{
  "filename": "wasm-go.md",
  "__html": "<h1>使用 GO 语言开发 WASM 插件</h1>\n<h1>一、工具准备</h1>\n<p>需要先安装 Golang 和 TinyGo 两个程序\n<a name=\"a81fa\"></a></p>\n<h2>1. Golang</h2>\n<p>（要求 1.18 版本以上）<br />官方指引链接：<a href=\"https://go.dev/doc/install\">https://go.dev/doc/install</a>\n<a name=\"JFoN6\"></a></p>\n<h3>Windows</h3>\n<ol>\n<li>下载安装文件：<a href=\"https://go.dev/dl/go1.19.windows-amd64.msi\">https://go.dev/dl/go1.19.windows-amd64.msi</a></li>\n<li>打开下载好的安装文件直接安装，默认会安装到 <code>Program Files</code> 或 <code>Program Files (x86)</code> 目录</li>\n<li>安装完成后，使用键盘上的快捷键“Win+R”打开运行窗口，在运行窗口中输入“cmd”点击确定即可打开命令窗口，输入命令：<code>go version</code>，输出当前安装的版本，表明安装成功\n<a name=\"tavPX\"></a></li>\n</ol>\n<h3>MacOS</h3>\n<ol>\n<li>下载安装文件：<a href=\"https://go.dev/dl/go1.19.darwin-amd64.pkg\">https://go.dev/dl/go1.19.darwin-amd64.pkg</a></li>\n<li>打开下载好的安装文件直接安装，默认会安装到<code>/usr/local/go</code>目录</li>\n<li>打开终端命令行工具，输入命令：<code>go version</code>，输出当前安装的版本，表明安装成功\n<a name=\"olPlT\"></a></li>\n</ol>\n<h3>Linux</h3>\n<ol>\n<li>下载安装文件：<a href=\"https://go.dev/dl/go1.19.linux-amd64.tar.gz\">https://go.dev/dl/go1.19.linux-amd64.tar.gz</a></li>\n<li>执行下列命令进行安装：</li>\n</ol>\n<pre><code class=\"language-bash\">rm -rf /usr/<span class=\"hljs-built_in\">local</span>/go &amp;&amp; tar -C /usr/<span class=\"hljs-built_in\">local</span> -xzf go1.19.linux-amd64.tar.gz\n<span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/<span class=\"hljs-built_in\">local</span>/go/bin\n</code></pre>\n<ol start=\"3\">\n<li>执行 <code>go version</code>，输出当前安装的版本，表明安装成功</li>\n</ol>\n<p><a name=\"qugm0\"></a></p>\n<h2>2. TinyGo</h2>\n<p>（要求 0.25.0 版本以上）<br />官方指引链接：<a href=\"https://tinygo.org/getting-started/install/\">https://tinygo.org/getting-started/install/</a>\n<a name=\"ELNis\"></a></p>\n<h3>Windows</h3>\n<ol>\n<li>下载安装文件：<a href=\"https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo0.25.0.windows-amd64.zip\">https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo0.25.0.windows-amd64.zip</a></li>\n<li>解压安装文件到指定目录</li>\n<li>如果安装解压后的目录为<code>C:\\tinygo</code>，则需要将<code>C:\\tinygo\\bin</code>添加到环境变量<code>PATH</code>中，例如通过在命令窗口中输入 set 命令设置</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">set</span> PATH=%PATH%;<span class=\"hljs-string\">\"C:\\tinygo\\bin\"</span>;\n</code></pre>\n<ol start=\"4\">\n<li>在命令窗口执行命令 <code>tinygo version</code>，输出当前安装的版本，表明安装成功\n<a name=\"iCo9z\"></a></li>\n</ol>\n<h3>MacOS</h3>\n<ol>\n<li>下载压缩包并解压</li>\n</ol>\n<pre><code class=\"language-bash\">wget https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo0.25.0.darwin-amd64.tar.gz\ntar -zxf tinygo0.25.0.darwin-amd64.tar.gz\n</code></pre>\n<ol start=\"2\">\n<li>如果安装解压后的目录为<code>/tmp</code>，则需要将<code>/tmp/tinygo/bin</code>添加到环境变量<code>PATH</code>中：</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">export</span> PATH=/tmp/tinygo/bin:<span class=\"hljs-variable\">$PATH</span>\n</code></pre>\n<ol start=\"3\">\n<li>在终端执行 <code>tinygo version</code>，输出当前安装的版本，表明安装成功\n<a name=\"hNZeF\"></a></li>\n</ol>\n<h3>Linux</h3>\n<p>以 Ubuntu 下 amd64 架构为例，其他系统请参考官方指引链接</p>\n<ol>\n<li>下载 DEB 文件，并安装</li>\n</ol>\n<pre><code class=\"language-bash\">wget https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo_0.25.0_amd64.deb\nsudo dpkg -i tinygo_0.25.0_amd64.deb\n<span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/<span class=\"hljs-built_in\">local</span>/bin\n</code></pre>\n<ol start=\"2\">\n<li>在终端执行 <code>tinygo version</code>，输出当前安装的版本，表明安装成功</li>\n</ol>\n<p><a name=\"QZbcA\"></a></p>\n<h1>二、编写插件</h1>\n<p><a name=\"u83FM\"></a></p>\n<h2>1. 初始化工程目录</h2>\n<ol>\n<li>新建一个工程目录文件，例如<code>wasm-demo-go</code></li>\n<li>在所建目录下执行以下命令，进行 Go 工程初始化</li>\n</ol>\n<pre><code class=\"language-bash\">go mod init wasm-demo-go\n</code></pre>\n<ol start=\"3\">\n<li>国内环境可能需要设置下载依赖包的代理</li>\n</ol>\n<pre><code class=\"language-bash\">go env -w GOPROXY=https://proxy.golang.com.cn,direct\n</code></pre>\n<ol start=\"4\">\n<li>下载构建插件的依赖</li>\n</ol>\n<pre><code class=\"language-bash\">go get github.com/tetratelabs/proxy-wasm-go-sdk\ngo get github.com/alibaba/higress/plugins/wasm-go@main\ngo get github.com/tidwall/gjson\n</code></pre>\n<p><a name=\"Z2lFM\"></a></p>\n<h2>2. 编写 main.go 文件</h2>\n<p>下面是一个简单示例，实现了在插件配置<code>mockEnable: true</code>时直接返回<code>hello world</code>应答；未做插件配置，或者设置<code>mockEnable: false</code>时给原始请求添加 <code>hello: world</code>请求头。更多例子请参考本文第四节。</p>\n<blockquote>\n<p>注意：在网关控制台中的插件配置为 yaml 格式，下发给插件时将自动转换为 json 格式，所以例子中的 parseConfig 可以直接从 json 中解析配置</p>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n        <span class=\"hljs-string\">\"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types\"</span>\n        <span class=\"hljs-string\">\"github.com/tidwall/gjson\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n        wrapper.SetCtx(\n                <span class=\"hljs-comment\">// 插件名称</span>\n                <span class=\"hljs-string\">\"my-plugin\"</span>,\n                <span class=\"hljs-comment\">// 为解析插件配置，设置自定义函数</span>\n                wrapper.ParseConfigBy(parseConfig),\n                <span class=\"hljs-comment\">// 为处理请求头，设置自定义函数</span>\n                wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),\n        )\n}\n\n<span class=\"hljs-comment\">// 自定义插件配置</span>\n<span class=\"hljs-keyword\">type</span> MyConfig <span class=\"hljs-keyword\">struct</span> {\n        mockEnable <span class=\"hljs-keyword\">bool</span>\n}\n\n<span class=\"hljs-comment\">// 在控制台插件配置中填写的yaml配置会自动转换为json，此处直接从json这个参数里解析配置即可</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">parseConfig</span><span class=\"hljs-params\">(json gjson.Result, config *MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">error</span></span> {\n        <span class=\"hljs-comment\">// 解析出配置，更新到config中</span>\n    \tconfig.mockEnable = json.Get(<span class=\"hljs-string\">\"mockEnable\"</span>).Bool()\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onHttpRequestHeaders</span><span class=\"hljs-params\">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">types</span>.<span class=\"hljs-title\">Action</span></span> {\n        proxywasm.AddHttpRequestHeader(<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"world\"</span>)\n        <span class=\"hljs-keyword\">if</span> config.mockEnable {\n                proxywasm.SendHttpResponse(<span class=\"hljs-number\">200</span>, <span class=\"hljs-literal\">nil</span>, []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"hello world\"</span>), <span class=\"hljs-number\">-1</span>)\n        }\n        <span class=\"hljs-keyword\">return</span> types.ActionContinue\n}\n</code></pre>\n<p><a name=\"SYNZJ\"></a></p>\n<h3>HTTP 处理挂载点</h3>\n<p>上面示例代码中通过 <code>wrapper.ProcessRequestHeadersBy</code>将自定义函数 <code>onHttpRequestHeaders</code>用于<code>HTTP 请求头处理阶段</code>处理请求。除此之外，还可以通过下面方式，设置其他阶段的自定义处理函数</p>\n<table>\n<thead>\n<tr>\n<th>HTTP 处理阶段</th>\n<th>触发时机</th>\n<th>挂载方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTTP 请求头处理阶段</td>\n<td>网关接收到客户端发送来的请求头数据时</td>\n<td>wrapper.ProcessRequestHeadersBy</td>\n</tr>\n<tr>\n<td>HTTP 请求 Body 处理阶段</td>\n<td>网关接收到客户端发送来的请求 Body 数据时</td>\n<td>wrapper.ProcessRequestBodyBy</td>\n</tr>\n<tr>\n<td>HTTP 应答头处理阶段</td>\n<td>网关接收到后端服务响应的应答头数据时</td>\n<td>wrapper.ProcessResponseHeadersBy</td>\n</tr>\n<tr>\n<td>HTTP 应答 Body 处理阶段</td>\n<td>网关接收到后端服务响应的应答 Body 数据时</td>\n<td>wrapper.ProcessResponseBodyBy</td>\n</tr>\n</tbody>\n</table>\n<p><a name=\"r6rK5\"></a></p>\n<h3>工具方法</h3>\n<p>上面示例代码中的 <code>proxywasm.AddHttpRequestHeader</code> 和 <code>proxywasm.SendHttpResponse</code>是插件 SDK 提供的两个工具方法，主要的工具方法见下表：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>方法名称</th>\n<th>用途</th>\n<th>可以生效的<br />HTTP 处理阶段</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>请求头处理</td>\n<td>GetHttpRequestHeaders</td>\n<td>获取客户端请求的全部请求头</td>\n<td>HTTP 请求头处理阶段<br /></td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpRequestHeaders</td>\n<td>替换客户端请求的全部请求头</td>\n<td>HTTP 请求头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpRequestHeader</td>\n<td>获取客户端请求的指定请求头</td>\n<td>HTTP 请求头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>RemoveHttpRequestHeader</td>\n<td>移除客户端请求的指定请求头</td>\n<td>HTTP 请求头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpRequestHeader</td>\n<td>替换客户端请求的指定请求头</td>\n<td>HTTP 请求头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>AddHttpRequestHeader</td>\n<td>新增一个客户端请求头</td>\n<td>HTTP 请求头处理阶段</td>\n</tr>\n<tr>\n<td>请求 Body 处理</td>\n<td>GetHttpRequestBody</td>\n<td>获取客户端请求 Body</td>\n<td>HTTP 请求 Body 处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>AppendHttpRequestBody</td>\n<td>将指定的字节串附加到客户端请求 Body 末尾</td>\n<td>HTTP 请求 Body 处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>PrependHttpRequestBody</td>\n<td>将指定的字节串附加到客户端请求 Body 的开头</td>\n<td>HTTP 请求 Body 处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpRequestBody</td>\n<td>替换客户端请求 Body</td>\n<td>HTTP 请求 Body 处理阶段</td>\n</tr>\n<tr>\n<td>应答头处理</td>\n<td>GetHttpResponseHeaders</td>\n<td>获取后端响应的全部应答头</td>\n<td>HTTP 应答头处理阶段<br /></td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpResponseHeaders</td>\n<td>替换后端响应的全部应答头</td>\n<td>HTTP 应答头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpResponseHeader</td>\n<td>获取后端响应的指定应答头</td>\n<td>HTTP 应答头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>RemoveHttpResponseHeader</td>\n<td>移除后端响应的指定应答头</td>\n<td>HTTP 应答头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpResponseHeader</td>\n<td>替换后端响应的指定应答头</td>\n<td>HTTP 应答头处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>AddHttpResponseHeader</td>\n<td>新增一个后端响应头</td>\n<td>HTTP 应答头处理阶段</td>\n</tr>\n<tr>\n<td>应答 Body 处理</td>\n<td>GetHttpResponseBody</td>\n<td>获取客户端请求 Body</td>\n<td>HTTP 应答 Body 处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>AppendHttpResponseBody</td>\n<td>将指定的字节串附加到后端响应 Body 末尾</td>\n<td>HTTP 应答 Body 处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>PrependHttpResponseBody</td>\n<td>将指定的字节串附加到后端响应 Body 的开头</td>\n<td>HTTP 应答 Body 处理阶段</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpResponseBody</td>\n<td>替换后端响应 Body</td>\n<td>HTTP 应答 Body 处理阶段</td>\n</tr>\n<tr>\n<td>HTTP 调用</td>\n<td>DispatchHttpCall</td>\n<td>发送一个 HTTP 请求</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpCallResponseHeaders</td>\n<td>获取 DispatchHttpCall 请求响应的应答头</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpCallResponseBody</td>\n<td>获取 DispatchHttpCall 请求响应的应答 Body</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpCallResponseTrailers</td>\n<td>获取 DispatchHttpCall 请求响应的应答 Trailer</td>\n<td>-</td>\n</tr>\n<tr>\n<td>直接响应</td>\n<td>SendHttpResponse</td>\n<td>直接返回一个特定的 HTTP 应答</td>\n<td>-</td>\n</tr>\n<tr>\n<td>流程恢复</td>\n<td>ResumeHttpRequest</td>\n<td>恢复先前被暂停的请求处理流程</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>ResumeHttpResponse</td>\n<td>恢复先前被暂停的应答处理流程</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p><a name=\"GAa0T\"></a></p>\n<h2>3. 编译生成 WASM 文件</h2>\n<p>执行以下命令</p>\n<pre><code class=\"language-bash\">tinygo build -o main.wasm -scheduler=none -target=wasi ./main.go\n</code></pre>\n<p>编译成功会在当前目录下创建文件 main.wasm。这个文件在下面本地调试的例子中也会被用到。<br />在使用云原生网关插件市场的自定义插件功能时，直接上传该文件即可。\n<a name=\"yJdN5\"></a></p>\n<h1>三、本地调试</h1>\n<p>TBD</p>\n<h1>更多示例</h1>\n<p><a name=\"vdifW\"></a></p>\n<h2>无配置插件</h2>\n<p>插件无需配置时，直接定义空结构体即可</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n        <span class=\"hljs-string\">\"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n        wrapper.SetCtx(\n                <span class=\"hljs-string\">\"hello-world\"</span>,\n                wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),\n        )\n}\n\n<span class=\"hljs-keyword\">type</span> MyConfig <span class=\"hljs-keyword\">struct</span> {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onHttpRequestHeaders</span><span class=\"hljs-params\">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">types</span>.<span class=\"hljs-title\">Action</span></span> {\n        proxywasm.SendHttpResponse(<span class=\"hljs-number\">200</span>, <span class=\"hljs-literal\">nil</span>, []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"hello world\"</span>), <span class=\"hljs-number\">-1</span>)\n        <span class=\"hljs-keyword\">return</span> types.ActionContinue\n}\n</code></pre>\n<p><a name=\"dSdLn\"></a></p>\n<h2>在插件中请求外部服务</h2>\n<p>目前仅支持 http 调用，支持访问在网关控制台中设置了服务来源的 Nacos、K8s 服务，以及固定地址或 DNS 来源的服务。请注意，无法直接使用<code>net/http</code>库中的 HTTP client，必须使用如下例中封装的 HTTP client。<br />下面例子中，在配置解析阶段解析服务类型，生成对应的 HTTP client ；在请求头处理阶段根据配置的请求路径访问对应服务，解析应答头，然后再设置在原始的请求头中。</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"errors\"</span>\n\t<span class=\"hljs-string\">\"net/http\"</span>\n\t<span class=\"hljs-string\">\"strings\"</span>\n\n    <span class=\"hljs-string\">\"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper\"</span>\n\t<span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm\"</span>\n\t<span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types\"</span>\n\t<span class=\"hljs-string\">\"github.com/tidwall/gjson\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\twrapper.SetCtx(\n\t\t<span class=\"hljs-string\">\"http-call\"</span>,\n\t\twrapper.ParseConfigBy(parseConfig),\n\t\twrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),\n\t)\n}\n\n<span class=\"hljs-keyword\">type</span> MyConfig <span class=\"hljs-keyword\">struct</span> {\n    <span class=\"hljs-comment\">// 用于发起HTTP调用client</span>\n\tclient      wrapper.HttpClient\n    <span class=\"hljs-comment\">// 请求url</span>\n\trequestPath <span class=\"hljs-keyword\">string</span>\n    <span class=\"hljs-comment\">// 根据这个key取出调用服务的应答头对应字段，再设置到原始请求的请求头，key为此配置项</span>\n\ttokenHeader <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">parseConfig</span><span class=\"hljs-params\">(json gjson.Result, config *MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">error</span></span> {\n\tconfig.tokenHeader = json.Get(<span class=\"hljs-string\">\"tokenHeader\"</span>).String()\n\t<span class=\"hljs-keyword\">if</span> config.tokenHeader == <span class=\"hljs-string\">\"\"</span> {\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"missing tokenHeader in config\"</span>)\n\t}\n\tconfig.requestPath = json.Get(<span class=\"hljs-string\">\"requestPath\"</span>).String()\n\t<span class=\"hljs-keyword\">if</span> config.requestPath == <span class=\"hljs-string\">\"\"</span> {\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"missing requestPath in config\"</span>)\n\t}\n\tserviceSource := json.Get(<span class=\"hljs-string\">\"serviceSource\"</span>).String()\n    <span class=\"hljs-comment\">// 固定地址和dns类型的serviceName，为控制台中创建服务时指定</span>\n    <span class=\"hljs-comment\">// nacos和k8s来源的serviceName，即服务注册时指定的原始名称</span>\n\tserviceName := json.Get(<span class=\"hljs-string\">\"serviceName\"</span>).String()\n\tservicePort := json.Get(<span class=\"hljs-string\">\"servicePort\"</span>).Int()\n\t<span class=\"hljs-keyword\">if</span> serviceName == <span class=\"hljs-string\">\"\"</span> || servicePort == <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"invalid service config\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">switch</span> serviceSource {\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"k8s\"</span>:\n\t\tnamespace := json.Get(<span class=\"hljs-string\">\"namespace\"</span>).String()\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.K8sCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tNamespace:   namespace,\n\t\t\tPort:        servicePort,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"nacos\"</span>:\n\t\tnamespace := json.Get(<span class=\"hljs-string\">\"namespace\"</span>).String()\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.NacosCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tNamespaceID: namespace,\n\t\t\tPort:        servicePort,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"ip\"</span>:\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.StaticIpCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tPort:        servicePort,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"dns\"</span>:\n\t\tdomain := json.Get(<span class=\"hljs-string\">\"domain\"</span>).String()\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.DnsCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tPort:        servicePort,\n\t\t\tDomain:      domain,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">default</span>:\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"unknown service source: \"</span> + serviceSource)\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onHttpRequestHeaders</span><span class=\"hljs-params\">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">types</span>.<span class=\"hljs-title\">Action</span></span> {\n    <span class=\"hljs-comment\">// 使用client的Get方法发起HTTP Get调用，此处省略了timeout参数，默认超时时间500毫秒</span>\n\tconfig.client.Get(config.requestPath, <span class=\"hljs-literal\">nil</span>,\n        <span class=\"hljs-comment\">// 回调函数，将在响应异步返回时被执行</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(statusCode <span class=\"hljs-keyword\">int</span>, responseHeaders http.Header, responseBody []<span class=\"hljs-keyword\">byte</span>)</span></span> {\n            <span class=\"hljs-comment\">// 用defer，在函数返回前恢复原始请求流程，继续往下处理，才能正常转发给后端服务</span>\n\t\t\t<span class=\"hljs-keyword\">defer</span> proxywasm.ResumeHttpRequest()\n            <span class=\"hljs-comment\">// 请求没有返回200状态码，进行处理</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> statusCode != http.StatusOK {\n\t\t\t\tlog.Errorf(<span class=\"hljs-string\">\"http call failed, status: %d\"</span>, statusCode)\n\t\t\t\tproxywasm.SendHttpResponse(http.StatusInternalServerError, <span class=\"hljs-literal\">nil</span>,\n\t\t\t\t\t[]<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"http call failed\"</span>), <span class=\"hljs-number\">-1</span>)\n\t\t\t\t<span class=\"hljs-keyword\">return</span>\n\t\t\t}\n            <span class=\"hljs-comment\">// 打印响应的HTTP状态码和应答body</span>\n            log.Infof(<span class=\"hljs-string\">\"get status: %d, request body: %s\"</span>, statusCode, responseBody)\n\t\t\t<span class=\"hljs-comment\">// 从应答头中解析token字段设置到原始请求头中</span>\n\t\t\ttoken := responseHeaders.Get(config.tokenHeader)\n\t\t\t<span class=\"hljs-keyword\">if</span> token != <span class=\"hljs-string\">\"\"</span> {\n\t\t\t\tproxywasm.AddHttpRequestHeader(config.tokenHeader, token)\n\t\t\t}\n\t\t})\n    <span class=\"hljs-comment\">// 需要等待异步回调完成，返回Pause状态，可以被ResumeHttpRequest恢复</span>\n\t<span class=\"hljs-keyword\">return</span> types.ActionPause\n}\n</code></pre>\n",
  "link": "/zh-cn/docs/user/wasm-go.html",
  "meta": {
    "title": "使用 GO 语言开发 WASM 插件",
    "keywords": "wasm",
    "description": "使用 GO 语言开发 WASM 插件"
  }
}