{"searchDocs":[{"title":"Higress在2023 KubeCon China的分享","type":0,"sectionRef":"#","url":"/zh-cn/blog/2023-kubecon","content":"","keywords":"Higress KubeCon","version":null},{"title":"分享简介​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#分享简介","content":"在9月26日的2023 KubeCon阿里云云原生开放日，Higress的分享内容分为两部分： Part 1. 由上海费芮网络科技系统运维副总监戴喜军，带来费芮在选型企业版Higress作为K8s Ingress替代Nginx Ingress的介绍 Part 2. 由Higress开源社区负责人澄潭，带来Higress开源项目的介绍 开源版和企业版是Higress的一体两面，通过本次分享，相信大家会对Higress有更全面的了解。 ","version":null,"tagName":"h2"},{"title":"Part 1. 费芮互动使用Higress作为Kubernetes Ingress实现稳定性和性能提升​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#part-1-费芮互动使用higress作为kubernetes-ingress实现稳定性和性能提升","content":"费芮通过Higress解决了原本Nginx Ingress网关的诸多痛点，性能提升90%，响应时间下降50%，并大幅提升业务入口的稳定及安全性，高效支撑每日1亿+粉丝交互， 4万+线下门店、每月3000万+笔的移动支付需求。 ","version":null,"tagName":"h2"},{"title":"费芮业务场景​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#费芮业务场景","content":" 费芮专注于移动营销、O2O、社交媒体、移动电商领域的创新与研发。费芮互动自主研发的自媒体平台运维超过2亿粉丝 ； 有超过4万家线下门店采用费芮O2O解决方案。费芮的主要客户包括优衣库，必胜客，肯德基，星巴克，SPG，欧莱雅，Innisfree，迪卡侬，顶新集团等。  费芮内部业务系统的日均发布次数达到100次之多，会涉及到400多条Ingress路由规则的日常更新，且网关每天需要承载的PV流量达到了1个亿。Ingress网关的性能和稳定性至关重要。 ","version":null,"tagName":"h3"},{"title":"Nginx Ingress 痛点​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#nginx-ingress-痛点","content":" 配置变更频繁，导致Nginx进程频繁重启，大量连接瞬时断开后并发重连会导致后端服务产生压力，严重时造成大量请求失败。  Nginx Ingress的Controller组件和Nginx组件运行在同一个POD中，控制面资源使用还会影响到数据面的性能。  Nginx Ingress还缺少面向服务限流的能力，只能实现面向单个来源IP限流，对于后端服务保护来说没有意义。 ","version":null,"tagName":"h3"},{"title":"Higress 收益​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#higress-收益","content":" Higress企业版采用了全托管架构，与业务集群分离，无需自己运维，稳定性有更好保障。  配置更新都是动态加载，无需重启数据面，保障业务平稳发布，websocket连接的业务收益也特别明显，长连接可以始终保持不会断开。  开启了TLS硬件加速，TLS握手时延直接减半，QPS吞吐提升86%。   开启WAF对吞吐影响还是比较明显的，下降了30%，但相比Ingress Nginx直接下降了90%，性能提升还是很明显，而且更大的优势是基于阿里云WAF产品，防护规则是实时更新的，而非Modsecurity的静态规则。  Higress集成了Sentinel限流的能力，可以直接面向服务的QPS吞吐上限/并发数上线进行限流，并且相比Nginx只能配置单机限制阈值，需要关注网关节点数量，Higress这里的配置是全局阈值，不受网关扩缩容影响。 触发限流后可以自定义响应内容或者重定向到指定地址，都是很实用的能力。 ","version":null,"tagName":"h3"},{"title":"Part 2. Higress开源之路：扎根开源生态，定义云原生网关​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#part-2-higress开源之路扎根开源生态定义云原生网关","content":"开源是云原生生态的基石，Higress也是借助了开源生态的力量，站在Istio/Envoy的肩膀上开发出了更多实用的功能，我们选择将MSE Higress（企业版）中的核心能力全部开源，决心扎根在开源生态中，让Higress变得更普惠，有更多人使用，从而让Higress更加强大。 ","version":null,"tagName":"h2"},{"title":"简介​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#简介","content":" Higress实际上有三次诞生过程：第一次是在阿里集团内部业务需求驱动下诞生；第二次是随着内部使用逐渐成熟沉淀为阿里云上的MSE Higress云原生网关产品；第三次是随着云产品成熟，2022年11月在云栖大会上正式宣布开源。2023年5月Release了第一个GA版本，意味着开源版本也走入成熟阶段。  从配置流转的过程来看Higress的架构： 首先用户可以通过UI控制台/命令行工具多种方式来下发配置到了控制面，如果是K8s下，配置持久化基于CRD，如果不是K8s，配置持久化基于Nacos除了用户下发的路由配置，实现服务路由还需要的服务IP地址信息，支持从K8s service/Nacos/Eureka/Consul/ZooKeeper/DNS/固定IP等多种方式获取Higress数据面是基于Envoy，配置通过xDS下发，这里复用了Istio的配置下发机制，因为是内置了这个机制，无需单独部署Istio最终配置下发到数据面生效，Higress基于Envoy扩展了很多能力，而且基于Wasm扩展机制，可以很方便开发自定义插件，且具备全局/域名/路由维度的生效粒度 ","version":null,"tagName":"h3"},{"title":"核心能力​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#核心能力","content":" 高集成：同时集成经典微服务生态和K8s开源生态能力，可以帮助业务从传统架构迁移到云原生架构，基于流量灰度等能力，可以保障这一过程的平滑  标准化：兼容Nginx Ingress常用注解，基于统一的Ingress标准可以轻松实现Nginx到Higress这一技术鸿沟的跨越，Higress也已经支持Gateway API，路由标准本身也能借助Higress实现平滑升级   易扩展：借助Higress的Wasm SDK，很少的业务代码就可以开发一个灵活的插件；并且支持基于OCI镜像标准分发，可以让插件的文档，配置约束等跟随插件本身一起被分发和共享；和传统Nginx类网关最大的差别，在于插件的分发集成阶段，实现了插件版本更新跟网关自身版本更新的解耦。   热更新：Envoy相比Nginx更合理的配置系统抽象，让Higress具备了Nginx Ingress无法实现的配置热更新能力 ","version":null,"tagName":"h3"},{"title":"回顾与展望​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#回顾与展望","content":" Higress开源的前半年，专注于开源生态的打通和易用性的提升，并基于Github Action构建了开源的集成测试体系，来保障项目质量，在今年5月份发布第一个GA稳定版本后，在多个核心社区开发者的努力下，我们又很快发布了1.1和1.2两个大版本，推出了非K8s部署/Knative支持等重量级功能。  未来的RoadMap，Higress会聚焦在Gateway API/插件生态/API管理三个方向上，随着社区开发团队的不断壮大，Higress已经建立了多个不同方向的SIG 并行推进核心功能演进，未来将不断有重量级功能推出，尽请期待。 ","version":null,"tagName":"h3"},{"title":"直播回看​","type":1,"pageTitle":"Higress在2023 KubeCon China的分享","url":"/zh-cn/blog/2023-kubecon#直播回看","content":"https://www.aliyun.com/activity/middleware/CloudNative_Meetup ","version":null,"tagName":"h2"},{"title":"30行代码写一个Wasm Go插件","type":0,"sectionRef":"#","url":"/zh-cn/blog/30-line-wasm","content":"","keywords":"higress wasm","version":null},{"title":"前言​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#前言","content":"在11月15号的直播 《Higress 开源背后的发展历程和上手 Demo 演示》中，为大家演示了 Higress 的 Wasm 插件如何面向 Ingress 资源进行配置生效，本文对当天的 Demo 进行一个回顾，并说明背后的原理机制。 本文中 Demo 运行的前提，需要在 K8s 集群中安装了 Higress，并生效了下面这份 quickstart 配置：https://higress.io/samples/quickstart.yaml这个 Demo 要实现的功能是一个 Mock 应答的功能，需要实现根据配置的内容，返回 HTTP 应答。 本文会按以下方式进行介绍： 编写代码：代码逻辑解析生效插件：说明代码如何进行编译打包并部署生效测试插件功能：说明全局粒度，路由/域名级粒度如何生效插件生效原理：对整体流程进行回顾，说明插件生效的原理三个革命性的特性：介绍 Wasm 插件机制为网关插件开发带来的变革 ","version":null,"tagName":"h2"},{"title":"编写代码​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#编写代码","content":"package main import ( . &quot;github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper&quot; &quot;github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm&quot; &quot;github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types&quot; &quot;github.com/tidwall/gjson&quot; ) func main() { SetCtx( &quot;my-plugin&quot;, ParseConfigBy(parseConfig), ProcessRequestHeadersBy(onHttpRequestHeaders), ) } type MyConfig struct { content string } func parseConfig(json gjson.Result, config *MyConfig, log Log) error { config.content = json.Get(&quot;content&quot;).String() return nil } func onHttpRequestHeaders(ctx HttpContext, config MyConfig, log Log) types.Action { proxywasm.SendHttpResponse(200, nil, []byte(config.content), -1) return types.ActionContinue }  上面代码中可以看到三个函数： main：插件通过 main 函数定义插件上下文，包括插件名称，用于解析配置的函数，以及用于处理请求/应答的函数 parseConfig：这个函数通过在 SetCtx 中指定的 ParseConfigBy 被挂载到插件配置解析阶段，传入的三个参数分别是： json：传入插件的配置，将统一序列化为一个 json 字典对象，提供 parseConfig 进行解析config：parseConfig 将解析后的插件配置输出到这个 MyConfig 对象log：提供日志输出接口 onHttpRequestHeaders：函数中调用的 proxywasm.SendHttpResponse，用于实现直接返回 HTTP 应答，这个函数通过在 SetCtx 中指定的 ProcessRequestHeadersBy 被挂载到解析请求 Header 的执行阶段，其他的挂载方式还有： ProcessRequestBodyBy：挂载到解析请求 Body 的执行阶段 ProcessResponseHeadersBy：挂载到构造应答 Header 的执行阶段 ProcessResponseBodyBy：挂载到构造应答 Body 的执行阶段 传入的三个参数分别是： ctx：用于获取请求上下文，如 scheme/method/path 等，通过 ctx 可以设置自定义上下文，能跨执行阶段访问 config：提供 parseConfig 解析好的自定义配置 log：提供日志输出接口 这个 30 行代码实现的插件功能比较简单，这里有一些功能相对复杂的例子：https://github.com/alibaba/higress/tree/main/plugins/wasm-go/extensions这里有插件 sdk 的详细使用文档：https://higress.io/zh-cn/docs/user/wasm-go.html这个插件 sdk 是基于 Tetrate 社区的 proxy-wasm-go-sdk 实现的，如果关注更底层的细节，可以查看：https://github.com/tetratelabs/proxy-wasm-go-sdkhttps://github.com/alibaba/higress/blob/main/plugins/wasm-go/pkg/wrapper可以看到，Higress 的 wasm-go sdk 是通过 Go 1.18 引入的泛型特性封装了插件上下文处理细节，从而降低插件开发所需代码量，开发者只用关心配置解析和请求应答处理的逻辑。 ","version":null,"tagName":"h2"},{"title":"生效插件​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#生效插件","content":"编写完成代码后，一共有三个步骤，实现插件逻辑的生效： 编译：将 go 代码编译成 Wasm 格式文件镜像推送：将 Wasm 文件打包成 docker 镜像，并推送至镜像仓库下发配置：在 K8s 上创建 WasmPlugin 资源 ","version":null,"tagName":"h2"},{"title":"编译​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#编译","content":"将上面的 Go 文件 main.go 编译成 plugin.wasm tinygo build -o plugin.wasm -scheduler=none -target=wasi -gc=custom -tags='custommalloc nottinygc_finalizer' main.go  ","version":null,"tagName":"h3"},{"title":"镜像推送​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#镜像推送","content":"编写 Dockerfile FROM scratch COPY plugin.wasm ./  构建并推送 Docker 镜像 （这里示例用的是 Higress 的官方镜像仓库） docker build -t higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/demo:1.0.0 . docker push higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/demo:1.0.0  ","version":null,"tagName":"h3"},{"title":"下发配置​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#下发配置","content":"编写 wasmplugin.yaml，配置说明： selector： 选中了默认安装在 higress-system 命名空间下的 higress-gateway 生效这份插件pluginConfig：插件配置，最终会被转换成上面代码中的 MyConfig 对象url：填写镜像地址，需要以&quot;oci://&quot;开头 除了这些配置外，还可以定义插件的执行阶段和优先级等进阶配置，可以参考 Istio API 官方文档：https://istio.io/latest/docs/reference/config/proxy_extensions/wasm-plugin/ # wasmplugin.yaml apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: request-block namespace: higress-system spec: defaultConfig: block_urls: - &quot;swagger.html&quot; url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/demo:1.0.0  通过 kubectl 创建这个资源 kubectl apply -f wasmplugin.yaml  ","version":null,"tagName":"h3"},{"title":"测试插件功能​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#测试插件功能","content":"基于之前生效的 quickstart.yaml，目前集群中的 Ingress 访问拓扑如下所示： ","version":null,"tagName":"h2"},{"title":"​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#ing-topopng","content":"未生效插件的情况下： 请求/foo 将返回 HTTP 应答 &quot;foo&quot;请求/bar 将返回 HTTP 应答 &quot;bar&quot; ","version":null,"tagName":"h3"},{"title":"全局生效​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#全局生效","content":"基于上文生效插件阶段，下发的 wasmplugin.yaml，生效插件后效果如下： 请求/foo 将返回 HTTP 应答 &quot;hello higress&quot;请求/bar 将返回 HTTP 应答 &quot;hello higress&quot; ","version":null,"tagName":"h3"},{"title":"域名&路由级生效​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#域名路由级生效","content":"将 wasmplugin.yaml 配置修改如下： # wasmplugin.yaml apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: request-block namespace: higress-system spec: defaultConfig: # 跟上面例子一样，这个配置会全局生效，但如果被下面规则匹配到，则会改为执行命中规则的配置 block_urls: - &quot;swagger.html&quot; matchRules: # 路由级生效配置 - ingress: - default/foo # default 命名空间下名为 foo 的 ingress 会执行下面这个配置 config: block_bodies: - &quot;foo&quot; - ingress: - default/bar # default 命名空间下名为 bar 的 ingress 会执行下面这个配置 config: block_bodies: - &quot;bar&quot; # 域名级生效配置 - domain: - &quot;*.example.com&quot; # 若请求匹配了上面的域名, 会执行下面这个配置 config: block_bodies: - &quot;foo&quot; - &quot;bar&quot; url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/demo:1.0.0  在 pluginConfig 中增加了 _rules_ 规则列表，规则中可以指定匹配方式，并填写对应生效的配置: match_route：匹配 Ingress 生效，匹配格式为：Ingress 所在命名空间 + &quot;/&quot; + Ingress 名称match_domain：匹配域名生效，填写域名即可，支持通配符 生效这份修改后的配置： kubectl apply -f wasmplugin.yaml  可以看到效果如下： 请求/foo 将返回 HTTP 应答 &quot;hello foo&quot; (匹配到第一条 rule)请求/bar 将返回 HTTP 应答 &quot;hello bar&quot; (匹配到第二条 rule)请求www.example.com 将返回 HTTP 应答 &quot;hello world&quot; （匹配到第三条 rule）请求www.abc.com 将返回 HTTP 应答 &quot;hello higress&quot; （没有匹配的 rule，使用全局配置） ","version":null,"tagName":"h3"},{"title":"插件生效原理​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#插件生效原理","content":" 这里对插件的生效机制简单做个说明： 用户将代码编译成 wasm 文件用户将 wasm 文件构建成 docker 镜像用户将 docker 镜像推送至镜像仓库用户创建 WasmPlugin 资源Istio watch 到 WasmPlugin 资源的变化Higress Gateway 中的 xDS proxy 进程从 Istio 获取到配置，发现插件的镜像地址xDS proxy 从镜像仓库拉取镜像xDS proxy 从镜像中提取出 wasm 文件Higress Gateway 中的 envoy 进程从 xDS proxy 获取到配置，发现 wasm 文件的本地路径envoy 从本地文件中加载 wasm 文件 这里 envoy 获取配置并加载 wasm 文件使用到了 ECDS (Extension Config Discovery Service)的机制，实现了 wasm 文件更新，直接热加载，不会导致任何连接中断，业务流量完全无损。 ","version":null,"tagName":"h2"},{"title":"三个革命性的特性​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#三个革命性的特性","content":"上面的 Wasm 插件机制为网关自定义插件开发带来了三个革命性的特性。 ","version":null,"tagName":"h2"},{"title":"特性一：插件生命周期和网关解耦​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#特性一插件生命周期和网关解耦","content":"这个特性主要得益于 Istio 的 WasmPlugin 机制设计。可以和 K8s Nginx Ingress 的插件机制做个对比： reference: https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/plugins/README.md Installing a plugin​ There are two options: mount your plugin into /etc/nginx/lua/plugins/ in the ingress-nginx podbuild your own ingress-nginx image like it is done in the example and install your plugin during image build 可以看到 Nginx Ingress 加载自定义插件，需要将 lua 文件挂载进 pod，或者在构建镜像时装入。这样就将插件的生命周期跟网关绑定在一起，插件逻辑更新，需要发布新版本，网关也需要发布新版本或者重新部署。 使用 WasmPlugin 的机制，插件需要发布新版本，只需构建插件自身的镜像并进行下发生效，而且可以基于镜像的 tag 进行插件的版本管理。这样插件变更，不仅无需重新部署网关，结合 Envoy 的 ECDS 机制对流量也是完全无损。 ","version":null,"tagName":"h3"},{"title":"特性二：高性能的多语言支持​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#特性二高性能的多语言支持","content":"基于 Wasm 的能力，可以用多种语言编写插件，对开发人员更加友好。实现多语言开发插件的另一种方式是基于 RPC 和网关进程通信的外置进程/服务插件，这种模式会有额外的 IO 开销，并且附加的进程/服务也带来额外的运维复杂度。目前大家对 Wasm 插件的性能比较关心，从我们的测试数据来看，指令执行性能相比原生的 C++ 语言确实有差距，但性能和 Lua 持平，且远好于外置插件。 对于一段逻辑：循环执行20次请求头设置，循环执行20次请求头获取，循环执行20次请求头移除。我们对比了分别用 Lua 和不同语言实现的 Wasm 的处理性能，下面是对单个请求延时的影响对比： 实现语言\t请求延时增加Lua\t0.20毫秒 Wasm (C++)\t0.19毫秒 Wasm (Go)\t0.20毫秒 Wasm (Rust)\t0.21毫秒 Wasm (AssemblyScript)\t0.21毫秒 ","version":null,"tagName":"h3"},{"title":"特性三：安全沙箱​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#特性三安全沙箱","content":"Envoy 目前支持多种 Wasm 的运行时，例如 V8，WAMR，wasmtime 等等，这些运行时均提供了安全沙箱能力，即 Wasm 插件中出现了访问空指针、异常未捕获等逻辑，也不会令 Envoy 宿主进程 Crash。并且可以通过配置，在插件逻辑出现异常后进行 Fail Open 处理，跳过插件的执行逻辑，将对业务的影响降至最低。 ","version":null,"tagName":"h3"},{"title":"开源社区​","type":1,"pageTitle":"30行代码写一个Wasm Go插件","url":"/zh-cn/blog/30-line-wasm#开源社区","content":"特别感谢 Istio/Envoy 社区的前置工作，让 Higress 可以实现对 Ingress 资源启用 WasmPlugin ，增强了 Ingress Controller 的自定义扩展能力。 特别感谢 Tetrate 社区实现的 proxy-wasm-go-sdk，Higress 在这个基础上封装了 wasm-go sdk，降低了开发插件的上手门槛。 Higress 对 Istio/Envoy 的 Wasm 能力做了一些 Bugfix 的工作，目前已经都合并进了上游社区。后续的一些 Feature 能力，也会持续反哺上游社区。 同时欢迎大家一起为 Higress 的插件以及其他社区生态添砖加瓦，为 Higress 贡献请参考文档：https://higress.io/zh-cn/docs/developers/guide_dev.html ","version":null,"tagName":"h2"},{"title":"如何使用 Higress Admin SDK 进行配置管理","type":0,"sectionRef":"#","url":"/zh-cn/blog/admin-sdk-intro","content":"","keywords":"Higress SDK Config","version":null},{"title":"3.1 环境准备​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#31-环境准备","content":"这里我们以本地基于 Kind 搭建的 K8s 集群作为实验环境。所以首先，请大家参考这篇文档在本地完成 K8s 集群的搭建和 Higress 的安装。 然后，我们需要创建一个测试用的 K8s 服务。大家可以将下方的 YAML 保存为 test.yaml，然后执行 kubectl apply -f test.yaml 命令在 K8s 中创建对应的资源。 kind: Pod apiVersion: v1 metadata: name: higress-demo-app namespace: default labels: app: higress-demo spec: containers: - name: higress-demo-app image: mendhak/http-https-echo:29 --- kind: Service apiVersion: v1 metadata: name: higress-demo-service namespace: default spec: selector: app: higress-demo ports: - port: 8080  ","version":null,"tagName":"h2"},{"title":"3.2 代码编写​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#32-代码编写","content":"这里的目标是创建一个路由，使 http://www.test.com/ 这个 URL 指向我们刚刚创建的 higress-demo-service。 ","version":null,"tagName":"h2"},{"title":"第一步：配置依赖​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#第一步配置依赖","content":"根据项目所使用的构建工具来添加 Higress Admin SDK 依赖： &lt;dependency&gt; &lt;groupId&gt;io.higress.api&lt;/groupId&gt; &lt;artifactId&gt;higress-admin-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.2&lt;/version&gt; &lt;/dependency&gt;  implementation 'io.higress.api:higress-admin-sdk:0.0.2'  ","version":null,"tagName":"h3"},{"title":"第二步：创建 Higress SDK 实例​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#第二步创建-higress-sdk-实例","content":"String kubeConfigFile = Paths.get(System.getProperty(&quot;user.home&quot;), &quot;/.kube/config&quot;).toString(); HigressServiceConfig config = HigressServiceConfig.builder().withKubeConfigPath(kubeConfigFile).build(); HigressServiceProvider provider = HigressServiceProvider.create(config);  这里我们使用的是 K8s 集群外的配置方式，所以需要设置 kubeConfig 文件的路径，以便 SDK 操作 K8s 内的各类资源。 ","version":null,"tagName":"h3"},{"title":"第二步：创建域名​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#第二步创建域名","content":"这里我们使用 SDK 中的 DomainService 来创建一个 www.test.com 域名，并将该域名设置为只开放 HTTP 访问。 Domain domain = Domain.builder().name(&quot;www.test.com&quot;).enableHttps(Domain.EnableHttps.OFF).build(); provider.domainService().add(domain);  ","version":null,"tagName":"h3"},{"title":"第三步：创建路由​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#第三步创建路由","content":"这里我们使用 SDK 中的 DomainService 来创建一个名为 higress-demo 的路由。路由绑定 www.test.com 域名，匹配所有以 / 开头的请求，并将请求转发至 higress-demo-service.default.svc.cluster.local 服务的 8080 端口。 Route route = Route.builder() .name(&quot;higress-demo&quot;) .domains(Collections.singletonList(&quot;www.test.com&quot;)) .path(RoutePredicate.builder() .matchType(RoutePredicateTypeEnum.PRE.name()) .matchValue(&quot;/&quot;) .build()) .services(Collections.singletonList( UpstreamService.builder() .name(&quot;higress-demo-service.default.svc.cluster.local:8080&quot;) .build() )).build(); provider.routeService().add(route);  ","version":null,"tagName":"h3"},{"title":"3.3 测试验证​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#33-测试验证","content":"执行编写好的代码：确认一切正常。然后在 Shell 中执行以下命令，检查请求路由情况。 curl -svk http://localhost/ -H &quot;Host: www.test.com&quot;  能够以 JSON 格式返回请求的详细信息就说明路由配置已经可以正常工作。 { &quot;path&quot;: &quot;/&quot;, &quot;headers&quot;: { &quot;host&quot;: &quot;www.test.com&quot;, &quot;user-agent&quot;: &quot;curl/8.4.0&quot;, &quot;accept&quot;: &quot;*/*&quot;, &quot;x-forwarded-for&quot;: &quot;10.42.0.230&quot;, &quot;x-forwarded-proto&quot;: &quot;http&quot;, &quot;x-envoy-internal&quot;: &quot;true&quot;, &quot;x-request-id&quot;: &quot;4a3db96b-c46c-4c8a-a60f-a513f258736d&quot;, &quot;x-envoy-decorator-operation&quot;: &quot;higress-demo-service.default.svc.cluster.local:8080/*&quot;, &quot;x-envoy-attempt-count&quot;: &quot;1&quot;, &quot;x-b3-traceid&quot;: &quot;a426d189c027371957f008c2cb2e9e8f&quot;, &quot;x-b3-spanid&quot;: &quot;57f008c2cb2e9e8f&quot;, &quot;x-b3-sampled&quot;: &quot;0&quot;, &quot;req-start-time&quot;: &quot;1707363093608&quot;, &quot;original-host&quot;: &quot;www.test.com&quot; }, &quot;method&quot;: &quot;GET&quot;, &quot;body&quot;: &quot;&quot;, &quot;fresh&quot;: false, &quot;hostname&quot;: &quot;www.test.com&quot;, &quot;ip&quot;: &quot;10.42.0.230&quot;, &quot;ips&quot;: [ &quot;10.42.0.230&quot; ], &quot;protocol&quot;: &quot;http&quot;, &quot;query&quot;: {}, &quot;subdomains&quot;: [ &quot;www&quot; ], &quot;xhr&quot;: false, &quot;os&quot;: { &quot;hostname&quot;: &quot;higress-demo-app&quot; }, &quot;connection&quot;: {} }  ","version":null,"tagName":"h2"},{"title":"4. 总结​","type":1,"pageTitle":"如何使用 Higress Admin SDK 进行配置管理","url":"/zh-cn/blog/admin-sdk-intro#4-总结","content":"目前 Higress Admin SDK 支持的功能还比较简单。未来社区也会在进一步着力增强 Higress 的治理侧功能，SDK 的能力也会不断完善。大家对 SDK 和 Console 有任何疑问和建议，都欢迎在 GitHub 上提出。感谢大家的支持！ 以上实操过程的项目代码可以在这里下载：下载链接 ","version":null,"tagName":"h2"},{"title":"基于文件配置实现 Higress 极简独立部署","type":0,"sectionRef":"#","url":"/zh-cn/blog/config-with-file","content":"","keywords":"higress file config","version":null},{"title":"前置准备​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#前置准备","content":"","version":null,"tagName":"h2"},{"title":"安装 Docker Compose​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#安装-docker-compose","content":"请参考 Docker 官方文档来安装 Docker Engine，其中已经内置了 Docker Compose 组件：https://docs.docker.com/engine/install/ ","version":null,"tagName":"h3"},{"title":"环境验证​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#环境验证","content":"启动终端；执行 docker compose version 命令，确认可以正常输出 Docker Compose 的版本。 Docker Compose version v2.20.2  ","version":null,"tagName":"h3"},{"title":"安装 Higrees​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#安装-higrees","content":"","version":null,"tagName":"h2"},{"title":"确定配置目录​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#确定配置目录","content":"由于这次我们准备使用文件来管理 Higress 的配置数据，所以需要先确定保存配置文件的目录。下面我们将以 ~/higress/conf 目录为例进行介绍。 ","version":null,"tagName":"h3"},{"title":"执行安装​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#执行安装","content":"启动终端，并执行以下命令： curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c file://~/higress/conf -p &lt;你的密码&gt; -a  请耐心等待安装过程执行完毕。Higress 的执行文件将被安装在当前目录下的 higress 子目录内。配置数据则将被写入 ~/higress/conf 目录内。 在安装完成后，脚本会自动启动 Higress。当终端输出如下信息时，则说明 Higress 已安装完成并成功启动。 Higress is now started. You can check out its status by executing /home/ch3cho/higress/bin/status.sh Higress Gateway is listening on: http://0.0.0.0:80 https://0.0.0.0:443 Visit Higress Console: http://localhost:8080/  ","version":null,"tagName":"h3"},{"title":"Higress 路由配置​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#higress-路由配置","content":"为了着重说明基于文件的路由配置方式，这里将不再展开介绍使用 Higress 控制台来进行配置的具体步骤。如有需要，大家可以查阅其他文档。 创建服务来源​ 使用文本编辑器将以下内容写入 ~/higress/conf/mcpbridges/default.yaml 文件中： apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: httpbin.org name: httpbin port: 80 type: dns  创建域名配置​ 使用文本编辑器将以下内容写入 ~/higress/conf/configmaps/domain-foo.bar.com.yaml 文件中： apiVersion: v1 kind: ConfigMap metadata: name: domain-foo.bar.com namespace: higress-system data: domain: foo.bar.com enableHttps: &quot;off&quot;  创建服务路由​ 使用文本编辑器将以下内容写入 ~/higress/conf/ingresses/route-foo-bar.yaml 文件中： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: httpbin.dns higress.io/ignore-path-case: &quot;false&quot; name: route-foo-bar namespace: higress-system spec: ingressClassName: higress rules: - host: foo.bar.com http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix  ","version":null,"tagName":"h3"},{"title":"请求验证​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#请求验证","content":"在终端中执行以下命令： curl http://localhost/get?foo=bar -H 'Host: foo.bar.com'  请求应返回一段包含请求信息的 JSON 数据： { &quot;args&quot;: { &quot;foo&quot;: &quot;bar&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Host&quot;: &quot;foo.bar.com&quot;, &quot;Original-Host&quot;: &quot;foo.bar.com&quot;, &quot;Req-Start-Time&quot;: &quot;1693049173053&quot;, &quot;User-Agent&quot;: &quot;curl/8.1.2&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-11111111-111111111111111111111111&quot;, &quot;X-B3-Sampled&quot;: &quot;0&quot;, &quot;X-B3-Spanid&quot;: &quot;2222222222222222&quot;, &quot;X-B3-Traceid&quot;: &quot;33333333333333333333333333333333&quot;, &quot;X-Envoy-Attempt-Count&quot;: &quot;1&quot;, &quot;X-Envoy-Decorator-Operation&quot;: &quot;httpbin.dns:80/*&quot;, &quot;X-Envoy-Internal&quot;: &quot;true&quot; }, &quot;origin&quot;: &quot;192.168.16.1, 123.123.123.123&quot;, &quot;url&quot;: &quot;http://foo.bar.com/get?foo=bar&quot; }  ","version":null,"tagName":"h3"},{"title":"已知问题​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#已知问题","content":"在 Windows 操作系统中，直接修改挂载到 Docker 容器中的本地文件后，容器内的进程无法收到通知（详情请查看 fsnotify/fsnotify #292）。如果要使用文件来保存配置数据的话，在直接修改配置文件后，Higress 无法立即加载到新的配置。如果需要在 Windows 上独立部署 Higress 网关，可以考虑通过 Higress Console 来管理配置信息，或使用 Nacos 保存网关配置。 ","version":null,"tagName":"h2"},{"title":"参考文档​","type":1,"pageTitle":"基于文件配置实现 Higress 极简独立部署","url":"/zh-cn/blog/config-with-file#参考文档","content":"更多相关信息与 Higress 的其他部署方式可查阅以下文档： 快速开始使用 Helm 进行云原生部署基于 Docker Compose 进行独立部署 ","version":null,"tagName":"h2"},{"title":"Higress助力AI大模型企业级应用落地","type":0,"sectionRef":"#","url":"/zh-cn/blog/ai_plugin","content":"","keywords":"Higress wasm AI plugin","version":null},{"title":"Higress 如何降低 AI 大模型使用成本？​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#higress-如何降低-ai-大模型使用成本","content":"Higress GitHub： https://github.com/alibaba/higress 以 OpenAI 为例，OpenAI 的 API 调用并不是基于请求量或者订阅时间来计费，而是基于每个请求的使用量来计费。对于 AI 大模型来说，模型输入与输出的 token 数可以比较好的衡量当前模型进行推理任务的复杂度。因此基于 token 作为请求使用量进行计费是 OpenAI-API 的标准计费策略。对于不同的模型 token 的计费标准也不同，越复杂的模型会生成越好的结果，但也会带来更高的计费。OpenAI 通过为用户分发 API 密钥来完成用户的鉴权与收费等功能。  对于组织来说，为每位成员申请 AI 大模型的访问权限（ API-Key ）显然是不现实的。分散的 API 密钥将不利于组织进行 API 的用量计算、管理与付费，从而增加 AI 大模型的使用成本。其次，对于组织来说，AI 模型的选型、使用频率和成员使用权限、以及向 AI 大模型暴露哪些数据都是在管理中需要着重关注的功能。 Higress 基于丰富的插件能力，提供了认证鉴权、请求过滤、流量控制、用量监测和安全防护等功能，能够帮助组织与 AI 大模型的 API 交互变得更加安全、可靠和可观察：基于 Higress 提供的认证鉴权能力，组织可以实现通过统一的 API 密钥进行 AI 模型的调用量管理和付费，并为团队成员授予不同的 AI 模型访问权限；基于 Higress 提供的流量控制能力，组织能为不同的模型与用户设置差异化的访问速率限制，有效降低 AI 模型的使用成本；基于 Higress 提供的请求拦截能力，组织能够有效过滤含敏感信息的访问请求，防护部分内部站点资源不对外暴露，从而有效保障内部数据安全；基于商业版 Higress提供的开箱即用的指标查询和日志记录的能力，组织能够完成对不同用户的 AI 模型调用的用量观测与分析，从而制定更加合理的 AI 模型使用策略。  ","version":null,"tagName":"h2"},{"title":"Higress 对接 OpenAI 大语言模型实战​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#higress-对接-openai-大语言模型实战","content":"下面我们将以 Higress 对接 OpenAI 大语言模型为例，介绍 Higress 如何无缝对接 AI 大模型。整体方案如图所示，我们基于 WASM 拓展了 Higress 插件，实现了对 OpenAI 语言模型的请求代理转发。基于 Higress 提供的 Key-Auth 认证插件的能力，我们实现统一 API-Key 下的多租户认证。基于 Higress 提供的 Request-Block 请求过滤的能力，我们将实现含敏感信息的请求拦截，保障用户数据安全。  ","version":null,"tagName":"h2"},{"title":"前提条件：​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#前提条件","content":"安装 Higress ，参考Higress 安装部署文档。准备 Go 语言开发 WASM 插件的开发环境，参考使用 GO 语言开发 WASM 插件。 ","version":null,"tagName":"h3"},{"title":"基于 WASM 的 AI Proxy Plugin​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#基于-wasm-的-ai-proxy-plugin","content":"下文将给出基于 Higress 与 WASM 实现的 AI 大模型 API 代理插件方案。Higress 支持基于 WASM 实现对外扩展的能力。WASM 插件提供的多语言生态和热插拔机制为插件的实现和部署提供了便利。Higress 同时支持在插件中请求外部服务，为 AI 代理插件的实现提供了高效的解决路径。 实现示例：​ 我们给出 OpenAI-API 的代理插件的实现示例，详情请参考AI proxy plugin。下列代码实现了插件相关配置完成之后，基于 HTTP 自动将请求代理转发到 OpenAI-API ，并接收来自 OpenAI-API 的响应，从而完成 AI 模型的调用，具体实现步骤如下： 通过 RouteCluster 方法指定具体的 OpenAI-API 的 host ，确认用户请求转发的具体路径，并新建用于请求代理转发的 HTTP Client 。 func parseConfig(json gjson.Result, config *MyConfig, log wrapper.Log) error { chatgptUri := json.Get(&quot;chatgptUri&quot;).String() var chatgptHost string if chatgptUri == &quot;&quot; { config.ChatgptPath = &quot;/v1/completions&quot; chatgptHost = &quot;api.openai.com&quot; } //请求默认转发到 OpenAI-API ... config.client = wrapper.NewClusterClient(wrapper.RouteCluster{ Host: chatgptHost, }) //通过 RouteCluster 方法确认请求转发的具体 host ... }  对用户请求进行 OpenAI-API 的格式封装，通过 HTTP Client 进行请求转发与响应接受，并将响应转发给用户。 //OpenAI API 接收的请求体模版，详见： https://platform.openai.com/docs/api-reference/chat const bodyTemplate string = ` { &quot;model&quot;:&quot;%s&quot;, &quot;prompt&quot;:&quot;%s&quot;, &quot;temperature&quot;:0.9, &quot;max_tokens&quot;: 150, &quot;top_p&quot;: 1, &quot;frequency_penalty&quot;: 0.0, &quot;presence_penalty&quot;: 0.6, &quot;stop&quot;: [&quot;%s&quot;, &quot;%s&quot;] } ` func onHttpRequestHeaders(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log) types.Action { ... //根据用户的请求内容进行 OpenAI-API 请求体封装 body := fmt.Sprintf(bodyTemplate, config.Model, prompt[0], config.HumanId, config.AIId) //通过 HTTP Client 进行转发 err = config.client.Post(config.ChatgptPath, [][2]string{ {&quot;Content-Type&quot;, &quot;application/json&quot;}, {&quot;Authorization&quot;, &quot;Bearer &quot; + config.ApiKey}, }, []byte(body), func(statusCode int, responseHeaders http.Header, responseBody []byte) { var headers [][2]string for key, value := range responseHeaders { headers = append(headers, [2]string{key, value[0]}) } //接收来自于 OpenAI-API 的响应并转发给用户 proxywasm.SendHttpResponse(uint32(statusCode), headers, responseBody, -1) }, 10000) ... }  在 Higress 中启用自定义的 AI-Proxy-Wasm 插件流程如下： 本示例提供已经编译好的 AI-proxy-plugin-wasm 文件并完成对应 docker 镜像的构建和推送，推荐配置如下所示： 名称\t推荐配置镜像地址\toci://registry.cn-hangzhou.aliyuncs.com/zwj_test/chatgpt-proxy:1.0.0 插件执行阶段\t鉴权阶段 插件执行优先级\t1 插件配置说明：​ 插件配置简单，支持全局/域名级/路由级的代理转发。推荐进行路由级配置：选中对应的路由配置-选中对应路由-策略-启用插件。配置字段包括： 名称\t数据类型\t填写要求\t默认值\t描述model\tstring\t选填\ttext-davinci-003\t调用的模型名称 apiKey\tstring\t必填\t-\tOpenAI-API 密钥，详情可参考 promptParam\tstring\t选填\tprompt\tprompt 的来源字段名称，URL 参数 chatgptUri\tstring\t选填\tapi.openai.com/v1/completions\t调用 AI 模型服务的 URL 路径，默认值为 OpenAI 的 API 调用路径 示例配置如下： apiKey: &quot;xxxxxxxxxxxxxxxxxx&quot; model: &quot;curie&quot; promptParam: &quot;text&quot;  根据该配置，网关代理到 OpenAI-API 下的 curie 模型，用户通过 text 关键字在 url 中输入文本。 curl &quot;http://{GatewayIP}/?text=Say,hello&quot;  得到 OpenAI-API 的响应： ","version":null,"tagName":"h3"},{"title":"基于 Key Auth 的多租户认证​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#基于-key-auth-的多租户认证","content":"不同于为每位成员颁发 OpenAI-API 密钥的形式，企业可以基于 Higress 网关提供的认证鉴权能力，依靠内部授权（如 Key Auth 等）来管理成员对 AI 模型对访问权限，从而限制成员可以使用的服务和模型，并依靠统一的 AI-API 密钥进行请求代理转发实现对 API 用量的统一管理。接下来以 Key Auth 为例介绍 Higress 的多租户认证能力。 Key Auth 插件实现了基于网关内 API Key 进行认证和鉴权的功能，支持从 HTTP 请求的 URL 参数或者请求头解析 API Key ，同时验证该 API 是否有权限访问。通过在Higress 控制台-插件市场-Key Auth进行全局配置和路由级配置，即可实现 Higress 网关的多租户认证。  consumers: - credential: &quot;xxxxxx&quot; name: &quot;consumer1&quot; - credential: &quot;yyyyyy&quot; name: &quot;consumer2&quot; global_auth: false in_header: true keys: - &quot;apikey&quot;   allow: [consumer1]  以上配置定义了指向 AI 模型服务的消费者组consumers，并且只有consumer1具备访问当前路由下 AI 模型服务的权限。 curl &quot;http://{GatewayIP}/?text=Say,hello&quot; #请求未提供 API-Key ，返回 401 curl &quot;http://{GatewayIP}/?text=Say,hello&quot; -H &quot;apikey:zzzzzz&quot; #请求提供的 API-Key 未在消费者组内，无权访问，返回 401 curl &quot;http://{GatewayIP}/?text=Say,hello&quot; -H &quot;apikey:yyyyyy&quot; #根据请求提供的 API-Keyy 匹配到的调用者无 AI 模型服务的访问权限，返回 403 curl &quot;http://{GatewayIP}/?text=Say,hello&quot; -H &quot;apikey:xxxxxx&quot; #请求合法且有 AI 模型服务访问权限，请求将被代理到 AI 模型，正常得到 OpenAI-API 的响应  Higress 除了提供网关级多租户认证外，还能提供限流等能力。Key Rate Limit 插件可以根据用户在消费组中的成员资格对用户请求速率进行限制，从而限制应用程序对高成本 AI 大模型服务的消耗。基于多租户认证与限流等功能，Higress 可以完全控制 AI 大模型 API 的访问权限、访问数量与调用成本。 ","version":null,"tagName":"h3"},{"title":"基于 Request Block 保障数据安全​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#基于-request-block-保障数据安全","content":"对于 AI 大模型尤其是语言模型来说，要得到良好的返回往往需要用户提供足够的提示（ prompt ）作为模型输入。这也意味着组织和个人可能会在提供提示的过程中面临数据泄漏的风险。因此如何在使用 AI 模型的过程中保障数据安全也是 API 调用方面临重要问题。保护数据安全涉及到对 AI 模型的 API 调用渠道进行严格的控制。一种方式是使用特定的经批准的模型与其发布的 API 。另一种方式是对含敏感信息的用户请求进行拦截。这可以通过在网关级别设置特定的请求拦截来实现。Higress 基于 Request Block 插件提供请求拦截能力，既能防止未经授权的模型访问用户信息，又能防止含敏感信息的用户请求暴露到外网。 Request Block 插件基于 URL 、请求头等特征屏蔽 HTTP 请求，可以用于防护站点资源不对外暴露。 通过在Higress 控制台-插件市场-Request Block进行屏蔽字段配置，即可防止含敏感字段的请求对外发送。  blocked_code: 404 block_urls: - password - pw case_sensitive: false  以上配置定义了当前路由下基于 URL 的屏蔽字段，其中含敏感信息（如 password 、pw ）的请求将被屏蔽。 curl &quot;http://{GatewayIP}/?text=Mypassword=xxxxxx&quot; -H &quot;apikey:xxxxxx&quot; curl &quot;http://{GatewayIP}/?text=pw=xxxxxx&quot; -H &quot;apikey:xxxxxx&quot; #上述请求将被禁止访问，返回 404  ","version":null,"tagName":"h3"},{"title":"基于商业版 Higress 的用量观测与分析​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#基于商业版-higress-的用量观测与分析","content":"对于组织来说，对各用户进行 AI 模型调用的用量观测和分析有助于了解其使用情况与产生的成本。对于个人用户，了解自己的调用量和开销也是必要的。因此，在网关层进行调用的观测和分析对于 AI 大模型的 API 管理是必要的能力。商业版 Higress与各种指标与日志系统进行了深度集成，提供了开箱即用的用量观测分析报告构建机制，可以实时查看各种 API 的使用情况，并根据各类参数进行过滤，从而更好的了解 API 使用情况。 以观察各用户对 OpenAI-Curie 模型的调用量为例，用户可通过MSE 管理控制台-云原生网关-网关实例-参数配置-日志格式调整中设置区分用户的可观测性参数请求头：x-mse-consumer，将其列入观测列表。之后进入观测分析-日志中心中设置使用统计图表功能即可完成对 API 的用量观测和分析。如下图所示，用户consumer1与用户consumer2的对 OpenAI-Curie 模型的调用量以饼状图形式呈现。 ","version":null,"tagName":"h3"},{"title":"加入 Higress 社区​","type":1,"pageTitle":"Higress助力AI大模型企业级应用落地","url":"/zh-cn/blog/ai_plugin#加入-higress-社区","content":" 如果您觉得 Higress 对您有帮助，欢迎前往github: Higress为我们 star 一下！ ","version":null,"tagName":"h2"},{"title":"教程：如何在本地开发和调试 Higress 控制台","type":0,"sectionRef":"#","url":"/zh-cn/blog/console-dev","content":"","keywords":"higress console","version":null},{"title":"概述​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#概述","content":"本文旨在介绍如何在本地使用 IDE 来进行 Higress 控制台（以下简称控制台）的开发和调试工作。 ","version":null,"tagName":"h2"},{"title":"代码结构​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#代码结构","content":"控制台的代码仓库地址为 https://github.com/higress-group/higress-console。 控制台项目使用了前后端分离的架构。在将代码下载到本地后，我们可以看到整个项目主要由以下三个目录组成：backend、frontend 和 helm。它们也分别对应了项目的三个部分：后端、前端和部署。 ","version":null,"tagName":"h2"},{"title":"Backend：后端部分​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#backend后端部分","content":"后端部分是一个使用 Maven 构建配置的 Java 项目，其中共有两个模块：sdk 和 console。 SDK​ sdk 中包含了定义了 Higress 治理平面的核心数据模型和业务逻辑，如路由模型、Wasm 插件模型、配置模型转换和读写逻辑等。它也同样作为一个独立产品发布到了 Maven 中央仓库。开发者可以世界使用这个 SDK 来进行面向 Higress 的治理功能开发（参考文档）。 项目中的核心包如下： config：SDK 初始化配置模型constant：各类常量model：各类配置模型service：核心业务逻辑服务 kubernetes：与 K8s 模型和 API 相关的服务 Console​ console 中定义了控制台所使用的 Restful API 和一些界面相关的非核心功能，例如监控看板管理、用户配置管理等。 项目中的核心包如下： client：封装访问外部 API 的客户端 constant：各类常量controller：Restful API 控制器service：业务服务逻辑 ","version":null,"tagName":"h3"},{"title":"Frontend：前端部分​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#frontend前端部分","content":"前端部分是一个 NodeJS 项目，使用基于 React 的应用研发框架飞冰（ICE）搭建。 整个项目的目录结构如下： public：项目中使用到的静态资源src：核心代码部分 components：在项目中被复用的小型组件interfaces：与 API 交互过程中需要使用到的数据模型locales：国际化资源文件models：前端页面上下文中需要使用到的数据模型pages：各个前端页面及其内部组件services：与 API 进行交互逻辑封装 ice.config.mts：飞冰的项目配置文件 ","version":null,"tagName":"h3"},{"title":"Helm：部署部分​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#helm部署部分","content":"控制台使用 Helm Chart 进行部署。这一部分就是 Helm Chart 的代码。整体代码结构遵循 Helm 的官方规范，可参考 Helm 官网。 ","version":null,"tagName":"h3"},{"title":"本地运行​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#本地运行","content":"","version":null,"tagName":"h2"},{"title":"后端部分​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#后端部分","content":"环境准备​ 控制台的正常运行依赖 Higress 核心组件，所以需要先准备一个安装好的 Higress 集群。大家可以参考这篇文档：链接。考虑到本地调试的便利度，建议大家使用本地 K8s 环境的方法进行安装。 控制台的后端项目要求 Java 版本不低于 17，所以请确认本地安装的 JDK 版本满足要求。 启动项目​ 控制台的外部服务依赖主要有两个，一个是 K8s API，另一个是 Higress Controller。 访问 K8s API，控制台默认使用的是本地默认的 kubeconfig （即 ~/.kube/config）。如果需要使用其他配置文件，则可以使用 HIGRESS_CONSOLE_KUBE_CONFIG 环境变量来指定对应的文件路径。 控制台在本地运行状态下，来访问 K8s 集群，使用本地的 15014 端口来访问 Higress Controller。可以使用以下命令将前面安装好的 Higress 实例中 controller 的 15014 端口映射到本地： kubectl port-forward deployment/higress-controller -n higress-system 15014   然后使用项目的主类 com.alibaba.higress.console.HigressConsoleApplication 进行启动即可。等待启动完成后，我们就可以使用 http://localhost:8080/ 来访问了。  如果你是第一次启动，那么访问上述地址的时候会发现并没有页面出现。如果只是要调试 API，这样也是可以正常进行的。但如果要结合网页进行调试，那么需要使用以下命令执行一次 Maven 构建，生成前端页面资源： ./mvnw clean package -Dmaven.test.skip=true   ","version":null,"tagName":"h3"},{"title":"前端部分​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#前端部分","content":"依赖安装​ 控制台的前端项目要求 NodeJS 的版本不低于 16，所以请确认本地安装的 NodeJS 版本满足要求。 然后使用以下命令安装项目所需的各个依赖包： npm install  项目启动​ 使用以下命令契合启动前端页面项目： npm start   默认情况下，前端页面会访问 Higress 官方提供的演示版控制台 API。如果不希望影响线上演示数据，或需要与后端 API 进行联调的话，可以修改项目根目录下的 ice.config.mts 文件，将其中的 http://demo.higress.io/ 替换为本地的服务地址（例如：http://127.0.0.1:8080/），然后重新启动前端项目。这样页面上访问的就是本地的测试服务了。  ","version":null,"tagName":"h3"},{"title":"镜像构建​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#镜像构建","content":"在命令行下进入 backend 目录并执行 build.sh 即可启动镜像构建。构建生成的镜像名称为 higress-console:0.0.1。 注意：如果尝试在 Windows 下构建，请务必确认该目录下的 start.sh 使用的是 Linux 的换行符（即 LF）。否则，构建生成的镜像将无法正常运行。  ","version":null,"tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress 控制台","url":"/zh-cn/blog/console-dev#总结","content":"控制台为用户提供了 Higress 治理侧的重要组成部分，为用户提供了基础的开箱即用体验。社区也会在控制台方面持续发力，为用户提供更丰富的、更便捷的网关治理体验。希望本文可以让更多的开发者加入控制台的研发队伍中，为控制台的升级迭代贡献一份力量。 欢迎参与阿里开源贡献👏 ","version":null,"tagName":"h2"},{"title":"欢迎报名Higress首次线下Meetup","type":0,"sectionRef":"#","url":"/zh-cn/blog/first-meetup","content":"","keywords":"higress meetup","version":null},{"title":"Windows 下 Higress 部署实践","type":0,"sectionRef":"#","url":"/zh-cn/blog/DeployOnWindows","content":"","keywords":"higress","version":null},{"title":"前置准备​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#前置准备","content":"","version":null,"tagName":"h2"},{"title":"配置 WSL2​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#配置-wsl2","content":"详情参看步骤1-5,顺便在微软商店中下载Terminal。 WSL手动安装步骤 ","version":null,"tagName":"h3"},{"title":"下载 Docker Desktop​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#下载-docker-desktop","content":"访问 Docker Desktop 官方下载页面 在浏览器中打开 Docker Desktop 的官方下载页面 下载 Docker Desktop 在下载页面，找到适用于 Windows 的 Docker Desktop 版本，然后点击下载。 运行安装程序 下载完成后，找到下载的安装程序（通常在你的 &quot;下载&quot; 文件夹中），然后双击运行。 ","version":null,"tagName":"h3"},{"title":"安装 Cygwin​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#安装-cygwin","content":"cygwin官网 选择setup-x86_64.exe，等待安装完成。 验证 Cygwin 安装是否成功​ cygcheck -c cygwin   为 Cygwin 配置环境变量​     点击确定即可添加成功 ","version":null,"tagName":"h3"},{"title":"安装 Higrees​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#安装-higrees","content":"","version":null,"tagName":"h2"},{"title":"准备 Nacos​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#准备-nacos","content":"nacos官网手册 我们这里选择nacos-docker的模式安装  下载解压zip文件,进入 nacos-docker-master 文件夹右键选择终端打开，执行命令，我们这里选择单机模式部署  docker-compose -f example/standalone-derby.yaml up  等待出现界面，即安装成功  ","version":null,"tagName":"h3"},{"title":"使用 Higrees 对接 Nacos​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#使用-higrees-对接-nacos","content":"安装命令：使用独立部署的 Nacos 当访问docker容器互相访问时候本地回环地址并不是真正的地址，所以需要在cygwin中执行获取本地网卡地址 ipconfig   curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.0.1:8848 --nacos-username=nacos --nacos-password=nacos  请将 192.168.0.1 替换为 Nacos 服务器的 IP（如果 Nacos 部署在本机，请不要使用如 localhost 或 127.0.0.1 的 Loopback 地址），并按需调整 --nacos-username 和 --nacos-password 的取值。如果 Nacos 服务未开启认证功能，则可以移除这两个参数。 在这里未开启授权服务，直接使用WLANIP替换对应的IP curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://10.30.0.225:8848  输入命令等待部署，即可看到生成的用户名与密码  ","version":null,"tagName":"h3"},{"title":"Higress 控制台配置​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#higress-控制台配置","content":"访问 http://localhost:8080/, 登录 Higress 控制台。首次访问时需要先设置用户名密码  点击左侧“服务来源”导航栏，然后点击页面右侧的“创建服务来源”按钮。按照下图所示内容填写表单并点击“确定”按钮。  点击左侧“域名管理”导航栏，然后点击页面右侧的“创建域名”按钮。按照下图所示内容填写表单并点击“确定”按钮。  点击左侧“路由管理”导航栏，然后点击页面右侧的“创建路由”按钮。按照下图片所示内容填写表单并点击“确定”按钮。  ","version":null,"tagName":"h3"},{"title":"请求验证​","type":1,"pageTitle":"Windows 下 Higress 部署实践","url":"/zh-cn/blog/DeployOnWindows#请求验证","content":"# should output a JSON object containing request data curl http://localhost/get?foo=bar -H 'host: foo.bar.com'   更多详情与部署方案可参考 quick start ","version":null,"tagName":"h3"},{"title":"阿里巴巴重磅开源云原生网关","type":0,"sectionRef":"#","url":"/zh-cn/blog/higress","content":"","keywords":"higress","version":null},{"title":"Higress的前世今生​","type":1,"pageTitle":"阿里巴巴重磅开源云原生网关","url":"/zh-cn/blog/higress#higress的前世今生","content":"","version":null,"tagName":"h2"},{"title":"诞生背景​","type":1,"pageTitle":"阿里巴巴重磅开源云原生网关","url":"/zh-cn/blog/higress#诞生背景","content":"Higress 的创建源于阿里内部的“本地生活战役”，该战役始于“支付宝2020合作伙伴大会”，在此大会上支付宝宣布升级为数字生活开放平台。该战役的核心技术目标，是实现阿里巴巴业务域与蚂蚁业务域之间 RPC 直接调用，但因阿里巴巴与蚂蚁业务域网络是隔离的，即网络是不通的，很自然想到利用网关来解决此问题。 ","version":null,"tagName":"h3"},{"title":"技术选型​","type":1,"pageTitle":"阿里巴巴重磅开源云原生网关","url":"/zh-cn/blog/higress#技术选型","content":"利用网关来解决阿里巴巴与蚂蚁跨业务域 RPC 互通问题，首先要对网关做技术选型。 相信大家也都或多或少知道，阿里巴巴开源的反向代理程序 Tengine。Tengine 在阿里内部统一接入网关 AServer 中被使用，我们团队就是负责其开发运维，同时我们团队也在负责阿里巴巴 Service Mesh 的落地，不管是对 Tengine 还是对 Istio + Envoy 这套架构都比较熟悉。 在选型时，虽然也调研过一些其他的软件，但考虑到网关对性能、可靠性的高要求，在结合我们自身的网关运维经验，决定看看 Tengine 与 Envoy 是否可以满足我们的业务需求，在对比时我们罗列了四个关键要点，其对比如下： 这里提一下“为什么我们认为配置的热更新，是非常重要的”？ Tengine/Nginx 的配置更新需要 reload，reload 需要重启 worker 进程，重启时会引起流量抖动，对长连接影响尤为明显。在网关的集群规模非常大时，更是不能随意的做 reload，这时就会引发一个矛盾点：业务向网关提交配置后，希望能快速验证，但受限于 reload 机制和稳定性要求，无法满足业务快速验证与快速试错的诉求。 现在已经有很多主流应用选择采用长连接，HTTP 1.1一般默认会使用Keep-Alive去保持长连接，后续HTTP 2以及HTTP 3也是如此，随着网络协议的发展，未来使用长连接会变得更加普遍。而配置热更新天然对长连接非常友好。 如何解决这点呢？ 一是采用两层网关，即流量网关 + 业务网关；二是实现网关原生支持配置热更新。除了对比不同方案的优劣势，我们也调研了 Envoy 作为网关在业界的趋势，结论是目前 Envoy 作为 K8s 中的 Ingress Provider 增长最快的事实（Ingress Provider 指 K8s Ingress 规范具体实现，因 K8s Ingress 自身只是规范定义，是 K8s 下外部流量进入集群内部的网关规范定义），我们最终选择了 Envoy 来实现两层网关。  ","version":null,"tagName":"h3"},{"title":"发展历程​","type":1,"pageTitle":"阿里巴巴重磅开源云原生网关","url":"/zh-cn/blog/higress#发展历程","content":"Higress从最初社区的 Istio + Envoy，到经历阿里巴巴内部的自研扩展，再到大规模生成验证，最后完成商业化产品的发布，其整个过程介绍如下： 下面的章节会对Higress的各个阶段做进一步的详细说明。 Higress (2020.05~2020.11) 此阶段的大目标是为了满足集团与蚂蚁RPC互通，降低全链路的RT，解决原s2s链路因RT过高带来的用户体验差及无法满足更多集团与蚂蚁协同场景要求。s2s链路是走公网链路，协议采用HTTP。与蚂蚁互通网关的架构图如下，这里以上海云单元为背景说明。  上图主要展示的是集团侧的架构，最终采用了Istio+Envoy的方案，在部署的时候又分成了出口集群和入口集群。之所以拆成两个集群，一方面是当时两边互访，蚂蚁调集团的流量要远远大于集团调蚂蚁的流量，上下行特别不均等；另一方面是分开之后两个集群可以各自维护，稳定性会更好。 Higress 从开始立项到完成第一期研发，网关改造的核心工作差不多两个人投入了一个半月左右，其中还涉及到大量网络、安全等协调部门的工作。Higress架构并没有完全按照社区方案来设计，社区版本中配置变更和服务发现使用的是K8s，在阿里内部庞大的服务规模及配置量下社区原生方案不管在稳定性及性能上都无法满足要求，因此阿里这套方案重点对服务发现、配置存储组件做了替换，及优化xDS推送性能。 Higress 上线后，顺利达成了最初的业务诉求，目前蚂蚁互通网关链路已经成为集团与蚂蚁互通的首选方案，一些支付链路也迁移到了该方案，例如充值中心等，具体达到的成果简述如下： 蚂蚁调用集团链路相比原链路RT降低50%，网关自身RT 0.3ms。Higress成功复制到集团与蚂蚁的消息互通，目前集团与蚂蚁的消息互通也是走的Higress Triple链路。微服务网关从5月份上线，目前已经成为集团与蚂蚁东西向流量的核心链路，飞猪、手淘、口碑、饿了么、1688、部分导购应用、商品库、评价等业务已成功上线，而且圆满支撑了618大促、支付宝717夏至大促。在2020双11大促每秒 数十万 的请求流量，圆满支撑了双11城市生活狂欢节的互动会场。在技术侧完成了Higress在东西向流量分发的探索。 Higress (2020.12~2021.10) 随着阿里巴巴上云战役的推进，越来越多的场景找到我们。比如云上云下业务互通，由于 Tengine 服务管理弱导致阿里内部大量二层微服务网关需要收敛，这就需要从业务上做 Tengine+Envoy 两层网关的演进，承担南北向网关流量。在 2020 年 12 月份，团队开始了Higress 架构的继续演进，以优酷场景为例的演进过程如下图：  Higress 南北向的架构图如下：  在两层架构中，Higress 网关更多承担了微服务网关和微服务治理的需求，和 Tengine 流量网关完成了整合。在这个过程里，团队支撑优酷内部多个二层微服务网关统一的工作，大幅提升了性能和运维效率。 在这一阶段，Higress Gateway 实现了东西向、南北向全域流量的调度分发，东西向上不仅支持跨业务域的蚂蚁 RPC 互通，也扩展到了混合云的云上云下 RPC 互通场景，覆盖钉钉文档、阿里视频云、达摩院的店小蜜、智慧数字人等。该阶段的业务大图如下（云上云下互通场景，以钉钉为例说明）：  随着 Higress Gateway 覆盖的业务场景越来多，在跟优酷持续合作的过程中，双方团队不约而同提出了一个设想：Tengine Gateway（承担流量网关角色） + Higress Gateway（承担微服务网关角色）的两层网关是否可以合并为一层 Higress Gateway？ 我们对这一想法做了调研，答案是肯定的，并且当时大家也合作设计了新的架构方案，如下图：  虽然由于各种各样的原因，这个方案最终没有跟优酷继续往下推进。但这个演进方向让团队明确了网关新的发展趋势：在以 K8s 主导的容器化背景下，由于K8s 集群内外网络的天然隔离性，用户需要一款兼顾高性能与安全性，以及强大服务治理能力的入口网关。这也为后续团队将技术沉淀变成云产品、推进Higress的诞生打下了基础。 2021 年，阿里巴巴开启了中间件三位一体战役，目标是用云产品支撑集团业务。我们开始将孵化成熟的Higress技术沉淀为云产品，即目前阿里云上提供的 MSE 云原生网关，一方面面向广大的公有云用户提供托管的网关服务，另一方面也对内服务集团。MSE 云原生网关的技术架构简图如下：  Higress (2021.11~2022.11) 随着Higress成为云产品服务于更多外部用户，我们逐步发现用户对Higress提出了更高的要求，其中反馈较多的大的需求点是插件扩展、Waf防护、多注册中心、Nginx Ingress注解兼容以及HTTP转Dubbo协议，当然也有很多小的需求点在此就不一一列出，因此该阶段我们重点发力在上述用户反馈的高频需求。 Higress 提供的插件市场，其一阶段支持Wasm插件，满足追求高性能、高安全的用户对网关的扩展诉求，二阶段会支持Lua插件，满足传统用户使用Lua的扩展的诉求，如Nginx用户，三阶段会支持进程外插件，满足多语言用户诉求，尤其是Java用户因现阶段Java社区对WebAssembly支持尚不完善但又希望对网关进行扩展的诉求。  Higress 也支持了Nginx Ingress注解平滑迁移的能力，满足部分用户期望迁移到Higress但又不希望重新配置网关的诉求，同时Higress打破了Nginx Ingress只能关联单个K8s集群的限制，支持关联多个K8s集群，即可以将Higress作为统一接入网关使用，同时又可以享受Ingress的红利。  对于传统使用Dubbo的微服务用户希望使用原生RPC方式暴露对外服务，但通常提供外部访问的服务以使用HTTP为主，为了帮助Dubbo用户降低服务暴露的开发成本，Higress提供了HTTP转Dubbo协议功能，且通过Console为用户提供白屏化的配置方式，某客户使用后反馈“这是业界完成度最高的HTTP转Dubbo协议”功能。  在云原生的浪潮下，开源已经成为软件发展的必然趋势与快速路径，因为社区的力量是非常强大的。因此我们将 这套经过内部实践沉淀下来的网关方案Higress正式对外开源，以Kubernetes Ingress网关为契机带来了流量网关与微服务网关融合的可能性，结合阿里内部实践沉淀Higress实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，同时深度集成了Dubbo、Nacos、Sentinel等，能够帮助用户极大的降低网关的部署及运维成本，而且能力不打折。  Higress 未来展望 虽然目前云原生已经成为必然趋势，但现实是有很大一部分用户处于迁移上云的过程中，在从传统架构向以Kubernetes 为代表的容器化云原生架构迁移，可预见这在未来很长一段时间会一直持续，因此 Higress 后续会重点支持非 Kubernetes 部署架构，以 Higress + Nacos 的组合形式为用户提供最小集运行环境，同时满足用户服务注册、配置管理、微服务治理的诉求。 在以 Kubernetes 为代表的容器化云原生方向，我们在兼容好现有 Ingress 标准的基础上，会重点发力下一代的Ingress 标准 Gateway API，利用 Gateway API 带来的契机打通南北向与东西向的全域流量调度，帮助用户使用一套架构架构同时管理外部与内部流量，降低部署运维成本、提升开发及运维效率。 ","version":null,"tagName":"h3"},{"title":"教程：如何在本地进行higress调试和端到端测试","type":0,"sectionRef":"#","url":"/zh-cn/blog/e2e-debug","content":"","keywords":"higress","version":null},{"title":"背景说明​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#背景说明","content":"","version":null,"tagName":"h2"},{"title":"本地调试​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#本地调试","content":"本地调试旨在在开发者的本地开发环境中识别、定位和修复代码中的错误（bug）。这个阶段的主要目标是确保单个模块或组件的正确性，以便更容易理解和解决问题。 开发者通常使用本地集成开发环境（IDE）或调试器来逐步执行代码、查看变量的值、观察程序的流程，并通过打断点来检查代码的执行过程。 本地调试是一个快速、迅速定位问题并进行修复的阶段，能够提供实时的反馈。它有助于确保代码的局部正确性，而不需要考虑整个系统的交互。 ","version":null,"tagName":"h3"},{"title":"端到端测试​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#端到端测试","content":"e2e测试是一种端到端的测试，是一种全面的测试方法，用于验证整个软件系统在真实环境中的功能和性能。它模拟用户的实际使用情况，确保整个系统的各个部分正确协同工作，以达到用户期望的功能。 端到端测试关注整个系统的集成和交互，旨在发现不同组件之间的问题以及在实际使用场景中可能出现的 bug。这有助于确保系统在生产环境中的稳定性和可靠性。 在higress中，e2e测试的主要流程可用下图来表示：  ","version":null,"tagName":"h3"},{"title":"弊端​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#弊端","content":"在本地开发的过程中，我们需要频繁的进行e2e测试，但是每次都要重新构建镜像、加载镜像、安装higress、运行e2e测试，这样的过程非常耗时，因此我们希望尽量地减少这些过程，复用测试环境以提高开发效率。 当e2e运行的时候出现问题，我们希望能够快速定位问题，这就需要在e2e测试中实现本地调试的功能。 另外，通常开发wasm插件的时候是不需要重新构建镜像的，只需要复用测试环境即可。然而，当涉及到higress-core组件代码(higress核心代码)修改的时候，就需要重新构建镜像，频繁地修改代码、重新构建镜像以运行e2e测试，这样开发效率就会大大降低。 ","version":null,"tagName":"h3"},{"title":"解决方案​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#解决方案","content":"不涉及higress-core组件修改 可分为端到端测试的优化和在端到端测试中实现本地调试的功能，端到端优化可采用实现测试环境复用的方法，通过修改makefile文件来减少环境的创建等开销。 而在端到端测试中实现本地调试的功能，可通过Goland来实现，提前准备好测试环境，修改e2e测试的部分代码来减少e2e环境创建的开销，更加方便的实现debug功能。 涉及higress-core组件修改 可在本地启动higress-core组件，并使其能够与kind集群中的discovery、gateway等组件进行交互。 例如在涉及到higress-config的ConfigMap修改的时候，其流程大致如下：  可以发现，只需要修改higress-core容器与discovery容器之间的xds协议通信地址，使其能够与本地的higress-core容器进行交互，其是注册在grpc服务上的，因此只需要修改xds地址为本地的grpc服务地址即可。 ","version":null,"tagName":"h3"},{"title":"具体实现​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#具体实现","content":"","version":null,"tagName":"h2"},{"title":"端到端测试优化​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#端到端测试优化","content":"通过makefile来完成，包含启动系列环境和执行e2e测试。 以运行插件测试为例，其make命令如下： .PHONY: higress-wasmplugin-test higress-wasmplugin-test: $(tools/kind) delete-cluster create-cluster docker-build kube-load-image install-dev-wasmplugin run-higress-e2e-test-wasmplugin delete-cluster  开发者首次运行环境可先删除最后一个delete-cluster的操作，第二次运行e2e测试的时候可以删除前面的操作，只保留run-higress-e2e-test-wasmplugin的操作，这样就可以减少很多时间。 然而make命令不支持添加到goland里面实现debug功能，运行出错的时候也不方便定位问题，更推荐使用下面这个方法。 ","version":null,"tagName":"h3"},{"title":"在e2e中实现本地调试​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#在e2e中实现本地调试","content":"通过Goland来完成，提前准备好环境，修改Goland启动参数来完成本地调试。 e2e测试之前的准备 根据各自的需求来定制环境，如果测试环境中需要用到higress的controller、gateway等组件，需要提前本地安装好环境，安装教程可参考这里，或者参考端到端测试优化步骤来准备好测试环境。 安装好higress后，可以使用如下命令来查看higress的pod是否正常运行： kubectl get pods --all-namespaces  显示结果如下图所示：  都显示Running状态，说明higress已经正常运行。 e2e的flag修改 在test/e2e/conformance/utils/flags目录下，有一个flags.go文件，里面定义了e2e测试的flag： var ( IngressClassName = flag.String(&quot;ingress-class&quot;, &quot;higress&quot;, &quot;Name of IngressClass to use for tests&quot;) ShowDebug = flag.Bool(&quot;debug&quot;, false, &quot;Whether to print debug logs&quot;) CleanupBaseResources = flag.Bool(&quot;cleanup-base-resources&quot;, true, &quot;Whether to cleanup base test resources after the run&quot;) SupportedFeatures = flag.String(&quot;supported-features&quot;, &quot;&quot;, &quot;Supported features included in conformance tests suites&quot;) ExemptFeatures = flag.String(&quot;exempt-features&quot;, &quot;&quot;, &quot;Exempt Features excluded from conformance tests suites&quot;) IsWasmPluginTest = flag.Bool(&quot;isWasmPluginTest&quot;, false, &quot;Determine if run wasm plugin conformance test&quot;) WasmPluginType = flag.String(&quot;wasmPluginType&quot;, &quot;GO&quot;, &quot;Define wasm plugin type, currently supports GO, CPP&quot;) WasmPluginName = flag.String(&quot;wasmPluginName&quot;, &quot;&quot;, &quot;Define wasm plugin name&quot;) IsEnvoyConfigTest = flag.Bool(&quot;isEnvoyConfigTest&quot;, false, &quot;Determine if run envoy config conformance test&quot;) )  可临时修改这些flag的初始值，也可以在Goland编辑器中定义启动参数，例如设置IsWasmPluginTest为true可只运行wasm插件的e2e测试。 修改好flag之后，我们就可以在Goland中通过debug的方式运行e2e测试。可先在如下位置添加一个断点，等待e2e环境准备完毕：  e2e测试在前期环境准备的过程中会创建一些namespace并启动一些pod，可以手动查看一下pod的启动情况。  在这张图里面，除了我们提前安装好的higress组件之外，还有一些其他的pod，这些pod是e2e测试过程中创建的，如果有些pod在本地e2e测试中用不到，可手动修改代码来减少前期环境的准备时间。 注意：如果设置了cleanup-base-resources为false，那么e2e测试结束之后，这些pod不会被删除，但是重启的时候会报错，例如： Pod &quot;consul-standlone&quot; is invalid: spec: Forbidden: pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds`, `spec.tolerations` (only additions to existing tolerations) or `spec.terminationGracePeriodSeconds` (allow it to be set to 1 if it was previously negative)  建议设置为true，每次测试完需要等待pod的销毁，然后重新测试，这些过程一般很快，也可以修改代码来减少一些pod的创建。 e2e测试环境优化 例如只需要higress环境，而不需要higress-conformance-infra,higress-conformance-app-backend等namespace环境，可以手动在如下几行代码里添加注释，来跳过这些环境的创建，然后测试中只用到了higress的组件：  在这里，我只需要运行EnvoyConfigTracing的Test测试，它只跟higress和higress-conformance-infra有关，注释掉了其他namespace的准备环境，可以看到e2e测试不到1s就结束了。 如果需要其他namespace的环境，而不需要nacos/consul等环境，可以在suite的New方法里找到以下代码块，根据需要进行注释： // apply defaults if suite.BaseManifests == nil { suite.BaseManifests = []string{ &quot;base/manifests.yaml&quot;, &quot;base/consul.yaml&quot;, &quot;base/eureka.yaml&quot;, &quot;base/nacos.yaml&quot;, &quot;base/dubbo.yaml&quot;, } }  解决好e2e测试的环境相关问题，我们就可以在Goland里添加自己想要的断点，来debug测试用例了。 ","version":null,"tagName":"h3"},{"title":"higress-core本地调试+e2e测试​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#higress-core本地调试e2e测试","content":"首先在本地启动higress-core组件，需要修改其启动参数，与正常部署的启动参数保持一致，可参考如下配置Goland的启动参数：  查找自己的本机非回环网卡的ip地址，例如我使用wlo0网卡，也就是192.168.0.189  修改xds协议地址，运行kubectl edit cm higress-config -n higress-system，将其修改本地的grpc服务地址，如图：  将其中的127.0.0.1:15051修改为192.168.0.189:15051，保存退出。 重启controller和gateway deployment，使其能够重新加载配置: kubectl rollout restart deployment higress-gateway -n higress-system  kubectl rollout restart deployment higress-controller -n higress-system   重启成功后可以先运行一下简单的e2e测试，比如http route等，测试是否能正常连通gateway，关于ConfigMap部分，我这里给本地higress-core添加了一个global-option的配置，此时kind的core组件还没有该配置，按照前面步骤启动本地higress-core并修改xds地址重启负载之后，运行相关的e2e测试，可以看到测试通过，本地higress-core日志以及kind上的discovery日志如下：  通过本地higress-core日志可以看到ads成功推送出去envoyfilter配置文件给discovery，而discovery日志则显示lds/rds/cds等成功将配置文件推送给gateway。 ","version":null,"tagName":"h3"},{"title":"hgctl code-debug的使用​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#hgctl-code-debug的使用","content":"hgctl已经推出code-debug的功能，会自动修改xds地址，使其能够与本地的higress-core进行交互。这里需要使用hgctl来安装higress，目前code-debug只支持local-k8s的profile。 hgctl安装higress hgctl install --set profile=local-k8s  等待安装完成后，手动查看一下是否启动成功。 启动本地higress-core 修改Goland启动参数为serve --kubeconfig=/root/.kube/config(改为自己的home目录)，然后启动higress-core，等待higress-core启动成功。 开启code-debug hgctl code-debug start  查看controller和gateway的pod是否重启成功，如果重启成功，说明code-debug已经生效。 其他环境准备 在后面的步骤上涉及到Ingress资源，这里需要准备一下Ingress资源，运行如下命令： kubectl apply -f - &lt;&lt;EOF apiVersion: v1 kind: Namespace metadata: name: higress-conformance-infra labels: higress-conformance: infra --- apiVersion: v1 kind: Service metadata: name: infra-backend-v1 namespace: higress-conformance-infra spec: selector: app: infra-backend-v1 ports: - protocol: TCP port: 8080 targetPort: 3000 --- apiVersion: apps/v1 kind: Deployment metadata: name: infra-backend-v1 namespace: higress-conformance-infra labels: app: infra-backend-v1 spec: replicas: 2 selector: matchLabels: app: infra-backend-v1 template: metadata: labels: app: infra-backend-v1 spec: containers: - name: infra-backend-v1 # From https://github.com/kubernetes-sigs/ingress-controller-conformance/tree/master/images/echoserver image: higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/echoserver:v20221109-7ee2f3e env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace resources: requests: cpu: 10m --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: higress-conformance-infra-configmap-global-test namespace: higress-conformance-infra spec: ingressClassName: higress rules: - host: &quot;foo.com&quot; http: paths: - pathType: Prefix path: &quot;/foo&quot; backend: service: name: infra-backend-v1 port: number: 8080 EOF  调试higress-core 以ConfigMap的gzip(位于pkg/ingress/kube/configmap/gzip.go)为例，修改NewDefaultGzip方法，将Enable的默认值修改为true，然后重启higress-core。 在重启之前，先运行如下shell命令，启动envoy查看面板： hgctl dashboard envoy  访问http://localhost:15000/config_dump，使用Ctrl+F搜索compression_level，可以看到查找结果为空，说明gzip配置还没有生效。 接下来重启higress-core，等待higress-core重启成功，再次访问http://localhost:15000/config_dump，使用Ctrl+F搜索compression_level，可以看到查找结果不为空，说明gzip配置已经生效。 关闭code-debug hgctl code-debug stop  ","version":null,"tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"教程：如何在本地进行higress调试和端到端测试","url":"/zh-cn/blog/e2e-debug#总结","content":"本地调试和e2e测试是开发过程中必不可少的环节，通过本文的介绍，我们可以更加方便的进行本地调试和e2e测试，提高开发效率。涉及到higress-core组件修改的时候，我们可以通过修改xds地址并本地启动higress-core，而不需要频繁地修改代码、重新构建镜像以运行e2e测试，并且还能调试higress-core组件的代码。higress后续会推出一些新功能，实现e2e测试的拆分，主要会分为准备环境，运行测试以及清除环境等，灵活性更高。 ","version":null,"tagName":"h2"},{"title":"Higress 团队招募小伙伴加入～","type":0,"sectionRef":"#","url":"/zh-cn/blog/hring","content":"","keywords":"higress hiring","version":null},{"title":"加入Higress的商业化Team​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#加入higress的商业化team","content":"我们商业化Team有充足的HC，欢迎加入👏，联系方式：微信(nomadao) 邮箱(zty98751@alibaba-inc.com) ","version":null,"tagName":"h2"},{"title":"团队介绍​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#团队介绍","content":"Higress团队属于阿里云云原生中间件团队。 阿里云云原生中间件团队负责分布式软件基础设施，为阿里云上万家企业提供如微服务引擎、分布式事务、EDAS等分布式基础服务，加速企业上云的进程和创新速度。同时，云原生中间件团队也服务着阿里集团众多核心业务和场景，是支撑双十一狂欢节的核心团队之一。 在这里，有非常优秀的中间件产品和场景以及企业互联网架构平台，服务上万家阿里云的企业，支持大规模电商交易业务场景。 在这里，你会参与到全球优秀开源项目（如 Apache Dubbo、RocketMQ、Nacos、Sentinel、Seata、Arthas、Tengine、Istio、Envoy、OpenSergo、Higress）和阿里云核心商业化产品（微服务引擎 MSE、企业级分布式应用服务 EDAS、应用实时监控服务ARMS）研发工作中，一同拓展技术的边界，既赋能阿里巴巴集团，更服务广泛的开发者用户。 在这里，你会参与到中间件、微服务、Serverless 等前沿的技术研发与探索中来；你也会与全球优秀开源产品创始人等组成的明星团队一起工作。 ","version":null,"tagName":"h3"},{"title":"负责工作​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#负责工作","content":"参与阿里云商业版Higress（MSE云原生网关）的产品研发参与Higress开源的产品研发和社群运营 ","version":null,"tagName":"h3"},{"title":"职位要求​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#职位要求","content":"3年以上产品研发工作经验，熟练使用Go或C++，有云原生相关产品研发经验者优先。有Higress/Envoy/Istio/Nginx开源贡献和开发经验者优先。具备出色的项目管理协调和业务规划能力，有团队合作精神，并能借助各方力量推动规则、制度等落地。 ","version":null,"tagName":"h3"},{"title":"加入Higress的开源Team​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#加入higress的开源team","content":"Higress为参与贡献的同学设计了几个可认领的头衔，达到一定贡献要求，即可在Higress官网提PR的方式认领。 头衔本身是一种荣誉象征，每一位参与Higress的贡献者在开源社区的地位都是平等的 ","version":null,"tagName":"h2"},{"title":"Member 头衔​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#member-头衔","content":"条件： 获得 8 个完成 issue 的积分（easy +1，normal +2，challenge +4） Higress开源社区为每个可认领（help wanted标签）的issue都标记了难度标签：简单(level/easy)，普通(level/normal)，有挑战(level/challenge)，完成issue后可以获得对应积分 贡献代码（包含文档）DIFF 行数（包含增删）达到 500+ 不仅只有贡献代码，在Higress官网仓库贡献文档，也可以满足此要求 在社区周会进行 1 次主题分享 重点不是分享的内容，是通过分享让大家认识你 申请方式： 直接提PR申请 ","version":null,"tagName":"h3"},{"title":"Reviewer 头衔​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#reviewer-头衔","content":"条件： 满足Member条件在SIG的核心 issue 中做出贡献 申请方式： 由Approvers/Maintainer提名后，提PR申请 ","version":null,"tagName":"h3"},{"title":"Approver 头衔​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#approver-头衔","content":"条件： 满足Reviewer条件主导一个SIG，组织并推进核心issue的tasklist完成 申请方式： 由Maintainer提名后，提PR申请 ","version":null,"tagName":"h3"},{"title":"Maintainer 头衔​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#maintainer-头衔","content":"Maintainer是对Higress项目（包括Higress下的项目）的演进和发展做出显著贡献的个人。在社区中具有有目共睹的影响力，能够代表Higress参加重要的社区会议和活动。 条件： 满足Approver条件主导多个SIG，组织并推进核心issue的tasklist完成积极参与开源社区的日常工作：引导新人开发，用户问题解答等 申请方式： 由2名Maintainer提名后，提PR申请 ","version":null,"tagName":"h3"},{"title":"已获得头衔名单​","type":1,"pageTitle":"Higress 团队招募小伙伴加入～","url":"/zh-cn/blog/hring#已获得头衔名单","content":"注：排名按 github id 首字母 Higress Maintainers​ 姓名\tgithub\t组织董艺荃\tCH3CHO\tTrip.com 耿蕾蕾\tgengleilei\tAlibaba 张添翼\tjohnlanni\tAlibaba 范扬\tSpecialYang\tAlibaba Higress Approvers​ 姓名\tgithub\t组织吴新军\t2456868764\t- 刘训灼\tXunzhuo\tTencent Higress Reviewers​ 姓名\tgithub\t组织凌轶群\tLynskylate\tPdd Holdings Inc 刘晓瑞\trinfx\tAlibaba 赵炳堃\tsjtuzbk\tAlibaba Higress Members​ 姓名\tgithub\t组织李强林\tCharlie17Li\tZJU-SEL 封宇腾\tFfyyt\tXUPT 田亚涛\tHinsteny\tAnt 宋鹏远\tsongpengyuan\tOkki.com 赵伟基\tvikizhao156\tSJTU 韦鑫\tWeixinX\tNUAA ","version":null,"tagName":"h3"},{"title":"Higress + Nacos 微服务网关最佳实践","type":0,"sectionRef":"#","url":"/zh-cn/blog/nacos","content":"","keywords":"higress wasm","version":null},{"title":"前言​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#前言","content":"在去年11月的云栖大会上，我们开源了云原生网关 Higress，时隔数月，Higress 的 Github 项目(https://github.com/alibaba/higress)已经收获了近 1k+ star，以及大量社区小伙伴的关注。 在社区的交流中我们发现有不少微服务开发者在使用如 Spring Cloud Gateway/Zuul 等微服务网关对接 Nacos 注册中心实现微服务的路由，并且希望了解迁移到 Higress 网关能带来哪些好处。 本文将介绍 Higress 组合 Nacos 作为微服务网关能力，并介绍微服务网关发展的两个趋势，为网关的选型指明道路： 趋势一：统一 API 标准，向云原生微服务架构演进趋势二：合并安全&amp;流量网关，向 DevSecOps 演进 ","version":null,"tagName":"h2"},{"title":"Higress：Nacos的最佳拍档​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#higressnacos的最佳拍档","content":"Higress 和 Nacos 其实是师出同门——阿里中间件团队。在 Higress 支撑阿里内部业务的阶段，Higress 就已经搭配 Nacos 作为微服务网关使用，凭借高性能支撑了双十一的洪峰流量；到了云产品商业化阶段，Higress 和 Nacos 继续基于阿里云 MSE（Microservices Engine）产品，紧密协作演进产品功能；Higress 开源之后，如果想要自建微服务网关，选择 Higress 配合 Nacos 使用，具备以下优势： 对比 Spring Cloud Gateway/Zuul 等传统 Java 微服务网关性能高出 2-4 倍，可以显著降低资源成本作为云原生网关，实现了 Ingress/Gateway API 标准，兼容 Nginx Ingress 大部分注解，支持业务渐进式向基于 K8s 的微服务架构演进与 Dubbo/OpenSergo/Sentinel 等开源微服务生态深度整合，提供最佳实践 这里默认已经安装好 Higress，搭配 Nacos 使用的具体方式如下： ","version":null,"tagName":"h2"},{"title":"配置服务来源​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#配置服务来源","content":"apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: # 定义一个名为 “production” 的服务来源 - name: production # 注册中心类型是 Nacos 2.x，支持 gRPC 协议 type: nacos2 # 注册中心的访问地址，可以是域名或者IP domain: 192.xxx.xx.32 # 注册中心的访问端口，Nacos 默认都是 8848 port: 8848 # Nacos 命名空间 ID nacosNamespaceId: d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358 # Nacos 服务分组 nacosGroups: - DEFAULT_GROUP # 定义一个名为 “uat” 的服务来源 - name: uat # 注册中心类型是 Nacos 1.x，只支持 HTTP 协议 type: nacos # 注册中心的访问地址，可以是域名或者IP domain: 192.xxx.xx.31 # 注册中心的访问端口，Nacos 默认都是 8848 port: 8848 # Nacos 命名空间 ID nacosNamespaceId: 98ac6df3-xxxx-xxxx-xxxx-ab98115dfde4 # Nacos 服务分组 nacosGroups: - DEFAULT_GROUP  我们通过 McpBridge 资源配置了两个服务来源，分别取名 “production”和“uat”，需要注意的是 Higress 对接 Nacos 同时支持 HTTP 和 gRPC 两种协议，建议将 Nacos 升级到 2.x 版本，这样可以在上述配置的 type 中指定 “nacos2” 使用 gRPC 协议，从而更快速地感知到服务变化，并消耗更少的 Nacos 服务端资源。 基于 McpBridge 中的 registries 数组配置，Higress 可以轻松对接多个且不同类型的服务来源（Nacos/Zookeeper/Eureka/Consul/...），这里对于 Nacos 类型的服务来源，支持配置多个不同命名空间，从而实现不同命名空间的微服务可以共用一个网关，降低自建微服务网关的资源成本开销。 ","version":null,"tagName":"h3"},{"title":"配置 Ingress​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#配置-ingress","content":"apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: service-provider.DEFAULT-GROUP.d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358.nacos name: demo namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix  和常见的 Ingress 在 backend 中定义 service 不同，这里基于 Ingress 的 resource backend 将上面定义服务来源的 McpBridge 进行关联。并通过注解higress.io/destination指定路由最终要转发到的目标服务。对于 Nacos 来源的服务，这里的目标服务格式为：“服务名称.服务分组.命名空间ID.nacos”，注意这里需要遵循 DNS 域名格式，因此服务分组中的下划线'_'被转换成了横杠'-'。 ","version":null,"tagName":"h3"},{"title":"丰富的微服务网关能力​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#丰富的微服务网关能力","content":"Higress 在微服务发现的基础上，提供了多种实用的微服务网关能力，这里以“灰度发布”和“自定义扩展”进行举例，更多能力可以点击原文参考 Higress 官网文档进行了解。 灰度发布​ Higress 完全兼容了 Nginx Ingress 的金丝雀（Canary）相关注解，如下所示，可以将带有HTTP Header为x-user-id: 100的请求流量路由到灰度服务中。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: service-provider.DEFAULT-GROUP.98ac6df3-xxxx-xxxx-xxxx-ab98115dfde4.nacos nginx.ingress.kubernetes.io/canary: 'true' nginx.ingress.kubernetes.io/canary-by-header: x-user-id nginx.ingress.kubernetes.io/canary-by-header-value: '100' name: demo-uat namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix  您还可以基于 OpenKruise Rollout 让灰度发布和服务部署过程联动，从而实现渐进式交付，具体可以参考这篇文章《Higress &amp; Kruise Rollout: 渐进式交付为应用发布保驾护航》 自定义扩展​ 作为微服务网关，需要在微服务架构中承担部分通用逻辑的处理，例如认证鉴权，安全防护等。通用的逻辑无法满足多样性的业务场景，Higress 可以支持开发者添加自定义处理逻辑。与 Spring Cloud Gateway 等传统微服务网关需要开发者自己在 Gateway 代码中加 Filter 不同，Higress 支持开发者使用多种语言编写 Wasm 插件，并动态加载生效，插件生效过程无需重启网关，变更插件逻辑对流量完全无损。 下例是一个屏蔽特定请求的 Wasm 插件，当请求 url 中出现 “swagger.html” 时将被直接拒绝访问，插件实现代码参考：https://github.com/alibaba/higress/tree/main/plugins/wasm-go/extensions/request-block apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: request-block namespace: higress-system spec: defaultConfig: block_urls: - &quot;swagger.html&quot; url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/demo:1.0.0  Wasm 插件的开发&amp;编译&amp;镜像推送方式可以参考这篇文章《Higress 实战：30 行代码写一个 Wasm Go插件》 ","version":null,"tagName":"h3"},{"title":"微服务网关发展趋势​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#微服务网关发展趋势","content":"","version":null,"tagName":"h2"},{"title":"趋势一：统一 API 标准，向云原生微服务架构演进​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#趋势一统一-api-标准向云原生微服务架构演进","content":"基于一套 API 可以有不同的实现，既让用户不被具体实现锁定，又桥接了技术演进的鸿沟。API 可以说是整个云原生架构的基石，或许有一天 K8s 会消失，但是面向抽象的 API 标准定会长存。在流量网关领域，Ingress API 已经成为标准。而对于微服务网关等更复杂的使用场景，Ingress 受限于其简单的协议字段，需要通过 Ingress 注解等方式进行能力扩展，难以被标准化。因此诸如 Contour、Emissary、Kong、APISIX 等都定义了自己的 HTTP 路由等 CRD，网关的 API 定义开始呈现碎片化。 这一背景之下，Gateway API 应运而生，并且在过去的一年里从 alpha 演进到了 beta 阶段。虽然目前 Gateway API 还未定稿，协议仍会发生变动，不建议用于生产，但 API 统一趋势已经不可阻挡，只是时间的问题。下图是 Gateway API 的一个用例场景，不同于 Ingress API，将集群运维和业务运维的职责进行了划分，这样业务开发人员不再需要关心网站证书等集群级的细节，只专注于业务本身的 DevOps，集群运维任务可以交给 SRE 人员进行统一处理。Higress 目前采用 Ingress 注解的能力来实现能力扩展，并兼容了 Nginx Ingress 大部分常用注解，且具备平滑迁移到 Gateway API 的能力。 Higress 为传统微服务架构，提供了渐进式的方式，向基于 K8s 的云原生微服务架构演进：可以通过 Nacos 发现部署在 K8s 之外的服务，从而实现了网关后端微服务可以和 K8s 解耦，业务团队可以将微服务逐个迁移至 K8s，而不用担心网关层的流量影响。 从传统微服务网关迁移到 Higress，再渐进式完成整个微服务架构的云原生化，是一个明智的选择。 ","version":null,"tagName":"h3"},{"title":"趋势二：合并安全&流量网关，向 DevSecOps 演进​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#趋势二合并安全流量网关向-devsecops-演进","content":"Higress 提出了将安全、流量、微服务网关三合一的概念，首先来看一个典型的多层网关架构：在这个架构中，用 WAF 网关实现安全能力，Ingress 网关实现集群入口网关能力（非 K8s 场景或会部署一层 Nginx），SCG（Spring Cloud Gateway） 实现微服务网关能力。这样的架构下，需要对每一层网关都进行容量评估，每一层网关都是潜在的瓶颈点，都可能需要进行扩容。这样造成的资源成本和运维人力成本都是巨大的。并且每多一层网关，就多一层可用性风险。一旦出现可用性问题，多层网关会导致问题定位复杂度显著上升，对应的平均故障恢复时间（MTTR）将大幅增加。采用三合一的架构中，可以显著降低成本，并提高系统整体可用性。同时这也符合 DevSecOps 的微服务演进趋势，微服务开发者可以更多地从业务接口视角关注安全性，而不是采用所有路由一刀切的 WAF 防护模式。 技术架构演进的背后是组织架构演进，这也是微服务 DevOps 一直在强调的，要围绕开发者为核心，从而提升微服务开发效率。向 DevSecOps 演进并没有捷径，依然需要开发角色和运维角色之间的双向奔赴，打破传统开发与运维之间的壁垒，形成从开发、部署、安全运营这样一个全功能化的敏捷团队。 通过 Higress 将网关合并作为向 DevSecOps 演进的抓手，是一个明智的选择。 ","version":null,"tagName":"h3"},{"title":"参与 Higress 社区​","type":1,"pageTitle":"Higress + Nacos 微服务网关最佳实践","url":"/zh-cn/blog/nacos#参与-higress-社区","content":"Higress 开源贡献小组正在火热招募贡献者。如果您有时间，有热情，有意愿，欢迎联系社区加入开源贡献小组，一起共同完善 Higress，一起主导下一代云原生网关的设计和实现。 社区官网（点击“阅读原文”跳转）: https://higress.io社区开发者群：社区交流群： ","version":null,"tagName":"h2"},{"title":"Higress 开源之夏项目报名","type":0,"sectionRef":"#","url":"/zh-cn/blog/ospp-2023","content":"","keywords":"higress summer-ospp","version":null},{"title":"开源之夏介绍​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#开源之夏介绍","content":"开源之夏是由中科院软件所“开源软件供应链点亮计划”发起并长期支持的一项暑期开源活动，旨在鼓励在校学生积极参与开源软件的开发维护，培养和发掘更多优秀的开发者，促进优秀开源软件社区的蓬勃发展，助力开源软件供应链建设。 目前开源之夏官网已经开启了学生报名，只要你满足以下要求即可进行项目申请： 本活动面向年满 18 周岁在校学生。暑期即将毕业的学生，只要在申请时学生证处在有效期内，就可以提交申请。中国籍学生参与活动需提供身份证、学生证、教育部学籍在线验证报告（学信网）或在读证明。外籍学生参与活动需提供护照，同时提供录取通知书、学生卡、在读证明等文件用于证明学生身份。 参与项目不仅可以为开源世界做出自己的贡献，还能获得丰厚的结项奖金（基础难度8000 RMB/进阶难度12000 RMB），项目经验也会成为你毕业简历上的亮点，快来报名吧！ 报名截止时间为 6 月 3 日 15 点，具体参考官网活动流程和参与指南介绍：  ","version":null,"tagName":"h2"},{"title":"Higress 介绍​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#higress-介绍","content":"Higress 是基于阿里内部两年多的实践沉淀，以开源 Istio 与 Envoy 为核心构建的下一代云原生网关。Higress 实现了安全防护网关、流量网关、微服务网关三层网关合一，可以显著降低网关的部署和运维成本。  Higress 在阿里内部的诞生和演进历程可以看这篇文章: 阿里巴巴重磅开源云原生网关: Higress Higress 开源半年时间，GitHub star 数已经破千，在上个月 Higress 已经 Release 出了第一个 RC 版本，作为正式 GA 的候选发布版本，详情可以查看这篇文章: 上线控制台，降低使用门槛｜Higress 1.0.0 RC 版本发布 在本次开源之夏活动中，Higress 有两个进阶难度的项目可以申请，欢迎各位同学踊跃报名。 ","version":null,"tagName":"h2"},{"title":"项目介绍​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#项目介绍","content":"","version":null,"tagName":"h2"},{"title":"项目一：Higress Wasm 插件构建/调试/部署的命令行实现​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#项目一higress-wasm-插件构建调试部署的命令行实现","content":"Higress 提供了很方便的 Wasm 插件扩展框架，具体可以查看这篇文章： 30行代码写一个Wasm Go插件 更详细的插件开发和调试流程可以查看这篇文章：使用 Go 语言开发 WASM 插件 这里对插件的生效机制简单做个说明：  用户将代码编译成 wasm 文件用户将 wasm 文件构建成 oci 镜像用户将 oci 镜像推送至镜像仓库用户创建 WasmPlugin 资源Istio watch 到 WasmPlugin 资源的变化Higress Gateway 中的 xDS proxy 进程从 Istio 获取到配置，发现插件的镜像地址xDS proxy 从镜像仓库拉取镜像xDS proxy 从镜像中提取出 wasm 文件Higress Gateway 中的 envoy 进程从 xDS proxy 获取到配置，发现 wasm 文件的本地路径envoy 从本地文件中加载 wasm 文件 这里 envoy 获取配置并加载 wasm 文件使用到了 ECDS (Extension Config Discovery Service)的机制，实现了 wasm 文件更新，直接热加载，不会导致任何连接中断，业务流量完全无损。 这个项目的初衷是希望能基于 Higress 的 CLI 命令行工具(hgctl) 来进一步简化 Higress Wasm 插件的开发调试和安装部署步骤，使之更容易上手使用。 需要实现的 hgctl 命令如下： hgctl plugin build：构建 wasm OCI 镜像并推送到指定仓库hgctl plugin test：启动 docker compose 测试插件功能hgctl plugin install/uninstall ：在当前higress集群中安装或卸载插件hgctl plugin config：修改制定插件的配置 Higress Wasm 插件配置基于 Openapi Specification （OAS 3.0）进行约束，需要能从代码中解析出插件配置字段格式，自动生成对应的 OAS 约束，用于添加到 OCI 镜像中，并同时用于 install/uninstall/config 等命令的参数配置校验 ","version":null,"tagName":"h3"},{"title":"项目二：基于 Wasm 实现 OIDC 认证插件​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#项目二基于-wasm-实现-oidc-认证插件","content":"Higress 作为一个云原生网关，需要实现 OIDC 认证的能力，方便用户对接外部认证服务。 OIDC （OpenID Connect） 是基于 OAuth 2.0 的身份认证协议，可以用于实现 SSO（Single Sign On）单点登录，即通过网关统一完成用户的身份认证，在身份认证成功后，再将资源请求转发给后端服务。  流程简介如下： 客户端向网关发起认证请求。网关将认证请求直接转发到给认证服务。认证服务读取请求中的验证信息（例如用户名、密码）进行验证，验证通过后返回Code给网关。网关将携带Code的应答返回给客户端。客户端向网关请求回调接口，请求中携带Code。网关请求认证服务颁发Token，请求中携带Code、Client ID、Client Secret。认证服务验证合法性，并返回ID Token。认证成功，网关将携带ID Token的应答返回给客户端。客户端向网关发起业务请求，请求中携带ID Token，网关校验请求中是否携带ID Token和合法性。网关校验客户端的业务请求合法，将请求透传给业务服务。业务服务进行业务处理后应答。网关将业务应答返回给客户端。 目前 Higress 也可以基于 Envoy 的 Ext Authz 机制对接外置的 oauth2-proxy 来实现鉴权，不过这个方案一方面有额外的请求开销，另一方面 oauth2-proxy 只能作一组 OIDC 配置，无法对接多个不同的认证服务 ","version":null,"tagName":"h3"},{"title":"加入社区​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#加入社区","content":"GitHub：https://github.com/alibaba/higress 官网: https://higress.io 对于报名方式有任何疑问，或者对某一个任务非常感兴趣，并且想要深入了解的同学，欢迎扫码添加微信，备注开源之夏  ","version":null,"tagName":"h2"},{"title":"相关项目推荐​","type":1,"pageTitle":"Higress 开源之夏项目报名","url":"/zh-cn/blog/ospp-2023#相关项目推荐","content":"对于微服务注册发现和配置管理有兴趣的同学，可以尝试填报 Nacos 开源之夏；对于微服务分布式事务有兴趣的同学，可以尝试填报 Seata 开源之夏；对于微服务框架和RPC框架有兴趣的同学，可以尝试填报 Spring Cloud Alibaba 和 Dubbo 开源之夏；对于分布式高可用防护有兴趣的同学，可以尝试填报 Sentinel 开源之夏；对于微服务治理有兴趣的同学，可以尝试填报 OpenSergo 开源之夏。 ","version":null,"tagName":"h2"},{"title":"Higress 全局配置控制面原理分析","type":0,"sectionRef":"#","url":"/zh-cn/blog/configmap","content":"","keywords":"higress","version":null},{"title":"整体架构流程​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#整体架构流程","content":"","version":null,"tagName":"h2"},{"title":"1. 整体架构​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#1-整体架构","content":" ","version":null,"tagName":"h3"},{"title":"2. 核心组件​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#2-核心组件","content":"IngressConfig IngressConfig 是 Higress 一个核心结构体, 负责监控 Ingress， McpBridge, Http2Rpc, WasmPlugin 等 k8s 资源， 同时集成 ConfigStore Interface，通过 List 接口下发 VirtualService, DestinationRule, EnvoyFilter, ServiceEntry, WasmPlugin 等 CR 资源。 ConfigmapMgr ConfigmapMgr 结构体负责整个核心流程，包括通过 Informer List/Watch 机制监控 higress-config 的变更，同时遍历 ItemControllers 下发变更通知，提供构建 EnvoyFilter 列表等功能。 TracingController TracingController 结构体负责具体的 Tracing 数据校验，构建 Tracing EnvoyFilter, 以及通过 ItemEventHandler 下发变更通知等。 HigressConfig HigressConfig 是 higress-config Configmap 所对应数据的结构体。 ","version":null,"tagName":"h3"},{"title":"3. 核心流程​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#3-核心流程","content":"用 Informer List/Watch 机制监控 higress-config 变更，校验变更，同时保存变更后数据。用变更数据构建 EnvoyFilter。通知 XDSUpdater，EnvoyFilter 有变更，重新拉取新的 EnvoyFilter 列表。 ","version":null,"tagName":"h3"},{"title":"初始化过程​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#初始化过程","content":"","version":null,"tagName":"h2"},{"title":"1. 初始化入口​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#1-初始化入口","content":"初始化过程入口在 NewIngressConfig， 初始化 IngressConfig 时同时构建 HigressConfigController 和 ConfigmapMgr。 // pkg/ingress/config/ingress_config.go func NewIngressConfig(localKubeClient kube.Client, XDSUpdater model.XDSUpdater, namespace, clusterId string) *IngressConfig { // ... // 构建 controller 和 configmapMgr higressConfigController := configmap.NewController(localKubeClient, clusterId, namespace) config.configmapMgr = configmap.NewConfigmapMgr(XDSUpdater, namespace, higressConfigController, higressConfigController.Lister()) return config }  ","version":null,"tagName":"h3"},{"title":"2. HigressConfigController 初始化​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#2-higressconfigcontroller-初始化","content":"通过 Higress 提供 NewCommonController 初始化 HigressConfigController 用于监听 higress-system 命名空间下 Configmap 的变化。 // pkg/ingress/kube/configmap/controller.go type HigressConfigController controller.Controller[listersv1.ConfigMapNamespaceLister] func NewController(client kubeclient.Client, clusterId string, namespace string) HigressConfigController { informer := client.KubeInformer().Core().V1().ConfigMaps().Informer() return controller.NewCommonController(&quot;higressConfig&quot;, client.KubeInformer().Core().V1().ConfigMaps().Lister().ConfigMaps(namespace), informer, GetConfigmap, clusterId) } func GetConfigmap(lister listersv1.ConfigMapNamespaceLister, namespacedName types.NamespacedName) (controllers.Object, error) { return lister.Get(namespacedName.Name) }  ","version":null,"tagName":"h3"},{"title":"3. ConfigmapMgr 初始化​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#3-configmapmgr-初始化","content":"ConfigmapMgr 初始化具体步骤如下： 构建 ConfigmapMgr设置 HigressConfigController configmap 新增或者更新回调函数为 configmapMgr.AddOrUpdateHigressConfig设置 HigressConfig 结构体默认值初始化 TracingController把 tracingController 添加到 configmapMgr itemControllers 数组里初始化 ItemEventHandler， 同时遍历 itemControllers，设置 ItemEventHandler // pkg/ingress/kube/configmap/controller.go func NewConfigmapMgr(XDSUpdater model.XDSUpdater, namespace string, higressConfigController HigressConfigController, higressConfigLister listersv1.ConfigMapNamespaceLister) *ConfigmapMgr { // 构建 ConfigmapMgr configmapMgr := &amp;ConfigmapMgr{ XDSUpdater: XDSUpdater, Namespace: namespace, HigressConfigController: higressConfigController, HigressConfigLister: higressConfigLister, higressConfig: atomic.Value{}, } // 设置 HigressConfigController configmap 新增或者更新回调函数 configmapMgr.AddOrUpdateHigressConfig configmapMgr.HigressConfigController.AddEventHandler(configmapMgr.AddOrUpdateHigressConfig) // 设置 HigressConfig 结构体默认值 configmapMgr.SetHigressConfig(NewDefaultHigressConfig()) // 初始化 TracingController tracingController := NewTracingController(namespace) // 把 tracingController 添加到 configmapMgr itemControllers 里 configmapMgr.AddItemControllers(tracingController) // 初始化 itemEventHandler， 同时遍历 itemControllers，设置 itemEventHandler configmapMgr.initEventHandlers() // 返回 configmapMgr return configmapMgr }  ","version":null,"tagName":"h3"},{"title":"启动​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#启动","content":"在 IngressConfig 添加 HigressConfigController Run() 和 HasSynced() 控制流程。 // pkg/ingress/config/ingress_config.go func (m *IngressConfig) Run(stop &lt;-chan struct{}) { // ... // 启动 HigressConfigController go m.configmapMgr.HigressConfigController.Run(stop) } func (m *IngressConfig) HasSynced() bool { // .... if !m.configmapMgr.HigressConfigController.HasSynced() { return false } }  ","version":null,"tagName":"h2"},{"title":"higress-config 变更和处理流程​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#higress-config-变更和处理流程","content":"","version":null,"tagName":"h2"},{"title":"1. configmapMgr 变更处理​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#1-configmapmgr-变更处理","content":"ConfigmapMgr 通过收到 HigressConfigController 通知来处理变更请求。 具体变更流程如下： 判断是否 higress-system 命名空间下 name 为 higress-config Configmap 发生了变化，如果不是就返回。获取 higress-config 内容。遍历 ItemControllers, 校验 higress-config 配置是否合法，如果有一个返回不合法，就返回。和上次保存在本地 higressConfig 比对, 检查这次数据是否有变化，如果没有变化就返回。如果数据有变化，就遍历 ItemControllers 通知每个 itemController 数据有变化，同时保存这次变化到本地 higressConfig。 // pkg/ingress/kube/configmap/controller.go func (c *ConfigmapMgr) AddOrUpdateHigressConfig(name util.ClusterNamespacedName) { // 只监听 higress-system 命名空间下 name 为 higress-config Configmap 的变化 if name.Namespace != c.Namespace || name.Name != HigressConfigMapName { return } // ... // 获取 higress-config 内容 higressConfigmap, err := c.HigressConfigLister.Get(HigressConfigMapName) // 通过 yaml.Unmarshal 转成 HigressConfig newHigressConfig := NewDefaultHigressConfig() if err = yaml.Unmarshal([]byte(higressConfigmap.Data[HigressConfigMapKey]), newHigressConfig); err != nil { IngressLog.Errorf(&quot;data:%s, convert to higress config error, error: %+v&quot;, higressConfigmap.Data[HigressConfigMapKey], err) return } // ... // 遍历 ItemControllers, 校验配置是否合法 for _, itemController := range c.ItemControllers { if itemErr := itemController.ValidHigressConfig(newHigressConfig); itemErr != nil { IngressLog.Errorf(&quot;configmap %s controller valid higress config error, error: %+v&quot;, itemController.GetName(), itemErr) return } } // 和上次比对这次数据是否有变更 oldHigressConfig := c.GetHigressConfig() result, _ := c.CompareHigressConfig(oldHigressConfig, newHigressConfig) // ... // 如果数据有变更，就遍历 ItemControllers 通知每个 itemController 数据有变更，同时保存这次变更到本地。 if result == ResultReplace || result == ResultDelete { for _, itemController := range c.ItemControllers { IngressLog.Infof(&quot;configmap %s controller AddOrUpdateHigressConfig&quot;, itemController.GetName()) if itemErr := itemController.AddOrUpdateHigressConfig(name, oldHigressConfig, newHigressConfig); itemErr != nil { IngressLog.Errorf(&quot;configmap %s controller AddOrUpdateHigressConfig error, error: %+v&quot;, itemController.GetName(), itemErr) } } // 保存这次变更 c.SetHigressConfig(newHigressConfig) } }  ","version":null,"tagName":"h3"},{"title":"2. TracingController 变更处理​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#2-tracingcontroller-变更处理","content":"TracingController 变更处理就比较简单： 检查 Tracing 这部分数据是否有变更。如果有变更，DeepCopy 一份 Tracing 数据保存到本地，同时通过 eventHandler 下发变更通知。 // pkg/ingress/kube/configmap/tracing.go func (t *TracingController) AddOrUpdateHigressConfig(name util.ClusterNamespacedName, old *HigressConfig, new *HigressConfig) error { // ... // 检查 Tracing 部分数据是否有变更 result, _ := compareTracing(old.Tracing, new.Tracing) // 如果有变更，DeepCopy 一份 Tracing 数据保存到本地，同时通过 eventHandler 下发变更通知 switch result { case ResultReplace: if newTracing, err := deepCopyTracing(new.Tracing); err != nil { IngressLog.Infof(&quot;tracing deepcopy error:%v&quot;, err) } else { t.SetTracing(newTracing) IngressLog.Infof(&quot;AddOrUpdate Higress config tracing&quot;) t.eventHandler(higressTracingEnvoyFilterName) IngressLog.Infof(&quot;send event with filter name:%s&quot;, higressTracingEnvoyFilterName) } case ResultDelete: t.SetTracing(NewDefaultTracing()) IngressLog.Infof(&quot;Delete Higress config tracing&quot;) t.eventHandler(higressTracingEnvoyFilterName) IngressLog.Infof(&quot;send event with filter name:%s&quot;, higressTracingEnvoyFilterName) } return nil }  ","version":null,"tagName":"h3"},{"title":"通知 XDSUpdater​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#通知-xdsupdater","content":"在 ConfigmapMgr 初始化时候调用 configmapMgr.initEventHandlers()， 这个 func 会创建 ItemEventHandler, 同时遍历 ItemControllers 设置 ItemEventHandler。 // pkg/ingress/kube/configmap/config.go type ItemEventHandler = func(name string) // pkg/ingress/kube/configmap/controller.go func (c *ConfigmapMgr) initEventHandlers() error { itemEventHandler := func(name string) { c.XDSUpdater.ConfigUpdate(&amp;model.PushRequest{ Full: true, ConfigsUpdated: map[model.ConfigKey]struct{}{{ Kind: gvk.EnvoyFilter, Name: name, Namespace: c.Namespace, }: {}}, Reason: []model.TriggerReason{ModelUpdatedReason}, }) } for _, itemController := range c.ItemControllers { itemController.RegisterItemEventHandler(itemEventHandler) } return nil }  这里 XDSUpdater 是从 IngressConfig 初始化传入， XDSUpdater.ConfigUpdate() 用于更新通知下发。 进一步跟踪可以发现在 Higress controller server 启动时执行 s.initXdsServer 函数创建 s.xdsServer，具体逻辑不在本文讨论范围, 有兴趣可以进一步阅读源码。 // pkg/bootstrap/server.go func NewServer(args *ServerArgs) (*Server, error) { // ... s := &amp;Server{ ServerArgs: args, httpMux: http.NewServeMux(), environment: e, readinessProbes: make(map[string]readinessProbe), server: server.New(), } s.environment.Watcher = mesh.NewFixedWatcher(&amp;v1alpha1.MeshConfig{}) s.environment.Init() initFuncList := []func() error{ s.initKubeClient, s.initXdsServer, s.initHttpServer, s.initConfigController, s.initRegistryEventHandlers, s.initAuthenticators, } for _, f := range initFuncList { if err := f(); err != nil { return nil, err } } // ... return s, nil } // pkg/bootstrap/server.go func (s *Server) initXdsServer() error { log.Info(&quot;init xds server&quot;) s.xdsServer = xds.NewDiscoveryServer(s.environment, nil, PodName, PodNamespace, s.RegistryOptions.KubeOptions.ClusterAliases) // ... return s.initGrpcServer() }  ","version":null,"tagName":"h2"},{"title":"构建和下发 EnvoyFilters​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#构建和下发-envoyfilters","content":"","version":null,"tagName":"h2"},{"title":"1. IngressConfig List 下发 EnvoyFilters 列表​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#1-ingressconfig-list-下发-envoyfilters-列表","content":"IngressConfig List 用于 VirtualService, DestinationRule, EnvoyFilter, ServiceEntry, WasmPlugin 等 CR 资源下发， 这里主要关注 EnvoyFilter CR 资源下发。 // pkg/ingress/config/ingress_config.go func (m *IngressConfig) List(typ config.GroupVersionKind, namespace string) ([]config.Config, error) { if typ != gvk.Gateway &amp;&amp; typ != gvk.VirtualService &amp;&amp; typ != gvk.DestinationRule &amp;&amp; typ != gvk.EnvoyFilter &amp;&amp; typ != gvk.ServiceEntry &amp;&amp; typ != gvk.WasmPlugin { return nil, common.ErrUnsupportedOp } // ... if typ == gvk.EnvoyFilter { m.mutex.RLock() defer m.mutex.RUnlock() var envoyFilters []config.Config // 调用 ConfigmapMgr ConstructEnvoyFilters 获取需要下发 EnvoyFilter 列表 configmapEnvoyFilters, err := m.configmapMgr.ConstructEnvoyFilters() if err != nil { IngressLog.Errorf(&quot;Construct configmap EnvoyFilters error %v&quot;, err) } else { for _, envoyFilter := range configmapEnvoyFilters { envoyFilters = append(envoyFilters, *envoyFilter) } IngressLog.Infof(&quot;Append %d configmap EnvoyFilters&quot;, len(configmapEnvoyFilters)) } if len(envoyFilters) == 0 { IngressLog.Infof(&quot;resource type %s, configs number %d&quot;, typ, len(m.cachedEnvoyFilters)) return m.cachedEnvoyFilters, nil } // 需要下发 configmap EnvoyFilter 列表 和 m.cachedEnvoyFilters 列表聚合一下下发 envoyFilters = append(envoyFilters, m.cachedEnvoyFilters...) IngressLog.Infof(&quot;resource type %s, configs number %d&quot;, typ, len(envoyFilters)) return envoyFilters, nil } }  调用 ConfigmapMgr ConstructEnvoyFilters 获取需要下发 EnvoyFilter 列表， 同时和 m.cachedEnvoyFilters 列表聚合一下再下发。 这里 m.cachedEnvoyFilters 是在构建 VirtualService 时生成，有兴趣可以进一步阅读 IngressConfig 源码。 ","version":null,"tagName":"h3"},{"title":"2. ConfigmapMgr 构建 EnvoyFilter 列表​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#2-configmapmgr-构建-envoyfilter-列表","content":"这里比较简单，遍历一下 ItemControllers，聚合每个 itemController 返回的 EnvoyFilters. // /pkg/ingress/kube/configmap/controller.go func (c *ConfigmapMgr) ConstructEnvoyFilters() ([]*config.Config, error) { configs := make([]*config.Config, 0) for _, itemController := range c.ItemControllers { IngressLog.Infof(&quot;controller %s ConstructEnvoyFilters&quot;, itemController.GetName()) if itemConfigs, err := itemController.ConstructEnvoyFilters(); err != nil { IngressLog.Errorf(&quot;controller %s ConstructEnvoyFilters error, error: %+v&quot;, itemController.GetName(), err) } else { configs = append(configs, itemConfigs...) } } return configs, nil }  ","version":null,"tagName":"h3"},{"title":"3. TracingController 构建 EnvoyFilters​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#3-tracingcontroller-构建-envoyfilters","content":"这里就比较简单，根据保存的 Tracing 数据构建对应的 EnvoyFilter // pkg/ingress/kube/configmap/tracing.go func (t *TracingController) ConstructEnvoyFilters() ([]*config.Config, error) { // ... tracingConfig := t.constructTracingTracer(tracing, namespace) if len(tracingConfig) == 0 { return configs, nil } config := &amp;config.Config{ Meta: config.Meta{ GroupVersionKind: gvk.EnvoyFilter, Name: higressTracingEnvoyFilterName, Namespace: namespace, }, Spec: &amp;networking.EnvoyFilter{ ConfigPatches: []*networking.EnvoyFilter_EnvoyConfigObjectPatch{ { ApplyTo: networking.EnvoyFilter_NETWORK_FILTER, Match: &amp;networking.EnvoyFilter_EnvoyConfigObjectMatch{ Context: networking.EnvoyFilter_GATEWAY, ObjectTypes: &amp;networking.EnvoyFilter_EnvoyConfigObjectMatch_Listener{ Listener: &amp;networking.EnvoyFilter_ListenerMatch{ FilterChain: &amp;networking.EnvoyFilter_ListenerMatch_FilterChainMatch{ Filter: &amp;networking.EnvoyFilter_ListenerMatch_FilterMatch{ Name: &quot;envoy.filters.network.http_connection_manager&quot;, }, }, }, }, }, Patch: &amp;networking.EnvoyFilter_Patch{ Operation: networking.EnvoyFilter_Patch_MERGE, Value: util.BuildPatchStruct(tracingConfig), }, }, { ApplyTo: networking.EnvoyFilter_HTTP_FILTER, Match: &amp;networking.EnvoyFilter_EnvoyConfigObjectMatch{ Context: networking.EnvoyFilter_GATEWAY, ObjectTypes: &amp;networking.EnvoyFilter_EnvoyConfigObjectMatch_Listener{ Listener: &amp;networking.EnvoyFilter_ListenerMatch{ FilterChain: &amp;networking.EnvoyFilter_ListenerMatch_FilterChainMatch{ Filter: &amp;networking.EnvoyFilter_ListenerMatch_FilterMatch{ Name: &quot;envoy.filters.network.http_connection_manager&quot;, SubFilter: &amp;networking.EnvoyFilter_ListenerMatch_SubFilterMatch{ Name: &quot;envoy.filters.http.router&quot;, }, }, }, }, }, }, Patch: &amp;networking.EnvoyFilter_Patch{ Operation: networking.EnvoyFilter_Patch_MERGE, Value: util.BuildPatchStruct(`{ &quot;name&quot;:&quot;envoy.filters.http.router&quot;, &quot;typed_config&quot;:{ &quot;@type&quot;: &quot;type.googleapis.com/envoy.extensions.filters.http.router.v3.Router&quot;, &quot;start_child_span&quot;: true } }`), }, }, }, }, } configs = append(configs, config) return configs, nil }  ","version":null,"tagName":"h3"},{"title":"如何扩展全局配置​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#如何扩展全局配置","content":"","version":null,"tagName":"h2"},{"title":"1. HigressConfig 结构体添加对应的扩展配置​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#1-higressconfig-结构体添加对应的扩展配置","content":"type HigressConfig struct { Tracing *Tracing `json:&quot;tracing,omitempty&quot;` // 在这里添加对应的数据结构来扩展配置 }  ","version":null,"tagName":"h3"},{"title":"2. 增加扩展配置默认值​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#2-增加扩展配置默认值","content":"// pkg/ingress/kube/configmap/config.go func NewDefaultHigressConfig() *HigressConfig { higressConfig := &amp;HigressConfig{ Tracing: NewDefaultTracing(), // 在这里增加扩展配置默认值 } return higressConfig }  ","version":null,"tagName":"h3"},{"title":"3. 实现 ItemController interface​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#3-实现-itemcontroller-interface","content":"type ItemController interface { GetName() string AddOrUpdateHigressConfig(name util.ClusterNamespacedName, old *HigressConfig, new *HigressConfig) error ValidHigressConfig(higressConfig *HigressConfig) error ConstructEnvoyFilters() ([]*config.Config, error) RegisterItemEventHandler(eventHandler ItemEventHandler) }  ","version":null,"tagName":"h3"},{"title":"4. 初始化扩展配置，同时添加到 ItemControllers​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#4-初始化扩展配置同时添加到-itemcontrollers","content":"func NewConfigmapMgr(XDSUpdater model.XDSUpdater, namespace string, higressConfigController HigressConfigController, higressConfigLister listersv1.ConfigMapNamespaceLister) *ConfigmapMgr { // ... tracingController := NewTracingController(namespace) configmapMgr.AddItemControllers(tracingController) // ... // 在这里初始化扩展配置，同时添加到 ItemControllers configmapMgr.initEventHandlers() return configmapMgr }  ","version":null,"tagName":"h3"},{"title":"参与社区贡献​","type":1,"pageTitle":"Higress 全局配置控制面原理分析","url":"/zh-cn/blog/configmap#参与社区贡献","content":"Higress 开源贡献小组正在火热招募贡献者。早期参与开源更容易成为项目 Committer，并有更多机会成为 Higress PMC(Project Management Committee) 的一员，参与主导 Higress 社区的前进方向。 欢迎加入 Higress 社区群：  ","version":null,"tagName":"h2"},{"title":"教程：如何在本地开发和调试 Higress Pilot","type":0,"sectionRef":"#","url":"/zh-cn/blog/pilot-debug","content":"","keywords":"higress pilot","version":null},{"title":"背景说明​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#背景说明","content":"前面 SJC 在这篇博客中介绍了如何在本地开发和调试 Higress Controller。而 Higress 控制面除了 Controller 之外还有一个组件，那就是 Pilot。本文就将介绍如何在本地开发和调试 Higress Pilot。 ","version":null,"tagName":"h2"},{"title":"环境准备​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#环境准备","content":"","version":null,"tagName":"h2"},{"title":"步骤一：克隆代码仓库​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#步骤一克隆代码仓库","content":"Pilot 的代码目前是以 Istio 上游仓库 submodule 加补丁文件的形式存在于 Higress 的主仓库中的，所以直接克隆 Higress 的代码主仓库 https://github.com/alibaba/higress 即可。 ","version":null,"tagName":"h3"},{"title":"步骤二：准备项目代码​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#步骤二准备项目代码","content":"Higress Pilot 是在 Istio Pilot 的基础上，基于 Higress 自身的功能需求进行了二次开发而构建而成的，所以我们这里需要下载上游代码仓库并应用现有的补丁。我们只需要执行下面这条命令： make prebuild  Windows 用户注意了！ 如果你是在 Windows 上进行开发，并且执行 make 命令有困难的话，不要怕，我们也有办法。因为整个 prebuild 其实也只做了两件事情。 第一件事情是初始化所有的上游子模块，只需要执行这样一条命令： git submodule update --init  第二件事情是初始化开发目录。这一步骤执行的就是 tools/hack/prebuild.sh。大家可以直接在 Cygwin 或者 Git Bash 等类 Linux 终端下执行这个脚本文件。 如果在应用补丁的时候出现了和换行符有关的报错，那么可以编辑 prebuild.sh，给两处 patch 命令增加 --binary 参数即可。  ","version":null,"tagName":"h3"},{"title":"步骤三：安装 Higress​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#步骤三安装-higress","content":"既然只是调试 pilot，那么其他组件还是要复用现有 Higress 集群里的。所以我们需要在本地配置一个 Higress 集群。大家可以参考这篇文档：链接。 ","version":null,"tagName":"h3"},{"title":"开发与调试​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#开发与调试","content":"","version":null,"tagName":"h2"},{"title":"本地开发​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#本地开发","content":"本地开发推荐使用 IDE JetBrains GoLand。我们直接在 GoLand 中打开 external/istio 目录，正常进行开发即可。  ","version":null,"tagName":"h3"},{"title":"调试运行​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#调试运行","content":"环境准备 第一步：提取配置文件 在本地任意一个位置创建一个目录，然后在该目录下执行以下命令，生成配置文件： kubectl get configmap higress-config -n higress-system -o=jsonpath='{.data.mesh}' &gt; ./mesh kubectl get configmap higress-config -n higress-system -o=jsonpath='{.data.meshNetworks}' &gt; ./meshNetworks  第二步：转发 controller 端口 执行以下命令，将 controller 的 xDS 服务端口转发至本地： kubectl port-forward deployment/higress-controller -n higress-system 15051  代码调整 如果要调试与 TLS 证书下发的相关功能，则需要在 pilot/pkg/xds/ads.go 的 initConnection 函数中添加代码，绕过证书下发过程的认证要求。代码修改方法请参考下方示例。  if features.EnableXDSIdentityCheck &amp;&amp; con.Identities != nil { // TODO: allow locking down, rejecting unauthenticated requests. id, err := checkConnectionIdentity(con) if err != nil { log.Warnf(&quot;Unauthorized XDS: %v with identity %v: %v&quot;, con.PeerAddr, con.Identities, err) return status.Newf(codes.PermissionDenied, &quot;authorization failed: %v&quot;, err).Err() } con.proxy.VerifiedIdentity = id } // Start - Auth bypassing for local debug con.proxy.VerifiedIdentity = &amp;spiffe.Identity{ TrustDomain: &quot;cluster.local&quot;, Namespace: &quot;higress-system&quot;, ServiceAccount: &quot;higress-gateway&quot;, } // End - Auth bypassing for local debug  运行配置 配置一：环境变量 CUSTOM_CA_CERT_NAME=higress-ca-root-cert; JWT_POLICY=none; PILOT_ENABLE_CROSS_CLUSTER_WORKLOAD_ENTRY=false; PILOT_ENABLE_GATEWAY_API=true; PILOT_ENABLE_GATEWAY_API_DEPLOYMENT_CONTROLLER=false; PILOT_ENABLE_GATEWAY_API_STATUS=false; PILOT_ENABLE_METADATA_EXCHANGE=false; PILOT_SCOPE_GATEWAY_TO_NAMESPACE=true; POD_NAME=higress-controller; POD_NAMESPACE=higress-system; REVISION=default; VALIDATION_ENABLED=false  配置二：命令行参数 discovery --monitoringAddr=:15014 --log_output_level=default:info --domain cluster.local --keepaliveMaxServerConnectionAge 30m --meshConfig ${configDir}/mesh --networksConfig ${configDir}/meshNetworks  注意：其中的 ${configDir} 为在环境准备一步创建的配置目录。 启动调试 在完成以上工作之后，我们就可以启动 Pilot 了。它的 main 函数定义在 pilot/cmd/pilot-discovery/main.go 文件中。  网关对接 如果想要验证 pilot 下发配置到 gateway 的功能，我们需要修改 gateway 的配置，使之连接到处于开发状态的 pilot 实例。 第一步：修改 higress-config ConfigMap kubectl edit configmap higress-config -n higress-system  修改两个地方： 将 discoveryAddress 修改为本机IP:15010； 注意：此处的本机 IP 不可以使用 127.0.0.1 等 loopback IP。需要使用本机有线或无线网卡的 IP。在 discoveryAddress 下面添加一个新属性：controlPlaneAuthPolicy: NONE。 修改后配置示例：  第二步：重启 Higress Gateway kubectl rollout restart deployment higress-gateway -n higress-system  重启后我们可以在 pilot 的控制台输出中看到 gateway 连接上来的并获取配置的日志。  ","version":null,"tagName":"h3"},{"title":"总结​","type":1,"pageTitle":"教程：如何在本地开发和调试 Higress Pilot","url":"/zh-cn/blog/pilot-debug#总结","content":"本地调试和测试是开发过程中必不可少的环节。通过本文的介绍，希望大家可以更加方便的对 pilot 进行本地调试和e2e测试，提高开发效率。同时也希望能够有越来越多的开发者加入到 Higress 研发队伍中，为产品的升级迭代贡献一份力量。 欢迎参与阿里开源贡献👏 ","version":null,"tagName":"h2"},{"title":"通义千问2.5“客串”ChatGPT4，你分的清吗","type":0,"sectionRef":"#","url":"/zh-cn/blog/qwen-or-chatgpt","content":"","keywords":"Higress Wasm AI Qwen ChatGPT NextChat","version":null},{"title":"引子​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#引子","content":"OpenAI 发布了最新的 GPT-4o 模型，通义千问也在前不久刚发布通义千问 2.5，已经和 GPT-4-Turbo 不分伯仲：  既然目前还没有和 GPT-4o 文本生成能力的对比数据，就让我们来和大模型一起做个游戏测试一下： 我们让通义千问 2.5 扮演 GPT4，来和真正的 GPT4 进行问答 PK，读者不妨来猜一猜谁是通义千问。 两名选手的头像和昵称分别是： 🌝 ：我是GPT4 🌚 ：如假包换GPT4 谁是通义千问，谁是ChatGPT，答案将在文末揭晓。 ","version":null,"tagName":"h2"},{"title":"Round 1​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#round-1","content":"第一轮由“我是GPT4”选手提问，由“如假包换GPT4”选手作答 🌝：角色设定+第一个问题  🌚 ：角色设定+第一个回答   🌝 ：第二个问题  🌚 ：第二个回答  🌝 ：第三个问题  🌚 ：第三个回答  ","version":null,"tagName":"h2"},{"title":"Round 2​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#round-2","content":"第二轮由“如假包换GPT4”选手提问，由“我是GPT4”选手作答 🌚 ：角色设定+第一个问题  🌝 ：角色设定+第一个回答   🌚 ：第二个问题  🌝 ：第二个回答  🌚 ：第三个问题  🌝 ：第三个回答  🌚 的回答更简短，更符合设定的要求，也是因为 🌝 的提问根据给定的要求更聚焦，相比下 🌚 的问题更发散，且都包含子问题，比较难用一两句话来作答。整体来说确实不分伯仲。 不过，聪明的你，可能已经有了答案。如果急于验证，可以直接划到文末查看。如果你对上面通义千问是如何扮演 ChatGPT，以及聊天框工具感到好奇，不妨先来看我们是如何搭建这个测试场景的。 ","version":null,"tagName":"h2"},{"title":"测试场景介绍​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#测试场景介绍","content":"我们使用了两个开源软件工具来搭建：NextChat 和 Higress。 NextChat (ChatGPT Next Web) 是一个可以私有化部署的开源 ChatGPT 网页应用，目前支持对接 OpenAI、Azure OpenAI、Google Gemini Pro 和 Anthropic Claude 这些 LLM 服务提供商。 Higress 是阿里云开源的高集成、易使用、易扩展、热更新的云原生API网关，遵循开源 Ingress/Gateway API 标准，提供流量调度、服务治理、安全防护三合一的网关能力。 我们使用 NextChat 来搭建前端，并使用 Higress 将通义千问的应答转换为 OpenAI 协议返回给 NextChat。 ","version":null,"tagName":"h2"},{"title":"具体搭建步骤：​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#具体搭建步骤","content":"第一步：启动容器​ 完整的 docker compose 配置贴在 Higress 社区的这个 issue 中。 注意： Higress 容器环境变量中的 YOUR_DASHSCOPE_API_KEY 需要替换为你自己的通义千问的 API Key。 docker compose -p higress-ai up -d  第二步：在浏览器里访问 http://localhost:3000/，打开 NextChat 页面；​  第三步：点击对话输入框工具栏最右侧的模型设置按钮，切换模型​ 因为 Higress 的 AI Proxy 插件（可以访问 http://localhost:8001 登录 Higress 的控制台查看插件配置）配置了 gpt-4o 到 qwen-max （即通义千问 2.5）的模型映射，所以实际上这里提供的模型服务是 qwen-max  完成！现在你就可以与 AI 进行对话了。​ 可以看到 Higress 实现了流式的效果，这不仅基于 Higress 底层对 SSE 等流式协议的良好支持，也依赖 Higress 的 Wasm 插件扩展机制可以实现通义千问协议到 OpenAI 协议的流式转换  ","version":null,"tagName":"h3"},{"title":"Higress AI 网关介绍​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#higress-ai-网关介绍","content":"随着 LLM 技术蓬勃发展，AI Web 应用创新如火如荼，对于构建一款 Web 应用来说，网关是必须的。而 AI Web 应用流量有以下特征，和对 AI 网关的需求： 长连接：由 AI Web 应用常见的 Websocket 和 SSE 协议决定，长连接的比例很高，要求网关更新配置操作对长连接无影响，不影响业务高延时：LLM 推理的响应延时比普通 Web 应用要高出很多，使得 AI Web 应用面向 CC 攻击很脆弱，容易被攻击长时间维持住大量长连接，消耗大量计算和存储资源大带宽：结合 LLM 上下文来回传输，以及高延时的特性，AI Web 应用对带宽的消耗远超普通应用，网关或后端如果没有实现较好的流式处理能力，容易导致内存快速上涨，继而触发 OOM Higress 可以很好地解决这些痛点： 长连接：不同于 Nginx 变更配置需要 Reload，导致连接断开，Higress 基于 Envoy 实现了连接无损的真正配置热更新高延时：Higress 基于安全网关能力可以提供 CC 防护能力，并面向 AI 场景，除了 QPS，还可以扩展针对 Token 生成的限流防护大带宽：Higress 支持完全流式转发，在 AI Web 应用场景下，所需的内存占用极低，同时也可以开发 Wasm 插件对请求和响应进行自定义逻辑的流式处理 从上面的测试环境搭建流程来看，Higress AI 代理插件可以很方便的让 AI 对话应用直接对接通义千问等接口契约不同的大模型服务。除了通义千问和 ChatGPT 之外，这个插件还支持 Azure OpenAI 和月之暗面（Moonshot）等大模型服务提供商，并且支持配置一个外部文件地址作为聊天上下文，可以用来快速搭建一个个人 AI 助理服务。 整个插件使用 Go 语言进行开发，代码可以在这里找到：https://github.com/alibaba/higress/tree/main/plugins/wasm-go/extensions/ai-proxy 对于流式相应的处理方法，大家可以参考这段代码： // 这个 handler 函数会重入。在收到响应 body 的流式分块后，每次调用此函数会传入一个分块（chunk）。isLastChunk 标识是否是最后一个分块。方法处理完需要返回修改后的分块。 func onStreamingResponseBody(ctx wrapper.HttpContext, pluginConfig config.PluginConfig, chunk []byte, isLastChunk bool, log wrapper.Log) []byte { activeProvider := pluginConfig.GetProvider() if activeProvider == nil { log.Debugf(&quot;[onStreamingResponseBody] no active provider, skip processing&quot;) return chunk } log.Debugf(&quot;[onStreamingResponseBody] provider=%s&quot;, activeProvider.GetProviderType()) log.Debugf(&quot;isLastChunk=%v chunk: %s&quot;, isLastChunk, string(chunk)) if handler, ok := activeProvider.(provider.StreamingResponseBodyHandler); ok { apiName := ctx.GetContext(ctxKeyApiName).(provider.ApiName) modifiedChunk, err := handler.OnStreamingResponseBody(ctx, apiName, chunk, isLastChunk, log) if err == nil &amp;&amp; modifiedChunk != nil { return modifiedChunk } return chunk } return chunk }  有兴趣参与 Higress 社区贡献，实现更多大模型 API 的适配，可以到这个 issue 下认领任务： https://github.com/alibaba/higress/issues/940 也欢迎参与 NextChat 社区贡献，参与到 3.0 版本的建设中： https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web/issues/4622 有任何使用问题，也欢迎到社区提 issue，也可以进微信或钉钉群交流：  此外，由中国科学院软件研究所“开源软件供应链点亮计划”发起并长期支持的暑期开源活动“开源之夏”正在进行中。Higress 也有两个与 AI 网关相关的项目参与其中，分别是“基于向量相似度实现LLM结果召回的WASM插件”和“基于AI网关实现AI模型的轻量化部署”。欢迎各位在校同学积极报名参与。 详情可查看开源之夏的 Higress 社区页面。 ","version":null,"tagName":"h2"},{"title":"答案揭晓​","type":1,"pageTitle":"通义千问2.5“客串”ChatGPT4，你分的清吗","url":"/zh-cn/blog/qwen-or-chatgpt#答案揭晓","content":"最后，我们来揭晓前面问题的答案。不知道各位猜对了吗？  ","version":null,"tagName":"h2"},{"title":"通过 Higress Wasm 插件 3 倍性能实现 Spring-cloud-gateway 功能","type":0,"sectionRef":"#","url":"/zh-cn/blog/plugin-transformer","content":"导读: 本文将和大家一同回顾 Spring Cloud Gateway 是如何满足 HTTP 请求/响应转换需求场景的，并为大家介绍在这种场景下使用 Higress 云原生网关的解决方案，同时还对比了两者的性能差异。 1. SCG 修改请求/响应 在 Spring Cloud Gateway (以下简称为 SCG) 中，当我们需要对 HTTP 请求或响应进行修改时，SCG 提供了许多内置的 GatewayFilter 来满足我们对这种应用场景的需求，例如 AddRequestHeader,AddRequestParameter, DedupeResponseHeader,MapRequestHeader, ModifyRequestBody 等。 考虑以下简单用例： 添加请求头部 X-First，值从请求路径中获取，例如从 /response-headers?testKey=testValue 中获取 &quot;response-headers&quot;；将请求头部 X-First 的值映射给 X-Second；添加请求查询参数 k1=v1；剔除重复的响应头部 X-Dedupe。 在 SCG 中使用 GatewayFilter 我们可以这样配置： # application.yaml: spring: cloud: gateway: routes: - id: test_route uri: lb://httpbin-svc predicates: - Path=/{api}/** filters: - AddRequestHeader=X-First, {api} - MapRequestHeader=X-First, X-Second - AddRequestParameter=k1, v1 - DedupeResponseHeader=X-Dedupe, RETAIN_FIRST 相信拥有 SCG 使用经验的同学对上述配置一定不陌生，那么本文将重点给出另一种能够满足上述需求并且性能更加优越的解决方案——使用 Higress 云原生网关的 Transformer 插件。 2. Higress 插件与 SCG 性能比较 我们在同一吞吐量水平（QPS）上，开启/关闭 Higress Transformer 插件 和 SCG 相应 GatewayFilters，统计两者在 CPU 和内存资源上的开销。 经过测试，我们得到的结论是： 在 Higress 未启用 Transformer 插件，SCG 未启用 GatewayFilters 的条件下，SCG 的 CPU, 内存资源开销分别约为 Higress的 3.30, 4.88倍；在 Higress 启用 Transformer 插件，SCG 启用相应 GatewayFilters 的条件下，SCG 的 CPU,内存资源开销分别约为 Higress 的 2.98, 3.19倍。 可见 Higress Transformer 相比于 SCG GatewayFilter 有着相当不错的性能表现！ 接下来我们将进一步为大家介绍 Higress 云原生网关以及上述提到的 Higress Transformer 插件。 3. Higress 简介 Higress 是基于阿里内部的 Envoy Gateway 实践沉淀、以开源 Istio + Envoy 为核心构建的下一代云原生网关，实现了流量网关+微服务网关+安全网关三合一的高集成能力，深度集成 Dubbo、Nacos、Sentinel 等微服务技术栈，能够帮助用户极大地降低网关的部署及运维成本且能力不打折；在标准上全面支持 Ingress 与 Gateway API，积极拥抱云原生下的标准 API 规范；同时，Higress Controller 也支持 Nginx Ingress 平滑迁移，帮助用户零成本快速迁移到 Higress。 Higress 提供了一套 Wasm (WebAssembly) SDK，使得开发者能够轻松使用 C++，Golang，Rust 开发 Wasm 插件增强网关能力。下面将为大家介绍 Higress Transformer 插件的基本功能，最后简单说明 Transformer 插件的核心代码逻辑。 4. Transformer 插件介绍 Higress Transformer 插件可以对请求/响应头部、请求查询参数、请求/响应体参数进行转换，支持的转换操作类型包括删除（remove）、重命名（rename）、更新（replace）、添加（add）、追加（append）、映射（map）和去重（dedupe）。 接下来我们复现最开始提到的 SCG GatewayFilter 简单用例，来演示如何使用该插件（以下使用 Higress 控制台可以很方便地部署插件，当然也可以使用 K8s YAML Manifests 的方式）： 首先根据官方文档 快速安装 Higress，结果如下： $ kubectl -n higress-system get deploy NAME READY UP-TO-DATE AVAILABLE AGE higress-console 1/1 1 1 1d higress-console-grafana 1/1 1 1 1d higress-console-prometheus 1/1 1 1 1d higress-controller 1/1 1 1 1d higress-gateway 1/1 1 1 1d 通过 Higress 控制台添加域名（foo.bar.com）、路由配置（foo），将流量转发至后端的 httpbin 服务： 为 foo 路由添加 Transformer 插件（当前未推送插件至官方镜像仓库，可以先使用 docker.io/weixinx/transformer:v0.1.0，或到代码仓库自行构建）： 注：为了能够同时完成请求和响应转换的需求，我们需要为 foo 路由再添加一个 Transformer 插件，命名为 transformer-resp，用于处理响应方向。 添加 Transformer 配置并开启该插件： 添加请求头部 X-First，值从请求路径中获取，例如从 /response-headers?testKey=testValue 中获取 &quot;response-headers&quot;；将请求头部 X-First 的值映射给 X-Second；添加请求查询参数 k1=v1；剔除重复的响应头部 X-Dedupe。 # transformer: type: request # 指定 Transformer 类型 rules: # 指定转换规则 - operate: add # 指定转换操作类型 headers: # 指定头部转换规则 - key: X-First value: $1 # 正则表达式捕获组 $1，支持 RE2 语法 path_pattern: ^\\/(\\w+)[\\?]{0,1}.*$ querys: # 指定查询参数转换规则 - key: k1 value: v1 - operate: map headers: - key: X-First value: X-Second --- # transformer-resp: type: response rules: - operate: dedupe headers: - key: X-Dedupe value: RETAIN_FIRST 发送请求进行测试： # 验证请求方向转换 $ curl -v -H &quot;host: foo.bar.com&quot; &quot;127.0.0.1/get&quot; ... &gt; &lt; HTTP/1.1 200 OK ... &lt; { &quot;args&quot;: { # 添加了查询参数 k1=v1 &quot;k1&quot;: &quot;v1&quot; }, &quot;headers&quot;: { ... &quot;X-First&quot;: &quot;get&quot;, # 添加了请求头部 X-First，值 &quot;get&quot; 来自请求路径 &quot;X-Second&quot;: &quot;get&quot; # 映射了请求头部 X-Second }, ... # 添加了查询参数 k1=v1 &quot;url&quot;: &quot;http://foo.bar.com/get?k1=v1&quot; } # 验证响应方向转换 $ curl -v -H &quot;host: foo.bar.com&quot; \\ &quot;127.0.0.1/response-headers?X-Dedupe=1&amp;X-Dedupe=2&amp;X-Dedupe=3&quot; ... &gt; &lt; HTTP/1.1 200 OK &lt; x-dedupe: 1 # 保留了响应头部 X-Dedupe 的第一个值 ... &lt; { ... # 通过查询参数传给 httpbin 的自定义响应头部 &quot;X-Dedupe&quot;: [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ], ... } ❗️需要注意的是： 与上述例子相同，若有同时处理请求和响应转换的需求，则需要为相应路由添加两个 Transformer 插件，分别处理请求方向和响应方向（正在优化）；请求体支持的 Content-Type 有：application/json, application/x-www-form-urlencoded, multipart/form-data；而响应体仅支持 application/json；更多说明详见插件文档。 5. Transformer 逻辑 本节将简单说明 Higress Transformer 插件的核心代码逻辑，希望可以为有兴趣优化该插件或进行二次开发的同学提供一些帮助。 首先该插件代码位于Higress 仓库的 plugins/wasm-go/extensions/transformer 目录下，使用 Higress 提供的 Wasm SDK 进行开发（关于如何开发 Wasm 插件详见官方文档）。 插件的配置模型 TransformerConfig： # 模型以插件配置的形式暴露给用户 type TransformerConfig struct { typ string # Transformer 类型，[request, response] rules []TransformRule # 转换规则 trans Transformer # Transformer 实例，不对用户暴露配置，用于实际的转换操作 } type TransformRule struct { operate string # 转换操作类型 headers []Param # header 参数 querys []Param # query 参数 body []Param # body 参数 } type Param struct { key string # 表示字段的 key value string # 表示字段的 value 或 key (map) 或 strategy (dedupe) valueType string # 为 application/json body 指定 value 的数据类型 hostPattern string # host 正则匹配模式 pathPattern string # path 正则匹配模式 } 其中 Transformer 作为接口分别有请求和响应两个实现（requestTransformer, responseTransformer），主要实现了 3 个接口方法 TransformHeaders,TransformerQuerys 和 TransformBody： type Transformer interface { TransformHeaders(host, path string, hs map[string][]string) error TransformQuerys(host, path string, qs map[string][]string) error TransformBody(host, path string, body interface{}) error ... } var _ Transformer = (*requestTransformer)(nil) var _ Transformer = (*responseTransformer)(nil) 由于头部（Headers）和查询参数（Querys）都是以 key-value 的形式存在，因此通过 kvHandler 对两者采用统一的处理逻辑；而 Body 由于请求、响应支持不同的 Content-Type，因此分别通过 requestBodyHandler (kvHandler, jsonHandler 组合)和 responseBodyHandler (jsonHandler) 进行处理。综上，在修改该插件逻辑时，主要对 kvHandler 和 jsonHandler 进行修改即可，其中 jsonHandler 依赖 GJSON 和 SJSON 工具库。 目前 handler 中的转换顺序是被硬编码的（remove -&gt; rename -&gt; replace -&gt; add -&gt; append -&gt; map -&gt; dedupe），我们对此有优化的打算，也欢迎感兴趣的同学参与进来 ~ 6. 总结 本文带大家了解了 Higress Transformer 插件，并与 Spring Cloud Gateway 进行了性能比较，在文章的最后还说明了该插件的核心代码逻辑，希望能够为大家从 Spring Cloud Gateway 迁移至 Higress 提供帮助！ 如果您觉得 Higress 对您有帮助，欢迎前往 Github: Higress 为我们 star⭐️ 一下！期待与您在 Higress 社区相遇 ~","keywords":"Higress Wasm","version":null},{"title":"higress-core源码分析","type":0,"sectionRef":"#","url":"/zh-cn/blog/higress-code","content":"","keywords":"higress","version":null},{"title":"引言​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#引言","content":"在开源社区中，源码分析是深入理解项目内部机制的关键步骤。通过仔细研究项目的源代码，我们可以揭示背后的设计原理、算法和工作流程。这不仅有助于提高我们的编程技能，还可以为开发者社区提供宝贵的学习资源。 本文将聚焦于分析Higress的源码，该项目在开源界备受瞩目。通过浏览阅读其代码，我们将初步展现其核心特性、架构设计和实现细节。希望各位用户以及开发者在本文中能够找到有价值的见解。 ","version":null,"tagName":"h2"},{"title":"关于Higress​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#关于higress","content":"Higress是基于阿里内部的Envoy Gateway实践沉淀、以开源Istio + Envoy为核心构建的下一代云原生网关，实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，深度集成Dubbo、Nacos、Sentinel等微服务技术栈，能够帮助用户极大的降低网关的部署及运维成本且能力不打折；在标准上全面支持Ingress与Gateway API，积极拥抱云原生下的标准API规范；同时，Higress Controller也支持Nginx Ingress平滑迁移，帮助用户零成本快速迁移到Higress。 ","version":null,"tagName":"h2"},{"title":"代码目录说明​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#代码目录说明","content":"cmd: 命令行参数解析等处理代码pkg/ingress: Ingress 资源转换为 Istio 资源等相关代码pkg/bootstrap: 包括启动 gRPC/xDS/HTTP server 等的代码registry: 实现对接多种注册中心进行服务发现的代码envoy: 依赖的 envoy 官方仓库 commit，以及对应的补丁代码istio: 依赖的 istio 官方仓库 commit，以及对应的补丁代码plugins: Higress 插件 sdk，以及官方内置插件代码script: 编译相关脚本docker: docker 镜像构建相关脚本 本文主要围绕着higress-core组件的源码，研究higress-core自启动以来做了哪些事情。higress-core的代码主要位于pkg目录下。 ","version":null,"tagName":"h2"},{"title":"higress-core源码整体分析​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#higress-core源码整体分析","content":"","version":null,"tagName":"h2"},{"title":"启动入口：pkg/cmd/server.go​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#启动入口pkgcmdservergo","content":"在该文件下，主要进行了命令参数的解析，并调用NewServer来创建一个Server实例，调用该实例的Start方法来启动实例Server，调用waitForMonitorSignal方法来监听进程的退出。 显然这里有两个很重要的方法函数：NewServer和Start，接下来针对这两个函数进行具体分析。 ","version":null,"tagName":"h3"},{"title":"创建实例：NewServer​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#创建实例newserver","content":"初始化Pilot的环境 APImodel.Environment​ model.Environment为Pilot 中的核心环境对象，集成了许多不同的组件，包括服务发现、配置存储、网络观察等，以提供一个完整的环境 API。 e := &amp;model.Environment{ PushContext: model.NewPushContext(), DomainSuffix: constants.DefaultKubernetesDomain, MCPMode: true, }  为model.Environment设置Ledger​ e.SetLedger(buildLedger(args.RegistryOptions))  Ledger 是一个表示经过修改的 map 的接口。这个 map 具有三个独特的特征： 每个 map 的唯一状态都有一个唯一的哈希值。map 的先前状态在固定的时间内被保留。给定先前的哈希值，我们可以从 map 中检索先前的状态（如果仍然被保留）。 Ledger提供了个接口来获取之前版本的Value，接口详情如下： // GetPreviousValue executes a get against a previous version of the ledger, using that version's root hash. GetPreviousValue(previousRootHash, key string) (result string, err error)  为model.Environment设置服务发现的接口ServiceDiscovery，用于列举服务和实例。​ ac := aggregate.NewController(aggregate.Options{ MeshHolder: e, }) e.ServiceDiscovery = ac  初始化Server实例​ s := &amp;Server{ ServerArgs: args, httpMux: http.NewServeMux(), environment: e, readinessProbes: make(map[string]readinessProbe), server: server.New(), } s.environment.Watcher = mesh.NewFixedWatcher(&amp;v1alpha1.MeshConfig{}) s.environment.Init()  这里说明一下Server结构体的各个字段的含义： type Server struct { *ServerArgs // Server参数配置 environment *model.Environment // Pilot环境配置 kubeClient higresskube.Client // 与 Kubernetes 集成的客户端 configController model.ConfigStoreCache // 配置存储控制器 configStores []model.ConfigStoreCache // 多个配置存储的缓存 httpServer *http.Server // HTTP 请求处理器 httpMux *http.ServeMux // HTTP 请求多路复用器 grpcServer *grpc.Server // grpc服务 xdsServer *xds.DiscoveryServer // xds服务 server server.Instance // Pilot Server实例配置 readinessProbes map[string]readinessProbe // server内部服务记录表，记录服务是否准备好 }  在这里，server.Instance维护了一个chan变量components chan Component，Component则定义了一个函数方法模板。当我们调用Instance的RunComponent(t Component)方法，则会将变量t发送给components管道，而我们调用Instance的Start(stop &lt;-chan struct{}) error方法，则会从components管道去接收Component对象，并执行该对象的函数方法。 type Component func(stop &lt;-chan struct{}) error  创建初始启动函数列表​ initFuncList := []func() error{ s.initKubeClient, s.initXdsServer, s.initHttpServer, s.initConfigController, s.initRegistryEventHandlers, s.initAuthenticators, }  initKubeClient函数 首先判断kubeClient是否为空，不为空进行下一步； 调用istiokube.DefaultRestConfig方法，创建一个具有 RESTful 风格的Kubernetes Config； 以Kubernetes Config为入参，调用istiokube.NewClientConfigForRestConfig方法创建一个具有 RESTful 风格的Kubernetes Client Config； 调用higress定义的NewClient方法，集成 Istio 客户端、Higress 客户端和可能的 Kingress 客户端，并为每个客户端设置了相应的 SharedInformerFactory。 initXdsServer函数 调用pliot xds的NewDiscoveryServer方法，创建一个xdsServer实例，并初始化一些资源。 s.xdsServer = xds.NewDiscoveryServer(s.environment, nil, PodName, PodNamespace, s.RegistryOptions.KubeOptions.ClusterAliases) s.xdsServer.McpGenerators[gvk.WasmPlugin.String()] = &amp;mcp.WasmpluginGenerator{Server: s.xdsServer} s.xdsServer.McpGenerators[gvk.DestinationRule.String()] = &amp;mcp.DestinationRuleGenerator{Server: s.xdsServer} s.xdsServer.McpGenerators[gvk.EnvoyFilter.String()] = &amp;mcp.EnvoyFilterGenerator{Server: s.xdsServer} s.xdsServer.McpGenerators[gvk.Gateway.String()] = &amp;mcp.GatewayGenerator{Server: s.xdsServer} s.xdsServer.McpGenerators[gvk.VirtualService.String()] = &amp;mcp.VirtualServiceGenerator{Server: s.xdsServer} s.xdsServer.McpGenerators[gvk.ServiceEntry.String()] = &amp;mcp.ServiceEntryGenerator{Server: s.xdsServer} s.xdsServer.ProxyNeedsPush = func(proxy *model.Proxy, req *model.PushRequest) bool { return true } 将xdsServer的Start方法注册给pilot server instance，并调用higress server的initGrpcServer初始化函数，将xds服务注册在grpc服务上，使得可以通过grpc协议端口进行xds协议的通信。 initHttpServer函数，初始化http server，添加8888端口的debug接口的处理器，并添加/ready路由的处理器，用于遍历higress server的readinessProbes，判断内部服务记录表内的服务是否准备完毕。 s.xdsServer.AddDebugHandlers(s.httpMux, nil, true, nil) s.httpMux.HandleFunc(&quot;/ready&quot;, s.readyHandler) initConfigController函数，这部分内容比较核心，将会在后面详细展开，暂时先跳过。 initRegistryEventHandlers函数，这部分内容跟initConfigController函数有关，暂时先跳过。 initAuthenticators函数，顾名思义，就是初始化认证器，并将其应用于 xDS 服务器。通过添加不同的认证器，可以支持不同的身份验证方式，这样服务器在处理请求时可以验证客户端的身份信息。 遍历启动函数列表，执行启动函数​ for _, f := range initFuncList { if err := f(); err != nil { return nil, err } }  注册Pilot Server​ s.server.RunComponent(func(stop &lt;-chan struct{}) error { s.kubeClient.RunAndWait(stop) return nil })  注意这里的kubeClient所调用的方法是istio的Kubernetes客户端提供的。 在ready服务记录表里注册xds服务​ s.readinessProbes[&quot;xds&quot;] = func() (bool, error) { return s.xdsServer.IsServerReady(), nil }  ","version":null,"tagName":"h3"},{"title":"启动实例：Start​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#启动实例start","content":"第一部分：遍历pilot server的components，执行chan管道里的函数 if err := s.server.Start(stop); err != nil { return err }  第二部分：等待缓存同步完成 if !s.waitForCacheSync(stop) { return fmt.Errorf(&quot;failed to sync cache&quot;) }  第三部分：启动grpc服务 grpcListener, err := net.Listen(&quot;tcp&quot;, s.GrpcAddress) if err != nil { return err } go func() { log.Infof(&quot;starting gRPC discovery service at %s&quot;, grpcListener.Addr()) if err := s.grpcServer.Serve(grpcListener); err != nil { log.Errorf(&quot;error serving GRPC server: %v&quot;, err) } }()  第四部分：启动http服务 httpListener, err := net.Listen(&quot;tcp&quot;, s.HttpAddress) if err != nil { return err } go func() { log.Infof(&quot;starting HTTP service at %s&quot;, httpListener.Addr()) if err := s.httpServer.Serve(httpListener); err != nil { log.Errorf(&quot;error serving http server: %v&quot;, err) } }()  ","version":null,"tagName":"h3"},{"title":"higress-core核心源码分析​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#higress-core核心源码分析","content":"在前面有两个函数initConfigController和initRegistryEventHandlers我们没有介绍，这两个函数可以说是higress-core的核心代码，接下来对这两个函数进行具体剖析。在分析之前，我们先看一下pkg其他目录的功能。 . ├── common //公共包 ├── config //配置包 ├── ingress //higress定义的ingress资源控制器 │ ├── config //配置ingress config和kingress config │ ├── kube //集成Kubernetes配置 │ │ ├── annotations //处理 Ingress 的注解相关的代码 │ │ ├── common //通用的代码和工具函数 │ │ ├── configmap //处理 ConfigMap 相关的代码 │ │ ├── controller //控制器相关的代码 │ │ ├── http2rpc //处理 HTTP 到 RPC 的转换的代码 │ │ ├── ingress //处理 Ingress 配置的代码 │ │ ├── ingressv1 //Ingress 的 API 版本 v1 相关的代码 │ │ ├── kingress //处理 Kingress 相关的代码 │ │ ├── mcpbridge //MCP（Mesh Configuration Protocol）的桥接相关的代码 │ │ ├── secret //处理 Secret 相关的代码 │ │ ├── util //通用的工具函数 │ │ └── wasmplugin //处理 WebAssembly 插件相关的代码 │ ├── log //日志 │ ├── mcp │ └── translation //翻译模块 └── kube //higress定义的Kubernetes客户端，包含了istio提供的Kubernetes客户端  通过目录我们可以清晰地看到higress集成了多个Kubernetes资源以及Ingress配置。 ","version":null,"tagName":"h2"},{"title":"initConfigController函数剖析​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#initconfigcontroller函数剖析","content":"我们先大致分析一下这个函数的流程，函数的具体逻辑稍后分析。最后会给出一个函数调用的流程图，可以结合流程图进行源码的理解分析。 设置 common.Options 结构体的一些选项，这些选项可能影响配置控制器的行为。这些选项包括是否启用控制器、集群 ID、Ingress 类等创建一个 translation.NewIngressTranslation 对象，该对象用于处理 Ingress 的翻译和配置向 ingressConfig 中添加本地集群的配置，并获取对应的 Ingress 控制器和 Kingress 控制器使用 configaggregate.MakeCache 创建一个带有缓存的配置控制器创建一个 Istio 配置存储，并将其设置到 Server 对象的 environment.IstioConfigStore 中将 ingressConfig 设置到 Server 对象的 environment.IngressStore 中将包含配置和启动 Ingress 控制器、Kingress 控制器以及相关的配置控制器的函数方法注册到pilot server instance的components管道中。 我们从中挑选出几个比较重要的函数出来：NewIngressTranslation、AddLocalCluster、InitializeCluster以及configController的Run方法，其它的像MakeCache、MakeIstioStore方法则是有istio提供的函数方法，用于对接higress中的discovery容器中Pilot组件。确定好接下来要分析的内容之后，我们来到pkg/ingress/translattion目录，查看一下translation.go。 translation.go剖析​ IngressTranslation实现了两个接口：model.ConfigStoreCache和model.IngressStore，其中model.ConfigStoreCache还包含了model.ConfigStore接口。我们可以大致浏览一下，可以发现基本上是调用IngressTranslation结构体中的ingressConfig和kingressConfig的方法，位于pkg/ingress/config目录下。 除了实现接口方法之外，还提供了NewIngressTranslation、AddLocalCluster、InitializeCluster方法。同样地，我们也可以发现这三个方法本质上也是调用ingressConfig和kingressConfig的方法。 既然translation.go本质上是调用pkg/ingress/config目录下的函数，不妨我们进入该目录，查看一下ingress_config.go，对于kingress_config.go，我们暂不做分析。 ingress_config.go剖析​ 在ingress_config.go中有一个名为IngressConfig结构体，内容如下(附带注释)： type IngressConfig struct { // 远程 Ingress 控制器的映射，键为集群 ID，值为 common.IngressController remoteIngressControllers map[string]common.IngressController // 用于保护并发访问 remoteIngressControllers 的互斥锁 mutex sync.RWMutex // Ingress 路由和域名的缓存 ingressRouteCache model.IngressRouteCollection ingressDomainCache model.IngressDomainCollection // 本地 Kubernetes 客户端 localKubeClient kube.Client // 处理 VirtualService 事件的事件处理程序切片 virtualServiceHandlers []model.EventHandler // 处理 Gateway 事件的事件处理程序切片 gatewayHandlers []model.EventHandler // 处理 DestinationRule 事件的事件处理程序切片 destinationRuleHandlers []model.EventHandler // 处理 EnvoyFilter 事件的事件处理程序切片 envoyFilterHandlers []model.EventHandler // 处理 ServiceEntry 事件的事件处理程序切片 serviceEntryHandlers []model.EventHandler // 处理 WasmPlugin 事件的事件处理程序切片 wasmPluginHandlers []model.EventHandler // 用于处理监视错误的处理程序 watchErrorHandler cache.WatchErrorHandler // 缓存的 EnvoyFilter 配置 cachedEnvoyFilters []config.Config // 正在监视的 Secret 集合 watchedSecretSet sets.Set // 用于协调注册表的调解器 RegistryReconciler *reconcile.Reconciler // MCP 桥接是否已调解的标志 mcpbridgeReconciled *atomic.Bool // 管理 MCP 桥接相关的控制器和列表 mcpbridgeController mcpbridge.McpBridgeController mcpbridgeLister netlisterv1.McpBridgeLister // 管理 WasmPlugin 相关的控制器和列表 wasmPluginController wasmplugin.WasmPluginController wasmPluginLister extlisterv1.WasmPluginLister // 已注册的 WasmPlugin 集合，键为 WasmPlugin 名称 wasmPlugins map[string]*extensions.WasmPlugin // 管理 HTTP2RPC 相关的控制器和列表 http2rpcController http2rpc.Http2RpcController http2rpcLister netlisterv1.Http2RpcLister // 已注册的 HTTP2RPC 集合，键为 HTTP2RPC 名称 http2rpcs map[string]*higressv1.Http2Rpc // Configmap 的管理器 configmapMgr *configmap.ConfigmapMgr // 用于更新 XDS XDSUpdater model.XDSUpdater // 处理注解的注解处理程序 annotationHandler annotations.AnnotationHandler // 命名空间 namespace string // 集群 ID clusterId string }  该结构体提供了一些方法，其实这个结构体本质上也是实现了translation.go提到的两个接口，方法列表和translation.go极其相似，我们分析一下一些比较复杂的方法，剩下的可自行定位到源码查看： NewIngressConfig 初始化IngressConfig，创建多个子控制器(mcpbridge、wasmplugin、http2rpc等)并赋值给对应的字段上。为多个子控制器注册事件监听器，用于监听Kubernetes资源的变化，并进行相应的处理。 config := &amp;IngressConfig{ remoteIngressControllers: make(map[string]common.IngressController), localKubeClient: localKubeClient, XDSUpdater: XDSUpdater, annotationHandler: annotations.NewAnnotationHandlerManager(), ... } mcpbridgeController := mcpbridge.NewController(localKubeClient, clusterId) mcpbridgeController.AddEventHandler(config.AddOrUpdateMcpBridge, config.DeleteMcpBridge) config.mcpbridgeController = mcpbridgeController config.mcpbridgeLister = mcpbridgeController.Lister() ...  在这里，有几个方法需要注意： 1. `annotations.NewAnnotationHandlerManager()` 2. `mcpbridge.NewController(localKubeClient, clusterId)` 3. `wasmplugin.NewController(localKubeClient, clusterId)` 4. `http2rpc.NewController(localKubeClient, clusterId)` 5. `configmap.NewController(localKubeClient, clusterId, namespace)`  很明显这些方法分别对应pkg/ingress/kube目录下一些自定义的资源配置方法，后面会针对该目录进行单独的介绍。 RegisterEventHandler 对kind变量进行判断，判断属于哪种资源，并添加到对应的事件处理程序切片 switch kind { case gvk.VirtualService: m.virtualServiceHandlers = append(m.virtualServiceHandlers, f) ... } 注册事件监听器 for _, remoteIngressController := range m.remoteIngressControllers { remoteIngressController.RegisterEventHandler(kind, f) } 我们可以定位一下remoteIngressController的RegisterEventHandler方法： func (c *controller) RegisterEventHandler(kind config.GroupVersionKind, f model.EventHandler) { switch kind { case gvk.VirtualService: c.virtualServiceHandlers = append(c.virtualServiceHandlers, f) ... } } AddLocalCluster 创建ingress总控制器，并注册到remoteIngressControllers中 ingressController = ingress.NewController(m.localKubeClient, m.localKubeClient, options, secretController) m.remoteIngressControllers[options.ClusterId] = ingressController InitializeCluster 设置错误监听处理器 _ = ingressController.SetWatchErrorHandler(m.watchErrorHandler) 其中SetWatchErrorHandler方法如下，调用各个informer的SetWatchErrorHandler方法： func (c *controller) SetWatchErrorHandler(handler func(r *cache.Reflector, err error)) error { var errs error if err := c.serviceInformer.SetWatchErrorHandler(handler); err != nil { errs = multierror.Append(errs, err) } if err := c.ingressInformer.SetWatchErrorHandler(handler); err != nil { errs = multierror.Append(errs, err) } ... return errs } 通过go协程启动ingressController go ingressController.Run(stop) List 前期检查，预防空指针或逻辑错误 if typ != gvk.Gateway &amp;&amp; typ != gvk.VirtualService &amp;&amp; typ != gvk.DestinationRule &amp;&amp; typ != gvk.EnvoyFilter &amp;&amp; typ != gvk.ServiceEntry &amp;&amp; typ != gvk.WasmPlugin { return nil, common.ErrUnsupportedOp } // Currently, only support list all namespaces gateways or virtualservices. if namespace != &quot;&quot; { IngressLog.Warnf(&quot;ingress store only support type %s of all namespace.&quot;, typ) return nil, common.ErrUnsupportedOp } 如果kind类型是envoyfilter，拿出来处理掉 if typ == gvk.EnvoyFilter { ... // Build configmap envoy filters configmapEnvoyFilters, err := m.configmapMgr.ConstructEnvoyFilters() ... } 如果不是，调用ingress控制器(如果有kingress控制器，也给带上)的List方法，添加到config列表，以ingress控制器的方法为例，会获取informer对象的存储器，并对其进行遍历，将遍历到的对象进行深拷贝，并返回config列表。由于List方法是实现ConfigStore接口的，istio内部会对这个config列表进行下一步处理。 var configs []config.Config m.mutex.RLock() for _, ingressController := range m.remoteIngressControllers { configs = append(configs, ingressController.List()...) } m.mutex.RUnlock() 对config列表根据创建时间进行排序，并创建一个包装好的config列表，wrapperConfigs里除了Config``，还会包含AnnotationsConfig`注解配置 common.SortIngressByCreationTime(configs) wrapperConfigs := m.createWrapperConfigs(configs) 根据kind类型，将wrapperConfigs转换为对应的资源，代码如下，并为convertGateways附加注释 switch typ { case gvk.Gateway: //1.初始化ConvertOptions //2.调用ingress控制器的ConvertGateway方法，在这里，ingress控制器首先做一些检查，并遍历rule规则列表 // 为每个rule创建IngressDomainBuilder构造器，中间过程会构造gateway包装器、获取tls密钥名称等等 // 在这个过程中会对config包装器进行修改 //3.apply注解 //4.组合成istio能够识别的config列表 return m.convertGateways(wrapperConfigs), nil case gvk.VirtualService: return m.convertVirtualService(wrapperConfigs), nil case gvk.DestinationRule: return m.convertDestinationRule(wrapperConfigs), nil ... } 这块内容较多，具备一定的难度，需要对各个资源有一定的理解。 以下几个方法的作用是极为相似的 AddOrUpdateWasmPluginDeleteWasmPluginAddOrUpdateMcpBridgeDeleteMcpBridgeAddOrUpdateHttp2RpcDeleteHttp2Rpc 顾名思义，就是在监听对应资源的过程中，发生资源的添加或者变更或者删除进行对应的操作。 以AddOrUpdateWasmPlugin和DeleteWasmPlugin为例。 AddOrUpdateWasmPlugin 获取wasmplugin wasmPlugin, err := m.wasmPluginLister.WasmPlugins(clusterNamespacedName.Namespace).Get(clusterNamespacedName.Name) 将wasmplugin转化为istio能够识别的wasmplugin istioWasmPlugin, err := m.convertIstioWasmPlugin(&amp;wasmPlugin.Spec) 更新IngressConfig m.wasmPlugins[clusterNamespacedName.Name] = istioWasmPlugin DeleteWasmPlugin 更新IngressConfig delete(m.wasmPlugins, clusterNamespacedName.Name) 如果存在该wasmplugin，触发wasmPluginHandlers的事件监听器，执行对应的操作 for _, f := range m.wasmPluginHandlers { IngressLog.Debug(&quot;WasmPlugin triggerd update&quot;) f(config.Config{Meta: metadata}, config.Config{Meta: metadata}, model.EventDelete) }  到此为此，ingress_config.go的内容基本介绍完毕，大部分内容并未做过多深入，感兴趣的朋友可以自行下载源码浏览查看。 我们现在回到最开始的initConfigController函数上，可以发现这个函数的核心内容其实就是ingress_config.go，当然还有对应的多个控制器，关于控制器的介绍，将在后面进行介绍。 ","version":null,"tagName":"h3"},{"title":"initRegistryEventHandlers函数剖析​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#initregistryeventhandlers函数剖析","content":"该函数相对于initConfigController函数来说简单很多，其主要做的内容就是配置xds更新处理器，并将其作为事件监听器的事件处理程序，注册给configController，也就是说，当发生资源的变更时，会通过xds协议进行推送更新。 ","version":null,"tagName":"h3"},{"title":"pkg/ingress/kube目录介绍​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#pkgingresskube目录介绍","content":"这部分内容较多，后续可自行针对感兴趣的部分进行精读。 annotations 这里主要处理ingress注解的配置，在NewAnnotationHandlerManager方法里列出了一些已经支持的注解，每个注解的处理程序需要实现AnnotationHandler所定义的接口列表。 common 这里核心的文件为controller.go，主要做了一些资源的包装，以及定义了IngressController接口方法，其实现类有pkg/ingress/kube/ingress/controller.go和pkg/ingress/kube/ingressv1/controller.go configmap 这里主要为ConfigMap添加了higress的KV对，在controller.go中定义了ItemController接口，和前者提到的一样，这里也提供了相似的更新配置的方法AddOrUpdateHigressConfig，同样地，也是先获取当前的value值，并获取旧的value值，进行一个比对，比对结果可能为新增、更新、删除，分别执行对应的事件监听器里所定义的事件处理器，也就是XDSUpdater。 controller 在前面的介绍中，提到了很多次事件监听器，可能会有人疑问是怎么做资源监听的，资源监听的代码就位于本目录下了。这里可以着重介绍一下，事件监听的具体实现原理。 定义了Controller[lister any]接口，其实现类为CommonController。 我们可以看一下这个实现结构体有哪些需要注意的字段。 lister: 这个字段为any类型，会在NewCommonController方法里传入进来，点击查看该方法调用情况，可以发现传入该字段的都是各个资源的监听器，例如ConfigMap的监听器就是client.KubeInformer().Core().V1().ConfigMaps().Lister().ConfigMaps(namespace)，其它也是如此。updateHandler: 这个字段为func(util.ClusterNamespacedName)类型，主要用于存储对应监听器lister所提供的更新或者新增事件处理器，存储代码如下： func (c *CommonController[lister]) AddEventHandler(addOrUpdate func(util.ClusterNamespacedName), delete ...func(util.ClusterNamespacedName)) { c.updateHandler = addOrUpdate if len(delete) &gt; 0 { c.removeHandler = delete[0] } } removeHandler: 同updateHandler 接口方法除了刚刚介绍的AddEventHandler方法，还有个Run方法需要注意一下 func (c *CommonController[lister]) Run(stop &lt;-chan struct{}) { defer utilruntime.HandleCrash() defer c.queue.ShutDown() if !cache.WaitForCacheSync(stop, c.HasSynced) { IngressLog.Errorf(&quot;Failed to sync %s controller cache&quot;, c.typeName) return } IngressLog.Debugf(&quot;%s cache has synced&quot;, c.typeName) go wait.Until(c.worker, time.Second, stop) &lt;-stop } 可以看有个wait.Until方法，用于每秒钟执行c.worker方法，直到接收到stop信号，方法调用链如下：c.worker-&gt;c.processNextWorkItem()-&gt;c.onEvent(ingressNamespacedName)-&gt;c.updateHandler(obj)，可以看出来当我们创建一个控制器，并为其注册了一个事件监听器以及事件处理器(updateHandler)，因此每秒钟会执行事件处理器，也就实现了监听的逻辑。 也就是说，这个目录下主要定义了一个公共的控制器，可以节省大量代码的编写，我们在创建一个新的子控制器的时候，可以调用NewCommonController方法来实现监听逻辑。 http2rpc 代码较为简单，通过NewCommonController来创建Http2RpcController，并提供了GetHttp2Rpc方法。 ingress Ingress控制器的核心代码逻辑，主要为前文提到的ingress_config.go所调用。部分内容在前文已经简单介绍过。 ingressv1 Ingress的API版本v1相关的控制器代码。 kingress kingress相关的控制器代码。 mcpbridge 同http2rpc目录。 secret 同http2rpc目录。 util 工具包。 wasmplugin 同http2rpc目录。 ","version":null,"tagName":"h2"},{"title":"higress-core流程图​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#higress-core流程图","content":"经过前面的源码分析，相信大家对higress核心逻辑已经有了初步的理解，后续可以针对自己感兴趣的部分，进行深入研究，其中会涉及到Kubernetes资源配置的核心逻辑以及Istio的基本掌握，当然，如果给它研究透了，对这些基本原理的理解将会更为深刻。 流程图如下：  对于初始化配置控制器部分，可进一步绘画流程图。  关于事件监听部分，其流程图如下：  ","version":null,"tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"higress-core源码分析","url":"/zh-cn/blog/higress-code#总结","content":"以上是对higress源码的初步分析，希望能够给用户以及开发者对higress有个基本的了解。 ","version":null,"tagName":"h2"},{"title":"Higress 0.7.0 版本发布：GA 进入倒计时","type":0,"sectionRef":"#","url":"/zh-cn/blog/release-070","content":"","keywords":"higress","version":null},{"title":"进展概要​","type":1,"pageTitle":"Higress 0.7.0 版本发布：GA 进入倒计时","url":"/zh-cn/blog/release-070#进展概要","content":"Higress 控制台正式 release，涵盖 Higress 的服务/路由/域名/证书管理能力，并提供开箱即用的可观测功能安装/升级 Higress 时支持自动安装对应版本的 Higress Console，避免版本不适配的问题支持开启 Istio API，实现更多复杂的功能，并且也可以用于平滑替换 Istio Ingress Gateway ","version":null,"tagName":"h2"},{"title":"版本特性​","type":1,"pageTitle":"Higress 0.7.0 版本发布：GA 进入倒计时","url":"/zh-cn/blog/release-070#版本特性","content":"","version":null,"tagName":"h2"},{"title":"Higress 控制台​","type":1,"pageTitle":"Higress 0.7.0 版本发布：GA 进入倒计时","url":"/zh-cn/blog/release-070#higress-控制台","content":"现在通过 helm 命令安装 Higress 时将自动安装对应版本的 Higress Console, 这里通过 higress-console.domain 参数，可以指定控制台的域名。 # 已经添加过 repo 的，请执行 helm repo update helm repo add higress.io https://higress.io/helm-charts helm install higress -n higress-system higress.io/higress --create-namespace --render-subchart-notes --set higress-console.domain=console.higress.io   注意：安装完成后会输出一段文本，其中包含获取控制台登录信息的命令。请执行该命令并记录用户名和密码。  正式环境部署时，建议控制台开启强制 HTTPS 访问，具体操作方式是，在 higress-system 命名空间下先创建好 TLS 证书和私钥对应的 secret，例如： apiVersion: v1 kind: Secret type: kubernetes.io/tls data: tls.crt: -----BEGIN CERTIFICATE-----... tls.key: -----BEGIN RSA PRIVATE KEY-----... metadata: name: my-tls-secret namespace: higress-system  然后通过下面 helm 命令开启强制 HTTPS 访问 helm upgrade higress -n higress-system higress.io/higress --set higress-console.tlsSecretName=my-tls-secret  如果希望启用 Higress 自带的 Prometheus&amp;Grafana，可以通过下面 helm 命令进行安装： helm upgrade higress -n higress-system higress.io/higress --set global.o11y.enabled=true  这样 Higress 控制台就可以看到自带的可观测大盘了：  当然，你也可以对接已有的 Prometheus&amp;Grafana，使用这份 Higress 官方提供的 Dashboard 配置即可：https://higress.io/grafana/dashboard.json 可以登陆 Higress 控制台 Demo 试用现有所有功能: http://demo.higress.io ","version":null,"tagName":"h3"},{"title":"开启 Istio API​","type":1,"pageTitle":"Higress 0.7.0 版本发布：GA 进入倒计时","url":"/zh-cn/blog/release-070#开启-istio-api","content":"通过开启 Istio API，可以实现使用 Higress 平滑替换 Istio Ingress Gateway，具体 helm 命令如下： helm upgrade higress -n higress-system higress.io/higress --set global.enableIstioAPI=true  基于 Istio API，可以实现目前 Higress 还未提供相应 Ingress 注解的能力，例如基于 Istio EnvoyFilter 来实现 HTTP to Dubbo 的协议转换配置方式： apiVersion: networking.istio.io/v1alpha3 kind: EnvoyFilter metadata: name: http-dubbo-transcoder namespace: higress-system spec: configPatches: - applyTo: HTTP_FILTER match: context: GATEWAY listener: filterChain: filter: name: envoy.filters.network.http_connection_manager subFilter: name: envoy.filters.http.router patch: operation: INSERT_BEFORE value: name: envoy.filters.http.http_dubbo_transcoder typed_config: '@type': type.googleapis.com/udpa.type.v1.TypedStruct type_url: type.googleapis.com/envoy.extensions.filters.http.http_dubbo_transcoder.v3.HttpDubboTranscoder - applyTo: HTTP_ROUTE match: context: GATEWAY routeConfiguration: vhost: route: name: test patch: operation: MERGE value: route: upgrade_configs: - connect_config: allow_post: true upgrade_type: CONNECT typed_per_filter_config: envoy.filters.http.http_dubbo_transcoder: '@type': type.googleapis.com/udpa.type.v1.TypedStruct type_url: type.googleapis.com/envoy.extensions.filters.http.http_dubbo_transcoder.v3.HttpDubboTranscoder value: request_validation_options: reject_unknown_method: true reject_unknown_query_parameters: true services_mapping: - group: dev method_mapping: - name: sayName parameter_mapping: - extract_key: p extract_key_spec: ALL_QUERY_PARAMETER mapping_type: java.lang.String passthrough_setting: passthrough_all_headers: true path_matcher: match_http_method_spec: ALL_GET match_pattern: /dubbo/hello name: com.alibaba.nacos.example.dubbo.service.DemoService version: 1.0.0 url_unescape_spec: ALL_CHARACTERS_EXCEPT_RESERVED  上述配置比较复杂，原因是为了方便 Envoy 数据面程序逻辑处理而设计的 Schema。目前 Higress 社区已经在设计更方便 Ingress 配置使用的 CRD，后续也会在 Higress 控制台上提供对应的配置功能。 ","version":null,"tagName":"h3"},{"title":"GA 版本规划​","type":1,"pageTitle":"Higress 0.7.0 版本发布：GA 进入倒计时","url":"/zh-cn/blog/release-070#ga-版本规划","content":"Higress 预计将在3月底/4月初发布首个 GA 版本, 这个版本的主要规划如下： 实现 HTTP to Dubbo 协议转换的控制面配置简化Higress 控制台提供 Wasm 插件能力，支持配置自定义插件推出第一版 Higress Admin API，可以被其他平台/工具集成全面完善 Higress 官网文档，覆盖 Higress 全部功能的详细说明 ","version":null,"tagName":"h2"},{"title":"Higress 社区​","type":1,"pageTitle":"Higress 0.7.0 版本发布：GA 进入倒计时","url":"/zh-cn/blog/release-070#higress-社区","content":"欢迎认领 Higress Issue 任务：https://github.com/alibaba/higress/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22 完成一定数量的 Issues 就可以成为 Higress Committer，也有机会获得开源社区的礼物和荣誉🏆 欢迎加入 Higress 社区群，及时了解更多 Higress 动向：  ","version":null,"tagName":"h2"},{"title":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","type":0,"sectionRef":"#","url":"/zh-cn/blog/release-100","content":"","keywords":"higress GA","version":null},{"title":"前言​","type":1,"pageTitle":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","url":"/zh-cn/blog/release-100#前言","content":"历时 5 个多月，Higress 推出了首个 RC （Release Candidate，即正式发布的候选）版本 1.0.0-rc，用户可以通过控制台，开箱即用地使用云原生网关。 选用 Higress 作为云原生网关的核心优势如下： 易用性 “云原生”已经不再是一个新鲜词，但企业对云原生技术的学习使用成本仍有许多顾虑，对云原生新标准的追赶又有很多焦虑； Higress 同时提供了本地安装/生产部署的 quickstart，可以一键部署，并通过控制台操作快速上手；基于简单易用的控制台，Higress 可以封装 Ingress/Gateway API 的标准细节，根治技术追赶焦虑。 标准化 K8s 带来了云原生的路由标准 Ingress/Gateway API，如同 POSIX 定义 Unix 可移植操作系统标准，历时 35 年经久不衰，云原生的路由标准的生命周期一定会远超过 K8s 本身； Higress 结合阿里内部实践以及阿里云产品沉淀，积累了基于 Ingress API 的丰富的路由策略扩展能力，同时还兼容大部分 Nginx Ingress 能力，这些能力后续也将在 Gateway API 上支持。 高集成 企业内有大量传统架构部署的服务，会成为向云原生架构演进的技术负担，要求云原生网关具备对接异构服务架构的能力； 基于 Higress 提供的多种服务发现机制，网关路由不仅可以转发到 K8s 服务，也可以直接配置 IP 转发到到物理机上的服务；基于 Nacos/ZooKeeper 等注册中心对接，还可以轻松实现 Spring Cloud 和 Dubbo 微服务的路由，无论其是否部署在 K8s 内。 易扩展 基于扩展机制进行二次开发的能力，是云原生网关在不同业务场景下都能适配落地的关键； Higress提供了灵活的插件扩展机制，目前插件市场已经推出多个官方插件，并支持用户通过控制台直接上传自己开发的插件，同时开源社区的插件市场生态也在不断建设中。 热更新 传统 Nginx 更新规则需要 reload 会导致链接抖动，导致流量损失，对实时通信、视频、IOT无法容忍； 对于路由规则，Wasm 插件逻辑更新，以及证书改动等等，Higress 全部支持热更新，不会造成任何连接抖动。 ","version":null,"tagName":"h2"},{"title":"企业落地支持​","type":1,"pageTitle":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","url":"/zh-cn/blog/release-100#企业落地支持","content":"在 RC 版本阶段使用 Higress 的企业用户，社区会在落地阶段提供更多帮助，我们建立了 Higress 企业落地群，可以联系我(微信:nomadao 钉钉:chengtanzty)，会将你加进群，群里有社区核心研发同学，可以提供更及时的响应和帮助。 ","version":null,"tagName":"h3"},{"title":"安装升级方式​","type":1,"pageTitle":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","url":"/zh-cn/blog/release-100#安装升级方式","content":"安装 RC 版本，需要 helm 安装或升级时需要指定--devel参数，例如：helm upgrade higress -n higress-system --devel 1.0.0 RC 版本已经在社区小伙伴的协作下完成了多轮测试和修复工作，欢迎大家使用。最终的正式版本，也将在近期很快推出。 ","version":null,"tagName":"h3"},{"title":"控制台功能速览​","type":1,"pageTitle":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","url":"/zh-cn/blog/release-100#控制台功能速览","content":"丰富的可观测 提供开箱即用的可观测，Grafana&amp;Prometheus 可以使用内置的也可对接自建的，具体可以参考文档 插件扩展机制 官方提供了多种插件，用户也可以开发自己的插件，构建成 docker/oci 镜像后在控制台配置，可以实时变更插件逻辑，对流量完全无损。 多种服务发现 默认提供 K8s Service 服务发现，通过配置可以对接 Nacos/ZooKeeper 等注册中心实现服务发现，也可以基于静态 IP 或者 DNS 来发现 域名和证书 可以创建管理 TLS 证书，并配置域名的 HTTP/HTTPS 行为，域名策略里支持对特定域名生效插件 丰富的路由能力 基于上面配置的服务发现机制，发现的服务会出现在服务列表中；创建路由时，选择域名，定义路由匹配机制，再选择目标服务进行路由；路由策略里支持对特定路由生效插件 ","version":null,"tagName":"h2"},{"title":"进阶使用​","type":1,"pageTitle":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","url":"/zh-cn/blog/release-100#进阶使用","content":"Higress 控制台的功能还在不断丰富和演进中，当前还有很多 Higress Ingress 注解的能力没有支持，如果有这部分深度使用的需求，可以参考这篇文档进行进阶配置 如果希望使用 Istio 的能力进行流量治理，可以参考这篇文档的支持 Istio CRD 一节。基于 Istio 的 EnvoyFilter API 可以实现更多细粒度的管控能力。 ","version":null,"tagName":"h3"},{"title":"社区​","type":1,"pageTitle":"上线控制台，降低使用门槛 ｜ Higress 1.0.0 RC 版本发布","url":"/zh-cn/blog/release-100#社区","content":"欢迎认领 Higress Issue 任务：https://github.com/alibaba/higress/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22 完成一定数量的 Issues 就可以成为 Higress Committer，也有机会获得开源社区的礼物和荣誉🏆 欢迎加入 Higress 社区群，及时了解更多 Higress 动向：  ","version":null,"tagName":"h2"},{"title":"美洽智能客服使用 Higress 统一网关落地实践","type":0,"sectionRef":"#","url":"/zh-cn/blog/user-mq","content":"","keywords":"higress 美洽","version":null},{"title":"Higress 开源一周年：新版本，新标准，新工具，新征程","type":0,"sectionRef":"#","url":"/zh-cn/blog/release-1.3","content":"","keywords":"higress ingress Gateway API","version":null},{"title":"历程回顾​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#历程回顾","content":" Higress 开源一年时间，一共发布了 18 个 release 版本，收获了 40 多位社区贡献者和 1800+ star，上图是这一年过来达成的一些关键的里程碑。 前面半年通过集成开源生态，打磨开源版本稳定性，并在发布 1.0 GA 版本后，社区又马不停蹄发布了 1.1 和 1.2 两个重要版本，实现了非 K8s 部署，Knative 适配等核心能力。 Higress 1.3 版本已经正式发布，除了增加的新功能，已有能力也在大量社区用户反馈的过程中不断完善改进，这个版本同时标志着 1.x 进入可以大规模生产使用的状态。 ","version":null,"tagName":"h2"},{"title":"新版本：功能速览​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#新版本功能速览","content":"自发布 1.2 版本过去了一个多月时间，1.3 版本正式发布，带来两个全新能力： 新标准：支持最新版本 Gateway API 标准，并且具备从 Ingress 平滑渐进演进，以及对接多种服务发现机制的能力新工具：正式 release 了 hgctl (Higress Crontroller) 这个 &quot;All in one&quot; 的新工具，不仅可以替代 Helm 实现更简易的安装，还提供了 WASM 插件开发工具包，以及网关配置检查等丰富功能 除了这两个核心功能外，还有一些实用功能： 提供了 Higress Admin Java SDK，可以统一对接 K8s 和非 K8s 环境，管理域名/路由等配置提供了 OIDC 插件，支持对接 Keycloak/Okta 等第三方身份认证系统Higress Console 的易用性和安全性提升，不再通过路由暴露，支持界面初始化/修改密码 与此同时，Higress 开源社区已经开始准备踏上一段全新的开源征程... ","version":null,"tagName":"h2"},{"title":"新标准：支持最新版 Gateway API​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#新标准支持最新版-gateway-api","content":"Gateway API 在 11 月 1 日正式发布了 1.0.0 版本，其中 GatewayClass, Gateway, HTTPRoute 这三个 API正式宣布 GA，发布了 v1 版本：gateway.networking.k8s.io/v1。 目前 Higress 已经可以支持这些最新版本的 API 配置，只需在安装/升级 Higress 时配置开启 Gateway API： 使用 Helm ：通过参数 --set global.enableGatewayAPI=true使用 Hgctl ：通过命令行参数或者 install.yaml 中配置 global.enableGatewayAPI=true 首先创建 GatewayClass 资源：  apiVersion: gateway.networking.k8s.io/v1 kind: GatewayClass metadata: name: higress-gateway spec: controllerName: &quot;higress.io/gateway-controller&quot;  接着在安装 Higress 的命名空间下，创建 Gateway 资源，通过 gatewayClassName 关联上面创建的 GatewayClass 资源，指定由 Higress 来管理此 Gateway 配置，下面为域名同时配置了 HTTP 和 HTTPS 入口，并为 HTTPS 入口配置了证书：  apiVersion: gateway.networking.k8s.io/v1 kind: Gateway metadata: name: higress-gateway namespace: higress-system spec: gatewayClassName: higress-gateway listeners: - name: foobar hostname: &quot;*.foobar.com&quot; port: 80 protocol: HTTP allowedRoutes: namespaces: from: All - name: foobar-https hostname: &quot;*.foobar.com&quot; port: 443 protocol: HTTPS allowedRoutes: namespaces: from: All tls: certificateRefs: - kind: Secret name: wildcard-foobar-com mode: Terminate  因为上面 Gateway 通过 allowedRoutes 配置了允许所有命名空间的路由来关联，所以这里在 default 命名空间下创建 HTTPRoute，关联上面创建的 Gateway，即可定义域名下的具体路由：  apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: foobar namespace: default spec: parentRefs: - name: higress-gateway namespace: higress-system hostnames: [&quot;www.foobar.com&quot;] rules: - matches: - path: type: PathPrefix value: /foo backendRefs: - name: foo-service port: 5678  以上就是 Gateway API 的一个简单用法示例，Gateway API 还有很多功能和玩法，后面 Higress 公众号/博客会出一个系列进行系统分享和介绍。 欢迎结合官方 API 文档，并使用 hgctl （获取方式见下文）在自己电脑上安装一个 local-k8s 模式的 Higress，来开启对这一新标准的探索：  # 一键安装, 交互式命令选择第一种安装模式 local-k8s，将默认安装 Gateway API CRD hgctl install  ","version":null,"tagName":"h2"},{"title":"多种服务发现能力​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#多种服务发现能力","content":"在 Ingress API 标准下，Higress 对接多种服务发现能力是独树一帜的，在 Gateway API 标准下， Higress 仍就保持了这一能力优势： 首先通过 McpBridge 资源，可以定义多种服务发现机制：  apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: 127.0.0.1 nacosGroups: - DEFAULT_GROUP name: my-local-nacos port: 8848 type: nacos2 - domain: 127.0.0.1 name: my-local-zk port: 2181 type: zookeeper - domain: 127.0.0.1 name: my-local-eureka port: 8761 type: eureka - domain: 127.0.0.1 consulDatacenter: dc1 name: my-local-consul port: 8500 type: consul  创建一个 HTTPRoute 资源，可以同时对接 K8s 服务，和注册中心的服务，并实现灰度路由能力：  apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: http namespace: default spec: parentRefs: - name: higress-gateway namespace: higress-system rules: - matches: - path: type: PathPrefix value: / backendRefs: - name: service-provider.DEFAULT-GROUP.public.nacos group: networking.higress.io port: 8080 weight: 90 - name: foo-service port: 5678 weight: 10  和 K8s 服务不同的是，这里 group 为 networking.higress.io 的服务并不需要提前创建 CRD 资源，这更符合传统微服务用户的习惯，即服务模型不需要提前创建，是通过服务节点注册自动生成。 ","version":null,"tagName":"h3"},{"title":"Ingress API 和 Gateway API 之间如何选择​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#ingress-api-和-gateway-api-之间如何选择","content":"有了 Gateway API，是否应该立即抛弃 Ingress API？ 只有最合适的，没有最好的。Gateway API 虽然为更多网关能力做了标准化，但 CRD 的种类和复杂度也增加了，相比之下对于大部分简单用例场景，Ingress API 更加简单易用。 对于以下场景，采用 Gateway API 替代 Ingress API 会带来很大帮助： 大型团队划分了 SRE 角色和业务研发角色，由 SRE 通过 Gateway 资源统一管理站点域名和证书，由业务研发通过 HTTPRoute 资源管理业务路由，实现职责划分，权限收敛创建的路由和 Service 有不在一个命名空间的需求，可以借助 ReferenceGrant 资源实现有大量证书需要集中式管理，不希望将证书 Secret 同步到 Ingress 所在命名空间，带来安全风险 Gateway API 的另一个好处是对于更多功能的标准化定义，我们建议遇到实际需要再转换到这个新的标准，而不必盲目跟随。 Higress 支持 Gateway API 和 Ingress API 混合使用，Gateway API 下的域名路由将比 Ingress API 优先匹配，和 Ingress 相同资源名称的 HTTPRoute 还会继承 WASM 插件配置，这样用户可以按需采用 Gateway API，平滑地完成从 Ingress API 向 Gateway API 的演进，无需焦虑 API 标准升级过程中产生业务损失。 ","version":null,"tagName":"h3"},{"title":"新工具：All in one 的 hgctl​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#新工具all-in-one-的-hgctl","content":"","version":null,"tagName":"h2"},{"title":"替代 Helm 用于安装/升级​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#替代-helm-用于安装升级","content":"在 K8s 下用 Helm 安装/升级组件很方便，但在 Higress 的场景下仍然存在一些问题： 无法支持非 K8s 场景下的安装/升级Higress 有很多安装参数，进行升级等操作时不好维护，使用reuse-values 有一些副作用，且容易误操作无法管理 CRD 跟随版本更新，需要手动更新 Higress 借鉴了 istio 的 istioctl，提供了 hgctl 这个命令行工具解决了上述问题，通过以下命令即可安装 hgctl  # 下载最新版 Hgctl： curl -Ls https://raw.githubusercontent.com/alibaba/higress/main/tools/hack/get-hgctl.sh | VERSION=latest bash  hgctl 集成了三种 Higress 安装模式，并统一了升级/运维操作： 本地 K8s 环境（例如kind/k3s）模式正式 K8s 环境模式不依赖 K8s 的纯 Docker 环境模式 直接执行 hgctl install 命令即可选择任意模式进行安装 安装配置文件将存至 ~/.hgctl/profiles/install.yaml 目录下，查看该文件内容如下：  charts: higress: name: higress # 安装文件的 helm repo 地址 url: https://higress.io/helm-charts # 执行 hgctl upgrade 时将自动更新至最新版本 version: latest console: # 开启可观测组件 o11YEnabled: true # 控制台实例数 replicas: 1 controller: # 控制面组件实例数 replicas: 1 gateway: # 数据面组件实例数 replicas: 1 global: # 开启 Gateway API enableGatewayAPI: true # 开启 Istio API enableIstioAPI: true # 设置监听的 ingress class ingressClass: higress # 安装模式 install: local-k8s # 安装命名空间 namespace: higress-system # 配置传递给 helm 的 values 参数 values: {} profile: local-k8s  修改上面文件的内容后，执行hgctl upgarde即可实现参数变更生效，如果只想修改参数，不想触发版本升级，可以将 version 参数固定为当前版本。 ","version":null,"tagName":"h3"},{"title":"WASM 插件开发工具包​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#wasm-插件开发工具包","content":"为了标准化并简化 WASM 插件的开发/编译/测试/发布，Higress 提供了 hgctl plugin 这一子命令，使用方式为： hgctl plugin init: 初始化 Golang WASM 插件项目，包括三个文件；用户编写 WASM 插件逻辑；hgctl plugin build --output-type files: 构建 WASM 插件，在本地输出构建产物；hgctl plugin test: 使用 docker compose 在本地测试 WASM 插件，如需修改插件逻辑，则返回第 2 步；hgctl plugin build --output-type image: 构建 WASM 插件作为 OCI 镜像上传至镜像仓库；hgctl plugin install: 安装 WASM 插件，可以通过本地的 yaml 文件或插件项目进行安装。 另外，若需要查看已安装的插件，则使用 hgctl plugin ls；若需要操作插件配置，则使用 hgctl plugin config 通过这个工具，可以在构建 WASM 插件的同时，根据配置代码自动生成插件的配置说明文档，以及包含插件配置约束的元信息文件，这些内容都将和 WASM 文件一起放入 OCI 镜像制品中，通过镜像方式进行版本管理和分发。这一机制是后续 Higress 建设 WASM 插件市场的基石。 ","version":null,"tagName":"h3"},{"title":"其他功能​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#其他功能","content":"另外介绍两个实用的子命令： hgctl dashboard: 用于呼出 UI 界面，例如 Higress 控制台，直接通过 hgctl dashboard console 即可打开  $ hgctl dashboard Access to Higress web UIs Usage: hgctl dashboard [flags] hgctl dashboard [command] Aliases: dashboard, dash, d Available Commands: console Open Console web UI controller Open Controller debug web UI envoy Open Envoy admin web UI grafana Open Grafana web UI prometheus Open Prometheus web UI  hgctl gateway-config: 用于查看数据面的 envoy 配置，可以快速验证配置是否正确下发  $ hgctl gateway-config Retrieve information about Higress Gateway Configuration. Usage: hgctl gateway-config [command] Aliases: gateway-config, gc Available Commands: all Retrieves all Envoy xDS resources from the specified Higress Gateway bootstrap Retrieves bootstrap Envoy xDS resources from the specified Higress Gateway cluster Retrieves cluster Envoy xDS resources from the specified Higress Gateway endpoint Retrieves endpoint Envoy xDS resources from the specified Higress Gateway listener Retrieves listener Envoy xDS resources from the specified Higress Gateway route Retrieves route Envoy xDS resources from the specified Higress Gateway  ","version":null,"tagName":"h3"},{"title":"新征程：API Gateway​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#新征程api-gateway","content":"上面说了 Gateway API，接着我们聊聊 API Gateway 😄，API Gateway 有两层定义： 狭义上：满足统一接入，将路由转发到不同服务的运维需求，即可称为 API Gateway；这里 API 的定义是服务的路由广义上：在实现服务转发的基础上，需要识别带业务语义的接口，将业务能力 API 化管理，统一对外提供服务；这里 API 的定义是业务功能接口 Higress 已经实现了狭义上的 API Gateway 能力，并且是基于 Gateway/Ingress API 这些通用路由标准来实现的。而与服务路由标准不同，业务功能接口的标准是 Swagger/OAS3/RPC IDL 等，做为 API Gateway 需要提供以下关键能力： 支持通过上传 Swagger 等接口定义文件的方式导入 API对 API 实现精细化策略管理，例如根据出入参定义实现参数映射/转换实现以 API 方式开放能力时的认证/鉴权，调用量控制/审计能力 Higress 新的开源征程将向具备业务 API 管理能力的 API Gateway 形态进发。在实现方式上，我们将基于 WASM 插件去扩展这一部分能力，这可以降低我们对上游 Envoy 社区的侵入性改造，同时让对 API 的精细化策略管理具备自定义扩展能力。 目前社区已经有一些 Proposal ，欢迎了解： https://github.com/alibaba/higress/issues/535 https://github.com/alibaba/higress/issues/601 欢迎有更多小伙伴加入，和我们一起踏上新的征程，有兴趣的小伙伴可以联系我(微信：nomadao)，加入 API Gateway 的 SIG（兴趣小组）。 ","version":null,"tagName":"h2"},{"title":"社区致谢​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#社区致谢","content":"首先要感谢 Envoy 和 Istio 社区，Higress 站在这两个软件的肩膀上演进能力，得以： 通过 WASM 机制扩展 Envoy 数据面能力，持续不断地扩大网关插件生态通过专注在网关领域，在 Istio 优秀的控制面基础上，进一步做抽象和简化，降低上手和运维门槛 还要感谢参与 Higress 开源贡献的开发者们，这里重点感谢下为 1.3 版本做出核心贡献的开发者： ","version":null,"tagName":"h2"},{"title":"Maintainer：董艺荃(CH3CHO)​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#maintainer董艺荃ch3cho","content":"人如其名“艺全”，十八般武艺样样精通，不管是控制台 TS 前端，Java 后台，还是 Higress 的 GO 控制面，以及 Standalone 安装 Shell 脚本和各种 CICD 流程，通通手到擒来。 在 1.3 版本中主要负责了 Higress 支持 Gateway API 的能力，以及实现了 Higress Admin Java SDK 可以提供外部集成用于管理 Higress 配置，并改进了 Higress Console 的安全性和易用性。 除了开发贡献之外，他还对社区用户充满善意和热情，无论是在 GitHub 的 Issues/Discussions，或是社区交流微信/钉钉群，随处可见他帮助用户解决问题的身影。 ","version":null,"tagName":"h3"},{"title":"Approver：吴新军(Jun)，刘训灼(Xunzhuo)​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#approver吴新军jun刘训灼xunzhuo","content":"两位都在多个 Higress 版本为社区做出了贡献，Jun 的主要贡献有：在多注册中心的服务发现支持，全局配置管理架构抽象；Xunzhuo 的主要贡献有：Higress E2E 测试流程的搭建，GitHub CI 流程的建设，hgctl 的整体架构设计。 在 1.3 版本中二位协作完成了 hgctl 的多样化能力建设，帮助 Higress 的易用性又上到了一个新的台阶。 两位同学作为 Approver 积极参与社区贡献 PR 的 Review，目前分别是 Higress Tools SIG 和 Higress GatewayAPI SIG 的领导者。 ","version":null,"tagName":"h3"},{"title":"Member：韦鑫(WeixinX)，封宇腾(Fkbqf)​","type":1,"pageTitle":"Higress 开源一周年：新版本，新标准，新工具，新征程","url":"/zh-cn/blog/release-1.3#member韦鑫weixinx封宇腾fkbqf","content":"两位都是通过中科院开源之夏（OSPP 2023）项目开始参与 Higress 贡献，WeixinX 是一名研二的学生，Fkbqf 是一名大三的学生。 在 1.3 版本中，WeixinX 实现了 hgctl plugin 子命令的能力，同时贡献了 Go 实现的 Basic Auth 插件，以及对标 Spring Cloud Gateway 请求响应转换能力的 Transformer 插件；Fkbqf 则实现了更为复杂的 OIDC 插件，具备比 Envoy 自带 OAuth2 Filter 更强大的功能，并且具备良好的扩展性。 两位同学除了开发贡献以外，用课余时间积极参与 Higress 社区周会，一起探讨和学习技术，不亦乐乎。能够成为你们人生学业进阶路上的阶梯，Higress 荣幸之至。 Higress 社区后续整体的 Roadmap 规划如下：  欢迎更多小伙伴一起加入我们：  ","version":null,"tagName":"h3"},{"title":"关于美洽​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#关于美洽","content":"美洽是一家全球智能云客服服务商，提供一站式智能客服解决方案，旗下拥有在线客服、工单系统、呼叫中心、客服机器人、语音机器人、营销机器人等产品及服务。美洽成立于2014年，总部位于成都，目前服务企业用户已超过40万家，覆盖多个行业领域。美洽的客服系统支持多平台使用，包括Web 网页端、手机客户端、PC 客户端，同时美洽也提供了开放 API 平台。 ","version":null,"tagName":"h2"},{"title":"需求背景​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#需求背景","content":"多条业务线使用了了不同编程语言，在微服务化演进的路上困难重重；历史架构使用多个流量转发中间件导致流量路径冗长、复杂且故障排查困难（LB + OpenResty + Nginx + Caddy + SpringCloud-Gateway）；WebSocket 长连接服务在多重路由层上不支持热更新，维护成本高。 历史架构的流量拓扑图如下：  ","version":null,"tagName":"h2"},{"title":"需求目标​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#需求目标","content":"找到一个统一网关，能够一次性解决流量网关和业务网关的路由转发需求；支持路由规则热更新，解决 WebSocket 连接在路由更新或网络抖动时产生的重连风暴；前置API 请求权限校验、签名校验、WAF 拦截、CC 拦截；可视化统一网关的后台操作，让普通员工也能上手；多云架构下私有化部署支持。 ","version":null,"tagName":"h2"},{"title":"方案横向对比​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#方案横向对比","content":"通过对目前市面上流行的网关产品进行详细的横向对比，再结合美洽对统一网关的需求目标，我们从对比的表格当中，看到了 Higress 所带来的最佳对比结果。 同时美洽重点关注的几个点：K8S Ingress 支持、WebSocket支持、Nacos 服务发现、路由配置热更新、WASM 插件都得到了很好的支持。  ","version":null,"tagName":"h2"},{"title":"为什么选择 Higress​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#为什么选择-higress","content":"","version":null,"tagName":"h2"},{"title":"面向多云架构友好​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#面向多云架构友好","content":"Higress 在阿里云上有成熟的企业版产品：MSE 云原生网关，我们从 2021 年开始使用这款产品，这是一款全托管，完全免运维的 SaaS 网关产品，并且具备强劲的性能和丰富的功能，相比自建同吞吐的网关，整体成本是更低的，因此我们在阿里云上直接使用了这款产品。 美洽除了阿里云，在其他云上也有部署业务，我们希望能统一多云的统一网关技术架构，开源版 Higress 正好符合我们的需求，相比商业版，在控制台功能上，开源版目前的能力相对较少，但大部分功能也都可以通过自己定义 K8s CRD 配置的方式来实现，完全满足我们的需求。 ","version":null,"tagName":"h3"},{"title":"原生支持 K8s Ingress​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#原生支持-k8s-ingress","content":"美洽从 2021 年便已经全面迁移到 Kubernetes 进行资源调度，遇到最大的困难是历史的网关中间件，在容器化的架构里面，各种水土不服，要么需要借助 Nginx-Ingress-Controller，要么需要外部的 SLB 进行服务之间的负载均衡与网络通信。这导致了比容器化之前更加复杂的流量路径，一度让我们下定决心，必须、必须、必须要解决统一网关的问题，还必须云原生的。 2021 年底开始，我们开始尝试使用阿里云 MSE 网关 SaaS 产品，开始将部分服务从 Nginx 路由迁移到 MSE 网关上，很快解决了Ngxin Configuration 配置维护复杂，故障频发的问题，尝到甜头后，我们便开始计划进一步扩大 MSE 网关的使用，结合 Nacos 和 K8S 的服务发现，将 80% 大部分容器化服务路由转发全部迁移到了云原生网关上。 这带来的收益就包括： 简化了流量路径，公网流量通过 SLB 直接到达网关，网关路由直达容器 Pod；释放了使用 ECS 自建的 Nginx 、OpenResty 、Caddy 服务，降低了大量服务器成本；服务发现和服务治理，以及各个服务当前的健康状态都以可视化的 Dashborad 呈现出来； ","version":null,"tagName":"h3"},{"title":"控制面和数据面解耦的架构​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#控制面和数据面解耦的架构","content":"控制面和数据面解耦是一种很好的设计模式，把管理控制逻辑和运行处理逻辑分开，这样可以更好地管理和扩展系统。 Console 负责管理 和 Gateway 负责处理请求，灵活可扩展，互补干扰；整个系统的性能和可用性可以得到很好的保障；即使控制面出现问题，数据面仍然可以继续处理请求，反之亦然。 在美洽客服自己的产品中，也大量试用了控制面和数据面分离的这种架构设计模式，在选择 Higress 统一网关的落地实践中，也更好的可以和美洽产品的架构进行配合，例如控制台采用微前端技术统一美洽运维控制台，Higress 控制台，Nacos 控制台。 ","version":null,"tagName":"h3"},{"title":"容易上手的后台 Dashboard​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#容易上手的后台-dashboard","content":"在早期，美洽在 2021 年开始使用阿里云 MSE 云原生网关时，就已经对网关的控制台使用有了很多的经验基础，团队中 QA 同学也能熟练使用了。目前在其他云上的项目，私有化部署的开源版Higress，在控制台方面功能与操作和阿里云 MSE 产品的交互保持一致，团队使用很快便上手了。  插件方面，美洽使用了 JWT Auth 鉴权，Key Rate Limit 限流，HMAC Auth 请求签名，Bot Detect 和 WAF 功能有涉及。  ","version":null,"tagName":"h3"},{"title":"美洽的落地实践​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#美洽的落地实践","content":"","version":null,"tagName":"h2"},{"title":"采用 Helm 在 K8s node 上 一键部署​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#采用-helm-在-k8s-node-上-一键部署","content":"helm repo add higress.io &lt;https://higress.io/helm-charts&gt; helm install higress higress.io/higress -n higress-system --create-namespace  ","version":null,"tagName":"h3"},{"title":"完全替代了 Nginx 、OpenResty、Caddy 、SLB-Intranet​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#完全替代了-nginx-openrestycaddy-slb-intranet","content":" ","version":null,"tagName":"h3"},{"title":"彻底解决 WebSocket 断线重连问题​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#彻底解决-websocket-断线重连问题","content":"美洽的智能客服产品侧试用了 WebSocket 进行长连接保持和消息通信，所以非常依赖网络的稳定，以及更新网关配置所带来的副作用。在使用 Nginx + OpenResty 方案的期间，每一次的配置变更都会带来极大的代价，断线重连风暴时常发生。一次配置变更 Pendding 或者变更失败带来的瞬时断联是及其痛苦的。  在迁移到 Higress 上之后，路由配置热更新特性，不在需要像 Nginx 一样需要 Reload Gateway，解决配置更新 reload 带来的断线重连风暴问题。 另外，在 WebSocket Server 服务升级过程中，通过给 Pod 打上 stage 标签，在 Higress 侧通过标签路由进行新老版本无损流量切换，给产品快速迭代升级带了巨大的杠杆效应。 ","version":null,"tagName":"h3"},{"title":"熔断限流​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#熔断限流","content":"在面向 2B 的 SaaS 产品业务场景中，经常会发生某一个客户突发海量流量，占据大量带宽，影响其他客户正常使用的情况，这时我们需要针对客户规模对单个客户的 API 并发上限做灵活的动态限流，使用 Higress 的插件Key Rate Limit 就很好的解决了这个问题，根据流量大盘随时调整限流水位红线，做到精准，灵活的限流。  ","version":null,"tagName":"h3"},{"title":"经验总结​","type":1,"pageTitle":"美洽智能客服使用 Higress 统一网关落地实践","url":"/zh-cn/blog/user-mq#经验总结","content":"Higress 网关的落地，给企业全面落地云原生微服务架构提供强有力的支持，对我们技术人员来说，这绝对是一个杠杆级别的开源产品，另外，在阿里云上又有对等的 SaaS 产品，这样的配合，将公有云和私有化部署的统一网关一次性全部解决，对企业来说是绝对的利好。 统一流量网关+业务网关能力，实现了给企业降本，为研发增效；为云原生架构提供很好的基座，在异构语言服务化层面排除了网络通信难题；路由热更新、无损升级、可视化 Console、开放的插件、基于 Kubernetes 和 Istio，给技术演进带来了更多的可能性。 最后，我们祝愿 Higress 在云原生的道路上越走越远，大家一起用开源、开放、分享的心态将 Higress 建设地越来越好。 ","version":null,"tagName":"h2"},{"title":"UU跑腿基于Higress的云原生网关实践","type":0,"sectionRef":"#","url":"/zh-cn/blog/user-uu","content":"","keywords":"higress UU跑腿","version":null},{"title":"UU跑腿介绍​","type":1,"pageTitle":"UU跑腿基于Higress的云原生网关实践","url":"/zh-cn/blog/user-uu#uu跑腿介绍","content":"UU跑腿隶属于郑州时空隧道信息技术有限公司，是更专业的同城即时生活服务平台，以共享劳动力与时间为众包理念，人人都可注册成为跑腿师傅，并为附近的人提供帮取送、帮买、全能帮、帮排队等多样化同城即时服务，为中小企业、电商、本地商户提供安全专业的高端配送服务。UU跑腿秉承“让生活更美好”的理念，不断创新、不断进步，为用户提供更加优质的服务体验。 ","version":null,"tagName":"h2"},{"title":"背景需求​","type":1,"pageTitle":"UU跑腿基于Higress的云原生网关实践","url":"/zh-cn/blog/user-uu#背景需求","content":"UU跑腿对于云原生网关的要求是，能同时满足流量网关，微服务网关，以及安全网关的场景诉求，用一个网关来解决之前需要部署多个网关才能解决的问题： 具备高可靠性和高性能，可以替代之前部署的 Nginx Ingress 流量网关同时支持 K8s 生态和传统微服务生态接入，支持（HTTP转Dubbo）协议转换，可以替代之前部署的 Spring Cloud Gateway 微服务网关能够支持在网关入口处完成鉴权，避免每个后端服务重复实现鉴权功能，实现安全网关的能力具备易用的控制台进行 API 的治理，以及具备丰富的可观测指标 ","version":null,"tagName":"h2"},{"title":"迁移 Higress 前的架构​","type":1,"pageTitle":"UU跑腿基于Higress的云原生网关实践","url":"/zh-cn/blog/user-uu#迁移-higress-前的架构","content":" 之前存在的主要痛点： Spring Cloud Gateway 自身参数调整改动需要重新部署影响流量，且动态路由需要进行复杂的配置，包括路由规则，容易出现配置错误导致系统异常运维需要同时维护 Nginx Ingress 和 Spring Cloud Gateway，面对流量高峰进行进行扩容相关操作时，运维负担比较重，而且这样两层网关的请求的链路较长，可用性低、成本高 ","version":null,"tagName":"h2"},{"title":"迁移 Higress 后的架构​","type":1,"pageTitle":"UU跑腿基于Higress的云原生网关实践","url":"/zh-cn/blog/user-uu#迁移-higress-后的架构","content":" Higress云原生网关实现负载均衡、路由、安全认证等功能。通过网关对外提供服务统一入口，并对请求进行鉴权、限流和监控等操作，用简单的架构保证了整体系统的稳定性和可靠性。 合并流量网关（K8s Nginx Ingress）和微服务网关（Spring Cloud Gateway ），降低网关成本，高性能服务；同时支持 K8s service 和 Nacos 服务注册发现，满足技术需求对 K8s 生态和传统微服务生态接入。Nginx Ingress 完美迁移到 Higress，十分丝滑 ","version":null,"tagName":"h2"},{"title":"Higress 集成 Skywalking 可观测性探索","type":0,"sectionRef":"#","url":"/zh-cn/blog/skywalking","content":"","keywords":"higress","version":null},{"title":"一、整体架构图​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#一整体架构图","content":" 整体包含四大块内容： Higress 组件： higress-gateway, higress-console, higress-controllerSkywalking 组件： skywalking dashboard ui, skywalking aop server业务应用组件： bff, middle service, backend serviceIngress 组件： skywalking.higress.io, httpbin.example.com ","version":null,"tagName":"h2"},{"title":"二、Skywalking 调用链路跟踪原理​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#二skywalking-调用链路跟踪原理","content":"SkyWalking为服务(service)，服务实例(service instance)，以及端点(endpoint)提供了可观测能力。 服务(service)：表示对请求提供相同行为的一组工作负载。在使用打点代理或 SDK 的时候，可以定义服务的名字。服务实例(Service Instance)：一组工作负载中的每一个工作负载称为一个实例。端点(Endpoint)： 对于特定服务所接收的请求路径，如 HTTP 的 URI 路径和 gRPC 服务的类名 + 方法签名。进程（Process）： 操作系统进程. 在某些场景下，一个服务实例和进程不是一一对应， 在k8s部署下，一个POD对应多个进程。 ","version":null,"tagName":"h2"},{"title":"Skywalking 整体架构​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#skywalking-整体架构","content":" 主要由四个核心组件组成： 探针: 探针用于收集监测数据包括指标，链路跟踪，日志和事件数据接收和聚合: 平台后端支持数据聚合，数据分析以及驱动数据流从探针到用户界面的处理存储: 通过开放接口支持后端存储系统支持ElasticSearch, H2, MySQL, TiDB, BanyanDB等UI: 一个定制化的Web系统，用户可以可视化查看和管理 SkyWalking 数据 ","version":null,"tagName":"h3"},{"title":"分布式链路追踪原理分析​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#分布式链路追踪原理分析","content":"分布式链路介绍 分布式链路追踪是记录来源于用户请求在各个系统或者服务中所传播的路径。 A distributed trace, more commonly known as a trace, records the paths taken by requests (made by an application or end-user) as they propagate through multi-service architectures, like microservice and serverless applications. 分布式链路追踪图示如下：  Skywalking 分布式链路追踪 主要包含四个内容： Trace: 一个完整的链路由多个 Segment 组成Segment: 一个请求在一个进程内的轨迹Span: 一个请求在某个进程里的一个组件逻辑内的轨迹, 有 Entry Span， Local Span 和 Exit Span 三类Span context: 跨进程或者服务 Trace 传递，这里讨论 http 传递头 sw8 基本组件图示如下：  从上图可以看出： 一个 Trace 内的所有 span 的 Trace ID 是相同的一个 Segment 中有一个 EntrySpan，是 Segment 内其他 Span 的根 Parent后一个 Segment的 Entryspan 总是与前一个 Segment 中的某个 ExitSpan 关联 Skywalking Trace 的数据协议 具体数据协议参考 Skywalking Trace Data Protocol, 这里主要讲一下 sw8 格式和组成。 sw8 格式: XXXXX-XXXXX-XXXX-XXXX，以 - 分割。 样例: 1-MzYzMzM1NDctNTc0YS00MzZlLTgzNWEtNTY1YTQyNzk3YTY3-ZWQ3ODA2ZjYwNTI0MTFlZWE5ZDdmZTFhNTA5YTRmYTk=-1-bWlkZGxl-bWlkZGxlLTZmNGRkN2JmNmMtcWJ4cm0=-L0dFVC9zZXJ2aWNl-aHR0cDovL2JhY2tlbmQv 具体内容如下： 采样标记(Sample): 0 或者 1， 0 表示不采样 1 表示采样跟踪ID(Trace ID): 字符(BASE64 编码)父Sengment ID (Parent trace segment ID): 字符(BASE64 编码)父 Span ID（Parent span ID): 整型父服务名称(Parent service): 字符(BASE64 编码)父服务实例(Parent service instance): 字符(BASE64 编码)父Endpoint(Parent endpoint): 字符(BASE64 编码)目标地址：字符(BASE64 编码) ","version":null,"tagName":"h3"},{"title":"三、Higress 架构​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#三higress-架构","content":"Higress是基于阿里内部的Envoy Gateway实践沉淀、以开源 Istio + Envoy 为核心构建的下一代云原生网关，实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，深度集成Dubbo、Nacos、Sentinel等微服务技术栈，能够帮助用户极大的降低网关的部署及运维成本且能力不打折； 在标准上全面支持 Ingress与 Gateway API，积极拥抱云原生下的标准API规范； 同时，Higress Controller也支持Nginx Ingress平滑迁移，帮助用户零成本快速迁移到Higress。  ","version":null,"tagName":"h2"},{"title":"四、业务应用集成 Skywalking​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#四业务应用集成-skywalking","content":"业务应用通过与 go2sky 项目集成 SkyWalking 监控 Golang 应用程序，主要通过 Gin middleware 和 Http 请求手动埋点。 1、集成 Gin middleware func middleware(engine *gin.Engine, tracer *go2sky.Tracer) gin.HandlerFunc { if engine == nil || tracer == nil { return func(c *gin.Context) { c.Next() } } return func(c *gin.Context) { if strings.HasPrefix(c.Request.URL.String(), skipProbPrefix) || strings.HasPrefix(c.Request.URL.String(), skipMetricsPrefix) { c.Next() return } span, ctx, err := tracer.CreateEntrySpan(c.Request.Context(), getOperationName(c), func(key string) (string, error) { return c.Request.Header.Get(key), nil }) if err != nil { c.Next() return } span.SetComponent(componentIDGINHttpServer) span.Tag(go2sky.TagHTTPMethod, c.Request.Method) span.Tag(go2sky.TagURL, c.Request.Host+c.Request.URL.Path) span.SetSpanLayer(agentv3.SpanLayer_Http) c.Request = c.Request.WithContext(ctx) c.Next() if len(c.Errors) &gt; 0 { span.Error(time.Now(), c.Errors.String()) } span.Tag(go2sky.TagStatusCode, strconv.Itoa(c.Writer.Status())) span.End() } } func getOperationName(c *gin.Context) string { return fmt.Sprintf(&quot;/%s%s&quot;, c.Request.Method, c.FullPath()) }  2、Http请求手动埋点 func traceHttpCall(c *gin.Context, req *http.Request, url string, fn func(req *http.Request) (*http.Response, error)) (*http.Response, error) { tracer := go2sky.GetGlobalTracer() if tracer == nil { resp, err := fn(req) return resp, err } reqSpan, err := go2sky.GetGlobalTracer().CreateExitSpan(c.Request.Context(), &quot;invoke&quot;, url, func(headerKey, headerValue string) error { req.Header.Set(headerKey, headerValue) return nil }) reqSpan.SetComponent(2) reqSpan.SetSpanLayer(v3.SpanLayer_Http) resp, err2 := fn(req) reqSpan.Tag(go2sky.TagHTTPMethod, http.MethodGet) reqSpan.Tag(go2sky.TagURL, url) reqSpan.End() return resp, err2 }  ","version":null,"tagName":"h2"},{"title":"五、本地测试环境搭建​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#五本地测试环境搭建","content":"本地安装 kubectl, kind, helm 可以参考 Higress 快速开始安装 kubectl, kind。 helm 安装参考安装文档 安装 higress 和 istio CRD 可以参考 higress 快速开始 和 安装部署 来部署，这里需要安装 Istio CRD。 下面是一个参考安装命令: helm install higress -n higress-system --set global.onlyPushRouteCluster=false --set higress-core.skywalking.enabled=true --set higress-core.skywalking.service.address=skywalking-oap-server.op-system.svc.cluster.local --set higress-core.skywalking.service.port=11800 higress.io/higress  部署 Skywalking，业务应用和 Ingress $ export KUBECONFIG=${HOME}/.kube/config_higress $ kubectl apply -f skywalking.yaml $ kubectl apply -f app.yaml $ kubectl apply -f ingress.yaml  检查 POD 运行状态和 Ingress 状态 $ export KUBECONFIG=${HOME}/.kube/config_higress $ kubectl get pods -n higress-system NAME READY STATUS RESTARTS AGE higress-console-6f554978dc-cclg7 1/1 Running 0 100m higress-console-grafana-7495766db4-4flq5 1/1 Running 0 131m higress-console-prometheus-6d7bdccfb-hxtsq 1/1 Running 0 131m higress-controller-689c5b965f-7wsmt 2/2 Running 0 131m higress-gateway-59966b45d9-z7ltd 1/1 Running 0 131m $ kubectl get pods -n op-system NAME READY STATUS RESTARTS AGE skywalking-oap-dashboard-65f496ccc9-dr96l 1/1 Running 0 99m skywalking-oap-server-859694656b-p8vcq 1/1 Running 0 99m $ kubectl get pods -n app-system NAME READY STATUS RESTARTS AGE backend-6b9549bc64-f98tr 1/1 Running 0 99m backend-6b9549bc64-x2btl 1/1 Running 0 99m bff-766967f8db-8ght7 1/1 Running 0 99m bff-766967f8db-gflbh 1/1 Running 0 99m middle-6f4dd7bf6c-qdjqj 1/1 Running 0 99m middle-6f4dd7bf6c-stzf4 1/1 Running 0 99m $ kubectl get svc -n app-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE backend ClusterIP 10.96.179.140 &lt;none&gt; 80/TCP 99m bff ClusterIP 10.96.121.62 &lt;none&gt; 80/TCP 99m middle ClusterIP 10.96.55.8 &lt;none&gt; 80/TCP 99m $ kubectl get ingress -n higress-system NAME CLASS HOSTS ADDRESS PORTS AGE httpbin higress httpbin.example.com 80 8s skywalking-dashboard higress skywalking.higress.io 80 8s  测试 Higress Console, Skywalking Dashboard, Bff 服务 1）编辑 /etc/hosts 文件添加以下三个域名 127.0.0.1 skywalking.higress.io 127.0.0.1 httpbin.example.com  2）打开 higress-gateway 端口转发 $ export KUBECONFIG=${HOME}/.kube/config_higress $ kubectl -n higress-system port-forward service/higress-gateway 8080:80 $ kubectl -n higress-system port-forward service/higress-console 18080:8080  3）通过浏览器打开访问上面三个域名 Higress 控制台: http://127.0.0.1:8080。首次访问控制台时需要先初始化管理员用户。初始化完成后使用对应的用户名密码登录即可。  Skywalking Dashboard: http://skywalking.higress.io:8080  Bff 服务： http://httpbin.example.com:8080/hostname  ","version":null,"tagName":"h2"},{"title":"六、Higress 集成 Skywalking 调用链路跟踪配置​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#六higress-集成-skywalking-调用链路跟踪配置","content":"通过修改 Higress configmap 全局配置 higress-config 来激活 Higress 集成 Skywalking 调用链路跟踪。 $ export KUBECONFIG=${HOME}/.kube/config_higress $ kubectl edit configmap higgress-config -n higress-system  在 data 下增加 higress 配置项然后保存，具体配置内容如下： data: higress: |- tracing: enable: true sampling: 100 timeout: 500 skywalking: service: skywalking-oap-server.op-system.svc.cluster.local port: 11800  ","version":null,"tagName":"h2"},{"title":"七、Skywalking 链路跟踪​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#七skywalking-链路跟踪","content":"","version":null,"tagName":"h2"},{"title":"运行压测脚本​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#运行压测脚本","content":"for i in $(seq 1 1000) do curl -v -H &quot;Host:httpbin.example.com&quot; http://127.0.0.1:8080/hostname curl -v -H &quot;Host:httpbin.example.com&quot; http://127.0.0.1:8080/ curl -v -H &quot;Host:httpbin.example.com&quot; http://127.0.0.1:8080/service?services=middle,backend done  ","version":null,"tagName":"h3"},{"title":"调用 bff 服务 /service 接口来模拟调用链路​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#调用-bff-服务-service-接口来模拟调用链路","content":"curl -v -H &quot;Host:httpbin.example.com&quot; http://127.0.0.1:8080/service?services=middle,backend  部分返回响应体情况如下： { &quot;args&quot;: { }, &quot;form&quot;: { }, &quot;headers&quot;: { &quot;accept-encoding&quot;: &quot;gzip&quot;, &quot;sw8&quot;: &quot;1-MzYzMzM1NDctNTc0YS00MzZlLTgzNWEtNTY1YTQyNzk3YTY3-ZWQ3ODA2ZjYwNTI0MTFlZWE5ZDdmZTFhNTA5YTRmYTk=-1-bWlkZGxl-bWlkZGxlLTZmNGRkN2JmNmMtcWJ4cm0=-L0dFVC9zZXJ2aWNl-aHR0cDovL2JhY2tlbmQv&quot;, &quot;sw8-correlation&quot;: &quot;&quot;, &quot;user-agent&quot;: &quot;Go-http-client/1.1&quot;, &quot;x-httpbin-trace-host&quot;: &quot;bff-766967f8db-jwn2g/middle-6f4dd7bf6c-qbxrm/backend-6b9549bc64-8twnx&quot;, &quot;x-httpbin-trace-service&quot;: &quot;bff/middle/backend&quot;, &quot;x-request-id&quot;: &quot;e5a1b250-ebe3-931d-91d7-90e3ee2fc867&quot; }, &quot;method&quot;: &quot;GET&quot;, &quot;origin&quot;: &quot;&quot;, &quot;url&quot;: &quot;/&quot;, &quot;envs&quot;: { &quot;NODE_NAME&quot;: &quot;higress-worker2&quot;, &quot;PATH&quot;: &quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;POD_IP&quot;: &quot;10.244.1.7&quot;, &quot;POD_NAME&quot;: &quot;backend-6b9549bc64-8twnx&quot;, &quot;POD_NAMESPACE&quot;: &quot;app-system&quot;, &quot;SERVICE_ACCOUNT&quot;: &quot;backend&quot;, &quot;SERVICE_NAME&quot;: &quot;backend&quot;, &quot;VERSION&quot;: &quot;v1&quot; }, &quot;host_name&quot;: &quot;backend-6b9549bc64-8twnx&quot;, &quot;body&quot;: &quot;&quot; }  响应头中和调用链路跟踪相关有如下： &quot;sw8&quot;: &quot;1-MzYzMzM1NDctNTc0YS00MzZlLTgzNWEtNTY1YTQyNzk3YTY3-ZWQ3ODA2ZjYwNTI0MTFlZWE5ZDdmZTFhNTA5YTRmYTk=-1-bWlkZGxl-bWlkZGxlLTZmNGRkN2JmNmMtcWJ4cm0=-L0dFVC9zZXJ2aWNl-aHR0cDovL2JhY2tlbmQv&quot;, &quot;x-httpbin-trace-host&quot;: &quot;bff-766967f8db-jwn2g/middle-6f4dd7bf6c-qbxrm/backend-6b9549bc64-8twnx&quot;, &quot;x-httpbin-trace-service&quot;: &quot;bff/middle/backend&quot;,  其中： sw8: Skywalking 用于跟踪的 Http Headerx-httpbin-trace-host: 调用链路经过 POD_NAMEx-httpbin-trace-service: 调用链路经过 SERVICE_NAME 在 Skywalking dashboard 中查看如下： 服务截图  调用链路截图  调用链路拓扑截图  ","version":null,"tagName":"h3"},{"title":"八、Higress gateway 指标和监控面板​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#八higress-gateway-指标和监控面板","content":"可以通过度量各个组件的性能指标，例如响应时间、吞吐量、错误率、资源使用率等指标来了解系统的状态和性能。 指标数据包含指标名称，指标标签，和指标值，下面是 envoy_cluster_upstream_cx_total upstream（总连接数）部分指标数据， 其中 envoy_cluster_upstream_cx_total 是指标名称，cluster_name 是指标标签，16 是指标值。 # TYPE envoy_cluster_upstream_cx_total counter envoy_cluster_upstream_cx_total{cluster_name=&quot;outbound|80||bff.app-system.svc.cluster.local&quot;} 16  Higress 指标数据大体可以分为三类: Downstream 下游: 指标与外来的连接/请求有关，主要由侦听器，HTTP连接管理器等UpStream 上游: 指标与外向的连接/请求有关，主要由连接池，路由器，过滤器，熔断等Server 负载: 指标信息记录 Higress gateway 服务器实例的负载等 Higress 指标数据类型主要有三类: Counter: 无符号整数，只会增加而不会减少。例如，总请求Gauge: 增加和减少的无符号整数。例如，当前活动的请求Histogram: 作为指标流的一部分的无符号整数，然后由收集器聚合以最终产生汇总的百分位值(percentile，即平常说的 P99/P50/Pxx)。例如，Upstream 响应时间 通过以下命令可以获取 Higress gateway 支持的指标和类型 $ export HIGRESS_GATEWAY_POD=$(kubectl get pods -l app=higress-gateway -o 'jsonpath={.items[0].metadata.name}' -n higress-system) $ kubectl exec &quot;$HIGRESS_GATEWAY_POD&quot; -n higress-system -- curl -sS http://127.0.0.1:15020/stats/prometheus | grep &quot;# TYPE&quot;  部分指标内容如下： ... # TYPE envoy_cluster_upstream_cx_total counter # TYPE envoy_cluster_upstream_cx_tx_bytes_total counter # TYPE envoy_cluster_upstream_flow_control_backed_up_total counter # TYPE envoy_cluster_upstream_flow_control_drained_total counter # TYPE envoy_cluster_upstream_flow_control_paused_reading_total counter # TYPE envoy_cluster_upstream_flow_control_resumed_reading_total counter # TYPE envoy_cluster_upstream_internal_redirect_failed_total counter # TYPE envoy_cluster_upstream_internal_redirect_succeeded_total counter # TYPE envoy_cluster_upstream_rq counter # TYPE envoy_cluster_upstream_rq_101 counter # TYPE envoy_cluster_upstream_rq_200 counter # TYPE envoy_cluster_upstream_rq_201 counter # TYPE envoy_cluster_upstream_rq_301 counter # TYPE envoy_cluster_upstream_rq_302 counter # TYPE envoy_cluster_upstream_rq_304 counter # TYPE envoy_cluster_upstream_rq_401 counter # TYPE envoy_cluster_upstream_rq_404 counter # TYPE envoy_cluster_upstream_rq_cancelled counter # TYPE envoy_cluster_upstream_rq_completed counter # TYPE envoy_cluster_upstream_rq_maintenance_mode counter # TYPE envoy_cluster_upstream_rq_max_duration_reached counter # TYPE envoy_cluster_upstream_rq_pending_failure_eject counter # TYPE envoy_cluster_upstream_rq_pending_overflow counter # TYPE envoy_cluster_upstream_rq_pending_total counter # TYPE envoy_cluster_upstream_rq_per_try_idle_timeout counter # TYPE envoy_cluster_upstream_rq_per_try_timeout counter # TYPE envoy_cluster_upstream_rq_retry counter # TYPE envoy_cluster_upstream_rq_retry_backoff_exponential counter # TYPE envoy_cluster_upstream_rq_retry_backoff_ratelimited counter # TYPE envoy_cluster_upstream_rq_retry_limit_exceeded counter # TYPE envoy_cluster_upstream_rq_retry_overflow counter # TYPE envoy_cluster_upstream_rq_retry_success counter # TYPE envoy_cluster_upstream_rq_rx_reset counter # TYPE envoy_cluster_upstream_rq_timeout counter # TYPE envoy_cluster_upstream_rq_total counter # TYPE envoy_cluster_upstream_rq_tx_reset counter ... # TYPE envoy_http_downstream_cx_total counter # TYPE envoy_http_downstream_cx_tx_bytes_total counter # TYPE envoy_http_downstream_cx_upgrades_total counter # TYPE envoy_http_downstream_flow_control_paused_reading_total counter # TYPE envoy_http_downstream_flow_control_resumed_reading_total counter # TYPE envoy_http_downstream_rq counter # TYPE envoy_http_downstream_rq_completed counter # TYPE envoy_http_downstream_rq_failed_path_normalization counter # TYPE envoy_http_downstream_rq_header_timeout counter # TYPE envoy_http_downstream_rq_http1_total counter # TYPE envoy_http_downstream_rq_http2_total counter # TYPE envoy_http_downstream_rq_http3_total counter # TYPE envoy_http_downstream_rq_idle_timeout counter # TYPE envoy_http_downstream_rq_max_duration_reached counter # TYPE envoy_http_downstream_rq_non_relative_path counter # TYPE envoy_http_downstream_rq_overload_close counter # TYPE envoy_http_downstream_rq_redirected_with_normalized_path counter # TYPE envoy_http_downstream_rq_rejected_via_ip_detection counter # TYPE envoy_http_downstream_rq_response_before_rq_complete counter # TYPE envoy_http_downstream_rq_rx_reset counter # TYPE envoy_http_downstream_rq_timeout counter # TYPE envoy_http_downstream_rq_too_large counter # TYPE envoy_http_downstream_rq_total counter # TYPE envoy_http_downstream_rq_tx_reset counter # TYPE envoy_http_downstream_rq_ws_on_non_ws_route counter ...  具体指标定义参考如下： cluster managerhttp connection managerlistenersserver 如何查看 Higress 指标数据： 通过 http://127.0.0.1:18080/dashboard 查看 Higress gateway 监控面板通过 Skywalking Dashboard 查看 Higress gateway 监控数据 通过 Skywalking Dashboard 查看 Higress gateway 监控数据部分截图如下：  ","version":null,"tagName":"h2"},{"title":"参考文档​","type":1,"pageTitle":"Higress 集成 Skywalking 可观测性探索","url":"/zh-cn/blog/skywalking#参考文档","content":"https://istio.io/latest/docs/tasks/observability/distributed-tracing/skywalking/http://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.htmlhttps://skywalking.apache.org/docs/main/next/en/api/x-process-propagation-headers-v3/https://skywalking.apache.org/docs/main/next/en/api/trace-data-protocol-v3/ ","version":null,"tagName":"h2"},{"title":"教程：如何在本地开发和调试 Higress 控制台","type":0,"sectionRef":"#","url":"/zh-cn/docs/dev/console-dev","content":"教程：如何在本地开发和调试 Higress 控制台 教程链接","keywords":"higress console","version":"Next"},{"title":"源码阅读指引","type":0,"sectionRef":"#","url":"/zh-cn/docs/dev/code","content":"源码阅读指引 如果您想给 Higress 贡献代码，请参考参与贡献 代码目录结构说明 cmd: 命令行参数解析等处理代码 pkg/ingress: Ingress 资源转换为 Istio 资源等相关代码 pkg/bootstrap: 包括启动 gRPC/xDS/HTTP server 等的代码 registry: 实现对接多种注册中心进行服务发现的代码 envoy: 依赖的 envoy 官方仓库 commit，以及对应的补丁代码 istio: 依赖的 istio 官方仓库 commit，以及对应的补丁代码 plugins: Higress 插件 sdk，以及官方内置插件代码 script: 编译相关脚本 docker: docker 镜像构建相关脚本 在编译过程中会自动执行make prebuild，将产生 external 目录，这是将用到的 envoy 和 istio 依赖，打上对应的补丁代码后生成。 如果要修改 envoy 和 istio 代码，并产生新的补丁文件，可以直接在 external 目录下修改，并进行重命名，再执行 prebuild，之后对比生成补丁文件，例如: mv external/envoy external/envoy_new make prebuild cd external diff -Naur envoy envoy_new &gt; ../envoy/1.20/patches/envoy/$(date +%Y%m%d)-what-changed.patch 注意补丁执行顺序按照文件名字符顺序，请以时间戳开头","keywords":"higress coding","version":"Next"},{"title":"教程：如何在本地进行higress调试和端到端测试","type":0,"sectionRef":"#","url":"/zh-cn/docs/dev/e2e-debug","content":"教程：如何在本地进行higress调试和端到端测试 教程链接","keywords":"higress","version":"Next"},{"title":"组件编译说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/dev/architecture","content":"","keywords":"higress architecture","version":"Next"},{"title":"Higress Controller​","type":1,"pageTitle":"组件编译说明","url":"/zh-cn/docs/dev/architecture#higress-controller","content":"Higress 的控制面程序，会连接 Istio ，用于生成 Istio API 对象，通过 xDS 协议发送给 Istio。 在 higress 仓库目录下执行 make build 即可进行本地环境能运行的二进制编译 若需要编译 docker 镜像，请执行 make docker-build。Higress Controller使用的Istio pilot镜像使用make build-istio-local 编译。 ","version":"Next","tagName":"h2"},{"title":"Higress Gateway​","type":1,"pageTitle":"组件编译说明","url":"/zh-cn/docs/dev/architecture#higress-gateway","content":"Higress 的数据面程序，用于实现网关路由转发等能力。 ","version":"Next","tagName":"h2"},{"title":"快速构建​","type":1,"pageTitle":"组件编译说明","url":"/zh-cn/docs/dev/architecture#快速构建","content":"适用场景：未对 Envoy 本体进行了修改，即不需要重新编译 Envoy 本体的情况 构建步骤： 在命令行下进入 higress 仓库目录；执行 make build-gateway-local 命令，进行 Higress Gateway 镜像的构建；构建完成后会输出镜像 tag。 ","version":"Next","tagName":"h3"},{"title":"完整构建​","type":1,"pageTitle":"组件编译说明","url":"/zh-cn/docs/dev/architecture#完整构建","content":"适用场景：需要重新编译 Envoy 本体的情况 构建步骤： 在命令行下进入 higress 仓库目录；执行 cd external/proxy; BUILD_WITH_CONTAINER=1 make test_release 命令，构建 Envoy 本体；构建完成后，生成的 envoy.tar.gz 文件会放在 higress 仓库目录的 external/package 子目录内；将构建完成后输出的 envoy.tar.gz 文件，根据本机的系统架构重命名为 envoy-amd64.tar.gz 或 envoy-arm64.tar.gz；如果需要构建多平台镜像，那么需要在另一个平台的系统上完成 Envoy 的构建，并将其生成的 envoy.tar.gz 文件重命名后复制到本机上（参考以上 2、3 两步）；参考上面的快速构建步骤，构建 Higress Gateway 镜像。 ","version":"Next","tagName":"h3"},{"title":"Higress自定义CRD开发指引","type":0,"sectionRef":"#","url":"/zh-cn/docs/dev/CustomResourceDefinition","content":"","keywords":"higress CRD","version":"Next"},{"title":"CRD模型定义​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#crd模型定义","content":"","version":"Next","tagName":"h2"},{"title":"进入api目录​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#进入api目录","content":"higress/api 根据所要新建CRD的api类型，选择相对于的子目录，比如 networking/v1 ","version":"Next","tagName":"h3"},{"title":"编写CRD模型​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#编写crd模型","content":"比如我这里想定义一个http_2_rpc的CRD资源 http_2_rpc.proto // Copyright (c) 2022 Alibaba Group Holding Ltd. // // Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &quot;AS IS&quot; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. syntax = &quot;proto3&quot;; import &quot;google/api/field_behavior.proto&quot;; // $schema: higress.networking.v1.Http2Rpc // $title: Http2Rpc // $description: Configuration affecting service discovery from multi registries // $mode: none package higress.networking.v1; option go_package = &quot;github.com/alibaba/higress/api/networking/v1&quot;; // &lt;!-- crd generation tags // +cue-gen:Http2Rpc:groupName:networking.higress.io // +cue-gen:Http2Rpc:version:v1 // +cue-gen:Http2Rpc:storageVersion // +cue-gen:Http2Rpc:annotations:helm.sh/resource-policy=keep // +cue-gen:Http2Rpc:subresource:status // +cue-gen:Http2Rpc:scope:Namespaced // +cue-gen:Http2Rpc:resource:categories=higress-io,plural=http2rpcs // +cue-gen:Http2Rpc:preserveUnknownFields:false // --&gt; // // &lt;!-- go code generation tags // +kubetype-gen // +kubetype-gen:groupVersion=networking.higress.io/v1 // +genclient // +k8s:deepcopy-gen=true // --&gt; message Http2Rpc { oneof destination { DubboService dubbo = 1; GrpcService grpc = 2; } } message DubboService { string service = 1 [(google.api.field_behavior) = REQUIRED]; string version = 2 [(google.api.field_behavior) = REQUIRED]; string group = 3 [(google.api.field_behavior) = OPTIONAL]; repeated Method methods = 4 [(google.api.field_behavior) = REQUIRED]; } message Method { string service_method = 1 [(google.api.field_behavior) = REQUIRED]; string headers_attach = 2 [(google.api.field_behavior) = OPTIONAL]; string http_path = 3 [(google.api.field_behavior) = REQUIRED]; repeated string http_methods = 4 [(google.api.field_behavior) = REQUIRED]; repeated Param params = 5; } message Param { string param_source = 1 [(google.api.field_behavior) = REQUIRED]; string param_key = 2 [(google.api.field_behavior) = REQUIRED]; string param_type = 3 [(google.api.field_behavior) = REQUIRED]; } message GrpcService { oneof destination { string proto_descriptor_str = 1; string proto_descriptor_file_path = 2; } repeated string services = 3 [(google.api.field_behavior) = REQUIRED]; }  ","version":"Next","tagName":"h3"},{"title":"2、代码生成​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#2代码生成","content":"这里依赖kubernetes code generators生成相关kubetype、client、informer、lister等代码。 在higress根目录执行以下命令， GENERATE_API=1 make gen-client 执行上述命令后会生成，如下代码 ","version":"Next","tagName":"h2"},{"title":"kubernetes customresuource定义​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#kubernetes-customresuource定义","content":"通过将这个定义注册给kubernetes集群，然后就能创建对应的CRD资源实例。 ","version":"Next","tagName":"h3"},{"title":"CRD对应资源对象Go语言的定义及操作方法​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#crd对应资源对象go语言的定义及操作方法","content":"Hingress(IngressConfig)初始化及运行阶段会使用这里的api模型。 ","version":"Next","tagName":"h3"},{"title":"kubernetes client apis​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#kubernetes-client-apis","content":"Hingress集成kubernetes client与kube-apiserver交互时会使用这里的模型对象。 ","version":"Next","tagName":"h3"},{"title":"kubernetes client apis operate​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#kubernetes-client-apis-operate","content":" ","version":"Next","tagName":"h3"},{"title":"kubernetes client informer​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#kubernetes-client-informer","content":" ","version":"Next","tagName":"h3"},{"title":"kubernetes client informer lister​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#kubernetes-client-informer-lister","content":" ","version":"Next","tagName":"h3"},{"title":"3、集成 Controller​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#3集成-controller","content":"这里主要是在ingress_config，添加自定义CRD Resource的引用对象，并且通过informer机制监听CRD实例的变化，然后实现相关业务逻辑，比如生成istio EnvoyFilter等 higress/pkg/ingress/config/ingress_config.go ","version":"Next","tagName":"h2"},{"title":"定义相关属性​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#定义相关属性","content":"//异步线程启动后，可以监听CRD-http2rpc资源变化事件 http2rpcController http2rpc.Http2RpcController //资源变化事件处理时通过Lister获取发送变化的CRD实例对象 http2rpcLister netlisterv1.Http2RpcLister //存储全量的http2rpcs资源对象，以便在其他事件流程中消费 http2rpcs map[string]*higressv1.Http2Rpc   ","version":"Next","tagName":"h3"},{"title":"在higress启动阶段初始化上述变量​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#在higress启动阶段初始化上述变量","content":"这里就会引用自动化生成的一些代码，进行Controller的创建及事件绑定。 ","version":"Next","tagName":"h3"},{"title":"实现CRD变更事件处理逻辑​","type":1,"pageTitle":"Higress自定义CRD开发指引","url":"/zh-cn/docs/dev/CustomResourceDefinition#实现crd变更事件处理逻辑","content":" 扩展阅读 Kubernetes Controller 机制详解（一） Kubernetes Informer机制 ","version":"Next","tagName":"h3"},{"title":"给问题打标签","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/committer-guide/label-an-issue-guide_dev","content":"给问题打标签 如果您正在处理一个问题，请记得给这个问题标记一个或者多个您认为有意义的标签。有了标签，其他开发人员就会很轻松地识别出问题，以便对其进行分类并跟踪进度。 对于需要编码和发版修复的issues和pull requests，需要您将其标记为milestone。 一些常用的标签： 请求帮助 help wantedgood first issue 优先级 priority/blockerpriority/highpriority/lowpriority/normal 状态 status/need-triagestatus/DO-NOT-MERGEstatus/READY-TO-MERGEstatus/invalidstatus/wontfix 类型 type/bugtype/documentationtype/enhancementtype/feature","keywords":"Higress","version":"Next"},{"title":"版本发布向导","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/committer-guide/release-guide_dev","content":"版本发布向导 TBD","keywords":"Higress","version":"Next"},{"title":"报告安全问题","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/contributor-guide/reporting-security-issues_dev","content":"","keywords":"Higress","version":"Next"},{"title":"报告漏洞​","type":1,"pageTitle":"报告安全问题","url":"/zh-cn/docs/developers/contributor-guide/reporting-security-issues_dev#报告漏洞","content":"如果您对Higress的安全性有担心，或者发现漏洞或潜在威胁，请发送电子邮件至higress@googlegroups.com与Higress安全团队联系。在邮件中，指定问题或潜在威胁的描述。还敦促您推荐重现和复制问题的方法。Higress社区会在评估和分析调查结果之后与您联系。 请先注意在安全电子邮件中报告安全问题，然后再在公共领域公开该问题。 ","version":"Next","tagName":"h2"},{"title":"漏洞处理​","type":1,"pageTitle":"报告安全问题","url":"/zh-cn/docs/developers/contributor-guide/reporting-security-issues_dev#漏洞处理","content":"漏洞处理过程的概述是： 报告者将漏洞秘密报告给Higress。相应项目的安全团队与报告者私下合作来解决漏洞。制作了包含该修复程序的有关Higress产品的新版本。该漏洞已公开宣布。 ","version":"Next","tagName":"h2"},{"title":"网站向导","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/committer-guide/website-guide_dev","content":"网站向导 Higress 的网站仓库是 https://github.com/higress-group/higress-group.github.io网站构建完毕后，它会被自动发布到 higress.io","keywords":"Higress","version":"Next"},{"title":"新贡献者向导","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/contributor-guide/new-contributor-guide_dev","content":"","keywords":"Higress","version":"Next"},{"title":"邮件列表描述​","type":1,"pageTitle":"新贡献者向导","url":"/zh-cn/docs/developers/contributor-guide/new-contributor-guide_dev#邮件列表描述","content":"TBD ","version":"Next","tagName":"h3"},{"title":"报告问题​","type":1,"pageTitle":"新贡献者向导","url":"/zh-cn/docs/developers/contributor-guide/new-contributor-guide_dev#报告问题","content":"您始终可以通过Github Issues 向Higress报告问题。 如果您正在报告bug，请参阅问题报告模版。 如果您正在报告功能要求，请参阅问题报告模版。 如果您正在报告常规问题，比如提出一个问题，则可以打开常规问题 ","version":"Next","tagName":"h3"},{"title":"发送 pull request​","type":1,"pageTitle":"新贡献者向导","url":"/zh-cn/docs/developers/contributor-guide/new-contributor-guide_dev#发送-pull-request","content":"参考pull request template在您发送pull request之前，请同步您的github仓库和远程仓库，这会使您的pull request简单明了，具体操作请看如下所示步骤： git remote add upstream git@github.com:alibaba/higress.git git fetch upstream git rebase upstream/main git checkout -b your_awesome_patch ... add some work git push origin your_awesome_patch  ","version":"Next","tagName":"h3"},{"title":"编码规范​","type":1,"pageTitle":"新贡献者向导","url":"/zh-cn/docs/developers/contributor-guide/new-contributor-guide_dev#编码规范","content":"请按照CONTRIBUTING.md中的编码规范对自己的代码进行检查。 ","version":"Next","tagName":"h3"},{"title":"测试覆盖率向导","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev","content":"","keywords":"Higress","version":"Next"},{"title":"测试粒度如何划分​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#测试粒度如何划分","content":" 测试粒度如何划分是个大问题。Chris Richardson 在&quot; [降低测试金字塔：微服务的有效测试策略](https://microservices.io/microservices/testing/2019/09/20/oracle-code-one-testing.html)&quot; 一文中将服务测试划分为：单元测试、集成测试、组件测试、端到端的测试。我们可以在设计测试用例的过程中,拿来借鉴。 ","version":"Next","tagName":"h2"},{"title":"单元测试​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#单元测试","content":"","version":"Next","tagName":"h2"},{"title":"1.写单元测试的收益​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#1写单元测试的收益","content":"单元测试能帮助每个人深入代码细节，了解代码的功能。通过测试用例我们能发现bug，并提交代码的健壮性。测试用例同时也是代码的demo用法。 ","version":"Next","tagName":"h3"},{"title":"2.单元测试用例的一些设计原则​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#2单元测试用例的一些设计原则","content":"应该精心设计好步骤，颗粒度和组合条件。注意边界条件。单元测试也应该好好设计，不要写无用的代码。当你发现一个方法很难写单元测试时，如果可以确认这个方法是臭代码，那么就和开发者一起重构它。Higress中用的mock框架是: mockito. 下面是一些开发向导:mockito tutorial,mockito refcardTDD（可选）：当你开始写一个新的功能时，你可以试着先写测试用例。  ","version":"Next","tagName":"h3"},{"title":"3.测试覆盖率设定值​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#3测试覆盖率设定值","content":"在现阶段，Delta更改代码的测试覆盖设定值为：&gt;＝80%，越高越好。我们可以在这个页面中看到测试报告: https://codecov.io/gh/alibaba/higress ","version":"Next","tagName":"h3"},{"title":"4.项目约定​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#4项目约定","content":"Higress 项目的单元测试用例分布在项目每个子模块中，测试断言类以Test结尾。 ","version":"Next","tagName":"h3"},{"title":"集成测试​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#集成测试","content":"","version":"Next","tagName":"h2"},{"title":"项目约定​","type":1,"pageTitle":"测试覆盖率向导","url":"/zh-cn/docs/developers/contributor-guide/test-coverage-guide_dev#项目约定","content":"集成测试在本项目泛指单元测试以上级别的测试。项目使用github actions、jiblib maven 插件、fabric maven 插件、testContainers等用来构建Docker镜像，搭建集成测试环境 区别于单元测试，某个测试用例，需要依赖第三方中间件的，可以不用Mock, 使用上面介绍的工具搭建docker环境,进行测试。但是也要注意搭建组件的粒度。过于复杂的环境，可以：核心测试依赖的中间件可以docker搭建，非强依赖的可以MockHigress 项目的集成测试用例分布统一放在integration-test子模块中，测试断言类以IT结尾。这里还用 Junit5。 测试用例并行跑的过程中，注意公共中间件的隔离状态，规划好所造数据，防止冲突。 ","version":"Next","tagName":"h3"},{"title":"基于 Docker Compose 进行独立部署","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/deploy-by-docker-compose","content":"","keywords":"deploy docker compose docker ops","version":"Next"},{"title":"开发人员","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/developers_dev","content":"","keywords":"Higress 维护者","version":"Next"},{"title":"开发人员​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#开发人员","content":"本页面展示了Higress的开发团队。请通过提交PR的方式把自己的信息添加到列表上。 注：排名按 github id 首字母 ","version":"Next","tagName":"h2"},{"title":"Higress Maintainers​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#higress-maintainers","content":"姓名\tgithub\t公司董艺荃\tCH3CHO\tTrip.com 耿蕾蕾\tgengleilei\tAlibaba 张添翼\tjohnlanni\tAlibaba 范扬\tSpecialYang\tAlibaba 季敏\tslievrly\tAlibaba ","version":"Next","tagName":"h2"},{"title":"Higress Approvers​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#higress-approvers","content":"姓名\tgithub\t公司吴新军\t2456868764 刘训灼\tXunzhuo\tTencent ","version":"Next","tagName":"h2"},{"title":"Higress Reviewers​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#higress-reviewers","content":"姓名\tgithub\t公司凌轶群\tLynskylate\teBay 刘晓瑞\trinfx\tAlibaba 赵炳堃\tsjtuzbk\tAlibaba 韦鑫\tWeixinX\tNUAA ","version":"Next","tagName":"h2"},{"title":"Higress Members​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#higress-members","content":"姓名\tgithub\t组织张正好\talexzzh\tkoal safety 李强林\tCharlie17Li\tZJU 封宇腾\tFfyyt\tXUPT 韩贤涛\thanxiantao\tFinv 田亚涛\tHinsteny\tAnt 屈晗煜\tInk-33\tDGUT 程治玮\tSe7en\tSAP 邵佳成\tsjcsjc123\tHDU 宋鹏远\tsongpengyuan\tOkki.com 彭万山\tUncle-Justice\tHUST 赵伟基\tvikizhao156\tSJTU ","version":"Next","tagName":"h2"},{"title":"获取Higress开发者头衔​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#获取higress开发者头衔","content":"头衔本身是一种荣誉象征，每一位参与Higress的贡献者在开源社区的地位都是平等的 每种的头衔的获取方式如下： ","version":"Next","tagName":"h2"},{"title":"Member​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#member","content":"条件： 获得 8 个完成 issue 的积分（good-issue +0.5, easy +1，normal +2，challenge +4） Higress开源社区为每个可认领（help wanted标签）的issue都标记了难度标签：简单(level/easy)，普通(level/normal)，有挑战(level/challenge)，完成issue后可以获得对应积分 创建有价值的 issue（被标记为 good-issue 标签），也可以得 0.5 分 贡献代码（包含文档）DIFF 行数（包含增删）达到 500+ 不仅只有贡献代码，在Higress官网仓库(https://github.com/higress-group/higress-group.github.io)贡献文档，也可以满足此要求 在社区周会进行 1 次主题分享 重点不是分享的内容，是通过分享让大家认识你 申请方式： 满足条件，本人直接编辑本文档，提 PR 申请 ","version":"Next","tagName":"h3"},{"title":"Reviewer​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#reviewer","content":"条件： 满足 Member 条件在 SIG 的核心 issue 中做出贡献 申请方式： 由 Approvers/Maintainer 提名，编辑本文档，提 PR 申请 ","version":"Next","tagName":"h3"},{"title":"Approver​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#approver","content":"条件： 满足 Reviewer 条件主导一个 SIG Proposal 草案，组织并推进核心 issue 的 tasklist 完成 申请方式： 由 Maintainer 提名，编辑本文档，提 PR 申请 ","version":"Next","tagName":"h3"},{"title":"Maintainer​","type":1,"pageTitle":"开发人员","url":"/zh-cn/docs/developers/developers_dev#maintainer","content":"Maintainer是对Higress项目（包括Higress下的项目）的演进和发展做出显著贡献的个人。在社区中具有有目共睹的影响力，能够代表Higress参加重要的社区会议和活动。 条件： 满足 Approver 条件主导多个 SIG Proposal 草案，组织并推进核心 issue 的 tasklist 完成积极参与开源社区的日常工作：引导新人开发，用户问题解答等 申请方式： 由 2 名以上Maintainer 提名，编辑本文档，提 PR 申请 ","version":"Next","tagName":"h3"},{"title":"为Higress贡献","type":0,"sectionRef":"#","url":"/zh-cn/docs/developers/guide_dev","content":"","keywords":"Higress","version":"Next"},{"title":"话题​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#话题","content":"为Higress贡献 话题贡献插件报告安全问题报告一般问题代码和文档贡献 工作准备分支定义提交规则 提交讯息提交内容 PR 说明 测试用例贡献致力于帮助任何事情 ","version":"Next","tagName":"h2"},{"title":"贡献插件​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#贡献插件","content":"Higress 基于 WASM 等方式具备了很好的可扩展性，具体贡献方式请参考此处说明 对于使用 GO 语言开发 WASM 插件，可以参考这篇文档 ","version":"Next","tagName":"h2"},{"title":"报告安全问题​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#报告安全问题","content":"安全问题应该始终得到认真对待。按照我们通常的原则，我们不鼓励任何人散布安全问题。如果您发现Higress的安全问题，请不要公开讨论，甚至不要公开问题。相反，我们建议您向我们发送一封私人电子邮件至higress@googlegroups.com进行举报。 ","version":"Next","tagName":"h2"},{"title":"报告一般问题​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#报告一般问题","content":"坦白地说，我们认为Higress的每位用户都是非常友好的贡献者。体验Higress之后，您可能会对项目有一些反馈。然后随时通过NEW ISSUE打开问题。 因为我们在一个分布式的方式合作项目Higress，我们对此表示赞赏编写良好，详细，明确的问题报告。为了提高沟通效率，我们希望每个人都可以搜索您的问题是否在搜索列表中。如果发现它存在，请在现有问题下的评论中添加您的详细信息，而不要打开一个全新的issue。 为了使问题详细信息尽可能地标准，我们为问题报告者设置了“ 问题模板 ”。请务必按照说明填写模板中的字段。 在很多情况下，您可以打开一个问题： 错误报告功能要求性能问题功能提案功能设计需要帮助doc不完整测试改进有关项目的任何问题等等 另外，我们必须提醒您，在填写新issue时，请记住从您的帖子中删除敏感数据。敏感数据可以是密码，密钥，网络位置，私人业务数据等。 ","version":"Next","tagName":"h2"},{"title":"代码和文档贡献​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#代码和文档贡献","content":"鼓励采取一切措施使Higress项目变得更好。在GitHub上，Higress的每个改进都可以通过PR（拉取请求的缩写）来实现。 如果发现错字，请尝试解决！如果发现错误，请尝试修复它！如果发现一些冗余代码，请尝试将其删除！如果发现缺少一些测试用例，请尝试添加它们！如果您可以增强功能，请不要犹豫！如果发现隐式代码，请尝试添加注释以使其清晰！如果您发现代码丑陋，请尝试重构它！如果可以帮助改善文档，那就再好不过了！如果发现文档不正确，请直接解决该问题！... 实际上，不可能完全列出它们。只要记住一个原则： 我们期待您的任何回复。 由于您已准备好通过PR改善Higress，因此建议您在此处查看PR规则。 工作准备分支定义提交规则PR说明 ","version":"Next","tagName":"h2"},{"title":"工作准备​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#工作准备","content":"要提出PR，我们假设您已经注册了GitHub ID。然后，您可以按照以下步骤完成准备工作： FORK Higress分支到您的存储库。要使此工作有效，您只需要单击Higress / Higress主页右边的按钮Fork 。然后，您将在https://github.com/&lt;your-username&gt;/Higress中your-username找到您的存储库，这是您的GitHub用户名。 CLONE您自己的存储库以在本地进行开发。用于git clone git@github.com:&lt;your-username&gt;/Higress.git将存储库克隆到本地计算机。然后，您可以创建新分支来完成您希望进行的更改。 Set Remote上游设置为git@github.com:alibaba/higress.git使用以下两个命令： git remote add upstream git@github.com:alibaba/higress.git git remote set-url --push upstream no-pushing  使用此远程设置，您可以像这样检查git远程配置： $ git remote -v origin git@github.com:&lt;your-username&gt;/Higress.git (fetch) origin git@github.com:&lt;your-username&gt;/Higress.git (push) upstream git@github.com:alibaba/higress.git (fetch) upstream no-pushing (push)  加上这一点，我们可以很容易地将本地分支与上游分支同步。 ","version":"Next","tagName":"h3"},{"title":"分支定义​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#分支定义","content":"现在，我们假设通过拉取请求所做的所有贡献都是针对Higress中的主分支。在做出贡献之前，了解分支定义会有所帮助。 作为贡献者，请再次记住，通过拉取请求进行的每个贡献都是为了分支发展。在Higress项目中，还有其他几个分支，我们通常称它们为发布分支（例如0.6.0、0.6.1）\\功能分支，修补程序分支和主分支。 正式发布版本时，将有一个发布分支，并以版本号命名。 发布之后，我们将发布分支的提交合并到master分支中。 当发现某个版本中存在错误时，我们将决定在更高版本中进行修复或在特定修补程序版本中进行修复。当我们决定修复此修补程序版本时，我们将根据相应的发行分支检出该修补程序分支，执行代码修复和验证，然后将其合并到开发分支和master分支中。 对于更大的功能，我们将拉出功能分支以进行开发和验证。 ","version":"Next","tagName":"h3"},{"title":"提交规则​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#提交规则","content":"实际上，在Higress中，我们在提交时要认真对待两个规则： 提交讯息提交内容 提交讯息​ 提交消息可以帮助审稿人更好地了解提交的PR的目的。它也可以帮助加快代码审查过程。我们鼓励贡献者清楚明白提交消息而不是模棱两可的消息。通常，我们提倡以下提交消息类型： docs：xxxx。例如，“ docs：添加有关Higress群集安装的文档”。feature：xxxx。例如，“新功能：在AT模式下支持oracle”。bugfix：xxxx。例如，“错误修正：修正了输入nil参数时的错误”。refactor：xxxx。例如，“重构：简化以使代码更具可读性”。test：xxx。例如，“测试：为func InsertIntoArray添加单元测试用例”。其他可读和显式的表达方式。 另一方面，我们不鼓励捐助者像以下方式提交消息： 修正错误更新添加文档 如果您迷路了，请参阅《如何编写Git提交消息》作为开始。 提交内容​ 提交内容表示一次提交中包含的所有内容更改。我们最好将内容包含在一个提交中，这样可以在没有任何其他提交帮助的情况下支持审阅者的完整审阅。换句话说，一次提交中的内容可以传递CI以避免代码混乱。简而言之，我们要记住三个小规则： 避免在提交中进行很大的更改；每次提交均完整且可审查。提交时检查git config（user.name，user.email）以确保它与您的GitHub ID相关联。 另外，在代码更改部分，我们建议所有贡献者都应阅读Higress的代码样式。 无论提交消息还是提交内容，我们都更加注重代码审查。 ","version":"Next","tagName":"h3"},{"title":"PR 说明​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#pr-说明","content":"PR是更改Higress项目文件的唯一方法。为了帮助审稿人更好地实现目标，PR 说明不能太详细。我们鼓励贡献者遵循PR模板完成请求请求。 ","version":"Next","tagName":"h3"},{"title":"测试用例贡献​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#测试用例贡献","content":"任何测试用例都将受到欢迎。当前，Higress功能测试用例是高度优先的。 ","version":"Next","tagName":"h2"},{"title":"致力于帮助任何事情​","type":1,"pageTitle":"为Higress贡献","url":"/zh-cn/docs/developers/guide_dev#致力于帮助任何事情","content":"我们选择GitHub作为Higress合作的主要场所。因此，Higress的最新更新始终在这里。尽管通过PR捐款是一种明确的帮助方式，但我们仍然呼吁其他方式。 如果可以的话，回复他人的问题；帮助解决其他用户的问题；帮助审查他人的PR设计；帮助审查PR中其他人的代码；讨论有关Higress的问题，以使事情更加清晰；在GitHub之外倡导Higress技术;在Higress上写博客，等等。 ","version":"Next","tagName":"h2"},{"title":"安装 Higress​","type":1,"pageTitle":"基于 Docker Compose 进行独立部署","url":"/zh-cn/docs/ops/deploy-by-docker-compose#安装-higress","content":"基于 Docker Compose 部署时，Higress 网关由如下几个服务组成： apiserver：基础设施服务。负责模拟 K8s 的 API Server；controller：控制面服务一号。负责配置收集整合所有的配置数据和服务列表；pilot：控制面服务一号。负责下发网关路由数据；gateway：数据面服务。负责承载实际的网关请求；console：Higress 网关控制台 ","version":"Next","tagName":"h2"},{"title":"安装命令​","type":1,"pageTitle":"基于 Docker Compose 进行独立部署","url":"/zh-cn/docs/ops/deploy-by-docker-compose#安装命令","content":"curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- [DESTINATION] [OPTIONS...]  ","version":"Next","tagName":"h3"},{"title":"安装参数​","type":1,"pageTitle":"基于 Docker Compose 进行独立部署","url":"/zh-cn/docs/ops/deploy-by-docker-compose#安装参数","content":"参数名\t参数说明\t默认值DESTINATION\t目标安装目录\t./higress -a --auto-run\t配置完成后自动启动 Higress 网关\t无 -c CONFIG_URL --config-url CONFIG_URL\t配置服务的 URL。 - 若使用独立部署的 Nacos 服务（版本不低于 2.0.0），URL 格式为：nacos://192.168.0.1:8848 - 若在本地磁盘上保存配置，URL 格式为：file://opt/higress/conf\t无 --use-builtin-nacos\t使用内置的 Nacos 服务。不建议用于生产环境。如果设置本参数，则无需设置-c参数\t无 --nacos-ns=NACOS_NAMESPACE\t用于保存 Higress 配置的 Nacos 命名空间 ID\thigress-system --nacos-username=NACOS_USERNAME\t用于访问 Nacos 的用户名。仅用于 Nacos 启动了认证的情况下\t无 --nacos-password=NACOS_PASSWORD\t用于访问 Nacos 的用户密码。仅用于 Nacos 启动了认证的情况下\t无 -k KEY --data-enc-key=KEY\t用于加密敏感配置数据的密钥。长度必须为 32 个字符。若未设置，Higress 将自动生成一个随机的密钥。若需集群部署，此项必须设置\t随机字符串 --nacos-port=NACOS_PORT\t内置 NACOS 服务在服务器本地监听的端口\t8848 --gateway-http-port=GATEWAY_HTTP_PORT\tHigress Gateway 在服务器本地监听的 HTTP 端口\t80 --gateway-https-port=GATEWAY_HTTPS_PORT\tHigress Gateway 在服务器本地监听的 HTTPS 端口\t443 --gateway-metrics-port=GATEWAY_METRIC_PORT\tHigress Gateway 在服务器本地监听的用于暴露运行指标端口\t15020 --console-port=CONSOLE_PORT\tHigress Console 在服务器本地监听的端口\t8080 -r --rerun\t在 Higress 已配置完成后重新执行配置流程\t无 -h --help\t显示帮助信息\t无 ","version":"Next","tagName":"h3"},{"title":"使用 Helm 进行云原生部署","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/deploy-by-helm","content":"","keywords":"deploy helm kubernetes k8s ops","version":"Next"},{"title":"安装 Higress​","type":1,"pageTitle":"使用 Helm 进行云原生部署","url":"/zh-cn/docs/ops/deploy-by-helm#安装-higress","content":"Higress 网关由控制面组件 higress-controller 和数据面组件 higress-gateway 组成。higress-gateway负责承载数据流量，higress-controller 负责管理配置下发。 ","version":"Next","tagName":"h2"},{"title":"Helm 安装命令​","type":1,"pageTitle":"使用 Helm 进行云原生部署","url":"/zh-cn/docs/ops/deploy-by-helm#helm-安装命令","content":"helm repo add higress.io https://higress.io/helm-charts helm install higress higress.io/higress -n higress-system --create-namespace  ","version":"Next","tagName":"h3"},{"title":"常用安装参数​","type":1,"pageTitle":"使用 Helm 进行云原生部署","url":"/zh-cn/docs/ops/deploy-by-helm#常用安装参数","content":"完整参数介绍请查看运维参数说明 参数名\t参数说明\t默认值全局参数 global.local\t如果要安装至本地 K8s 集群（如 Kind、Rancher Desktop 等），请设置为 true\tfalse global.ingressClass\t用于过滤被 Higress Controller 监听的 Ingress 资源的 IngressClass。 在集群内部署了多个网关时，可以使用这一参数来区分每个网关的职责范围。 IngressClass 有一些特殊的取值： 1. 如果设置为“nginx”，Higress Controller 将监听 Ingress 为 nginx 或为空的 Ingress 资源。 2. 如果设为空，Higress Controller 将监听 K8s 集群内的全部 Ingress 资源。\thigress global.watchNamespace\t如果值不为空，Higress Controller 将只会监听指定命名空间下的资源。 当基于 K8s 命名空间进行业务系统隔离时，若需要对每个命名空间部署一套独立的网关，可以通过这一参数来限制 Higress 监听指定命名空间内的 Ingress。\t&quot;&quot; global.disableAlpnH2\t是否在 ALPN 中禁用 HTTP/2 协议\ttrue global.enableStatus\t若为true， Higress Controller 将会更新 Ingress 资源的 status 字段。 为避免从 Nginx Ingress 迁移过程中，覆盖 Ingress 对象的 status 字段，可以将这一参数设置为false，这样 Higress 默认就不会将入口 IP 写入 Ingress 的 status 字段。\ttrue global.enableIstioAPI\t若为true，Higress Controller 将同时监听 istio 资源\tfalse global.enableGatewayAPI\t若为true，Higress Controller 将同时监听 Gateway API 资源\tfalse global.onlyPushRouteCluster\t若为true，Higress Controller 将会只推送被路由关联的服务\ttrue global.o11y.enabled\t若为 true，将同时安装可观测性套件（Grafana、Promethues、Loki、PromTail）\tfalse global.pvc.rwxSupported\t标识目标 K8s 集群是否支持 PersistentVolumeClaim 的 ReadWriteMany 操作方式。\ttrue 核心组件参数 higress-core.gateway.replicas\tHigress Gateway 的 pod 数量\t2 higress-core.controller.replicas\tHigress Controller 的 pod 数量\t1 控制台参数 higress-console.replicaCount\tHigress Console 的 pod 数量\t1 higress-console.service.type\tHigress Console 所使用的 K8s Service 类型\tClusterIP higress-console.web.login.prompt\t登录页面上显示的提示信息\t&quot;&quot; ","version":"Next","tagName":"h3"},{"title":"支持 Istio CRD（可选）​","type":1,"pageTitle":"使用 Helm 进行云原生部署","url":"/zh-cn/docs/ops/deploy-by-helm#支持-istio-crd可选","content":"集群里需要提前安装好 Istio 的 CRD，如果不希望安装 Istio，也可以只安装 Istio 的 CRD： helm repo add istio https://istio-release.storage.googleapis.com/charts helm install istio-base istio/base -n istio-system --create-namespace  这种模式下，需要更新 Higress 的部署参数： helm upgrade higress -n higress-system --set global.enableIstioAPI=true higress.io/higress --reuse-values  ","version":"Next","tagName":"h2"},{"title":"支持 Gateway API CRD（可选）​","type":1,"pageTitle":"使用 Helm 进行云原生部署","url":"/zh-cn/docs/ops/deploy-by-helm#支持-gateway-api-crd可选","content":"集群里需要提前安装好 Gateway API 的 CRD：https://github.com/kubernetes-sigs/gateway-api/releases 以1.0.0为例： kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/experimental-install.yaml  这种模式下，需要更新 Higress 的部署参数： helm upgrade higress -n higress-system --set global.enableGatewayAPI=true higress.io/higress --reuse-values  ","version":"Next","tagName":"h2"},{"title":"路由指向 gRPC 服务","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/how-tos/grpc-upstream","content":"路由指向 gRPC 服务 TBD","keywords":"ops config route upstream grpc","version":"Next"},{"title":"修改 Gateway 监听端口","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/how-tos/gateway-ports","content":"修改 Gateway 监听端口 TBD","keywords":"ops config route tcp","version":"Next"},{"title":"配置路由指向 HTTPS 服务","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/how-tos/https-upstream","content":"配置路由指向 HTTPS 服务 TBD","keywords":"ops config route upstream https","version":"Next"},{"title":"版本升级","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/upgrade","content":"","keywords":"Upgrade","version":"Next"},{"title":"云原生部署​","type":1,"pageTitle":"版本升级","url":"/zh-cn/docs/ops/upgrade#云原生部署","content":"","version":"Next","tagName":"h2"},{"title":"基于 Helm 实现版本升级​","type":1,"pageTitle":"版本升级","url":"/zh-cn/docs/ops/upgrade#基于-helm-实现版本升级","content":"# ${higress_version} 的值示例: v1.1.0 kubectl apply -f https://raw.githubusercontent.com/alibaba/higress/${higress_version}/helm/core/crds/customresourcedefinitions.gen.yaml helm repo update helm upgrade higress -n higress-system higress.io/higress  ","version":"Next","tagName":"h3"},{"title":"独立部署​","type":1,"pageTitle":"版本升级","url":"/zh-cn/docs/ops/upgrade#独立部署","content":"# ${higress_dir} 为 Higress 独立部署的安装目录 curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- &quot;${higress_dir}&quot; -u  ","version":"Next","tagName":"h2"},{"title":"日志说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/log","content":"日志说明 查看日志可以使用下面命令: kubectl logs -n higress-system -l app=higress-gateway --since=5m Higress 默认使用的日志格式为 JSON 格式，如下所示: { &quot;authority&quot;: &quot;%REQ(:AUTHORITY)%&quot;, &quot;bytes_received&quot;: &quot;%BYTES_RECEIVED%&quot;, &quot;bytes_sent&quot;: &quot;%BYTES_SENT%&quot;, &quot;downstream_local_address&quot;: &quot;%DOWNSTREAM_LOCAL_ADDRESS%&quot;, &quot;downstream_remote_address&quot;: &quot;%DOWNSTREAM_REMOTE_ADDRESS%&quot;, &quot;duration&quot;: &quot;%DURATION%&quot;, &quot;method&quot;: &quot;%REQ(:METHOD)%&quot;, &quot;path&quot;: &quot;%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%&quot;, &quot;protocol&quot;: &quot;%PROTOCOL%&quot;, &quot;request_id&quot;: &quot;%REQ(X-REQUEST-ID)%&quot;, &quot;requested_server_name&quot;: &quot;%REQUESTED_SERVER_NAME%&quot;, &quot;response_code&quot;: &quot;%RESPONSE_CODE%&quot;, &quot;response_flags&quot;: &quot;%RESPONSE_FLAGS%&quot;, &quot;route_name&quot;: &quot;%ROUTE_NAME%&quot;, &quot;start_time&quot;: &quot;%START_TIME%&quot;, &quot;trace_id&quot;: &quot;%REQ(X-B3-TRACEID)%&quot;, &quot;upstream_cluster&quot;: &quot;%UPSTREAM_CLUSTER%&quot;, &quot;upstream_host&quot;: &quot;%UPSTREAM_HOST%&quot;, &quot;upstream_local_address&quot;: &quot;%UPSTREAM_LOCAL_ADDRESS%&quot;, &quot;upstream_service_time&quot;: &quot;%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%&quot;, &quot;upstream_transport_failure_reason&quot;: &quot;%UPSTREAM_TRANSPORT_FAILURE_REASON%&quot;, &quot;user_agent&quot;: &quot;%REQ(USER-AGENT)%&quot;, &quot;x_forwarded_for&quot;: &quot;%REQ(X-FORWARDED-FOR)%&quot; } Value 的配置含义可以参考 envoy 日志说明 字段名\t类型\t含义authority\tstring\t请求报文中的Host Header。 bytes_received\tlong\t请求的Body大小（不包含Header）。 bytes_sent\tlong\t响应的Body大小（不包含Header）。 downstream_local_address\tstring\t网关Pod地址。 downstream_remote_address\tstring\t连接到网关的Client端地址。 duration\tlong\t请求整体耗时。 method\tstring\tHTTP方法。 path\tstring\tHTTP请求中的Path。 protocol\tstring\tHTTP的协议版本。 request_id\tstring\t网关会为每次请求产生一个ID，并放在Header的x-request-id中，后端可以根据这个字段记录并进行排查。 requested_server_name\tstring\tSSL连接时使用的Server Name。 response_code\tlong\tHTTP响应的状态码。 response_flags\tstring\t响应失败的原因。 route_name\tstring\t路由名。 start_time\tstring\t请求开始时间。 trace_id\tstring\tTrace ID。 upstream_cluster\tstring\t上游集群。 upstream_host\tstring\t上游IP。 upstream_local_address\tstring\t本地连接上游的地址。 upstream_service_time\tlong\t最后一次调用上游服务的时间。 upstream_transport_failure_reason\tstring\t上游链接失败的原因。 user_agent\tstring\tHTTP Header中的UserAgent。 x_forwarded_for\tstring\tHTTP Header中的x-forwarded-for，通常用来表示HTTP请求端真实IP。","keywords":"higress log","version":"Next"},{"title":"配置 TCP 四层路由","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/how-tos/tcp-route","content":"","keywords":"ops config route tcp","version":"Next"},{"title":"前置准备​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#前置准备","content":"Higress 安装在 K8s 内的 higress-system 命名空间下，网关的 Service 名称为 higress-gateway；目标是为 default 命名空间下的 tcp-echo 服务配置一个四层路由，服务监听的端口为 9000，网关监听的端口也为 9000；路由使用 Gateway API CRD 进行配置，需要提前配置 Higress 使其支持监听 Gateway API。参考文档：文档 ","version":"Next","tagName":"h2"},{"title":"配置步骤​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#配置步骤","content":"","version":"Next","tagName":"h2"},{"title":"1. 创建 GatewayClass​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#1-创建-gatewayclass","content":"创建 gatewayclass.yaml 文件，并写入以下内容： apiVersion: gateway.networking.k8s.io/v1 kind: GatewayClass metadata: name: higress-gateway spec: controllerName: &quot;higress.io/gateway-controller&quot; 执行命令，将以上配置写入 K8s 集群： kubectl apply -f gatewayclass.yaml  ","version":"Next","tagName":"h3"},{"title":"2. 创建 Gateway​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#2-创建-gateway","content":"创建 gateway.yaml 文件，并写入以下内容： apiVersion: gateway.networking.k8s.io/v1 kind: Gateway metadata: name: higress-gateway namespace: higress-system spec: gatewayClassName: higress-gateway listeners: - name: default-tcp protocol: TCP port: 9000 allowedRoutes: namespaces: from: All kinds: - kind: TCPRoute 执行命令，将以上配置写入 K8s 集群： kubectl apply -f gateway.yaml  ","version":"Next","tagName":"h3"},{"title":"3. 修改 higress-gateway Service​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#3-修改-higress-gateway-service","content":"执行命令，进度 higress-gateway Service 的编辑状态： kubectl edit service higress-gateway -n higress-system 在 spec.ports 列表中增加对 9000 的端口的描述信息。增加后的配置如下所示： ... ports: - name: http2 port: 80 protocol: TCP targetPort: 80 - name: https port: 443 protocol: TCP targetPort: 443 # --- 此处为增加的配置 --- - name: tcp port: 9000 protocol: TCP targetPort: 9000 # ---------------------- ... 保存编辑内容并退出编辑器。 ","version":"Next","tagName":"h3"},{"title":"4. 创建 TCPRoute​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#4-创建-tcproute","content":"创建 tcproute.yaml 文件，并写入以下内容： apiVersion: gateway.networking.k8s.io/v1alpha2 kind: TCPRoute metadata: name: tcp-echo namespace: default spec: parentRefs: - name: higress-gateway namespace: higress-system port: 9000 rules: - backendRefs: - name: tcp-echo port: 9000 执行命令，将以上配置写入 K8s 集群： kubectl apply -f tcproute.yaml  ","version":"Next","tagName":"h3"},{"title":"5. 配置验证​","type":1,"pageTitle":"配置 TCP 四层路由","url":"/zh-cn/docs/ops/how-tos/tcp-route#5-配置验证","content":"配置完成。我们可以通过 telnet higress-gateway service 的 9000 端口等方式验证路由是否能够正常工作。 ","version":"Next","tagName":"h3"},{"title":"版本计划","type":0,"sectionRef":"#","url":"/zh-cn/docs/overview/roadmap","content":"版本计划 版本号\t版本核心目标\t预计发布时间v0.6.0\tK8s 下黑屏操作(kubectl)达到GA状态；发布控制台预览版，提高安装部署的易用性\t2023-01 v0.7.0\t控制台发布正式版本，集成开箱即用的可观测\t2023-02 v1.0.0\t整体达到GA状态\t2023-05 v1.1.0\t增强控制台功能中微服务网关相关能力；支持非 K8s 下安装部署\t2023-07 v1.2.0\t支持作为 Knative 的网络层使用；支持 ARM 架构部署；支持对接 Consul\t2023-08 v1.3.0\t完整支持 GatewayAPI；支持 Operator 模式部署\t2023-11 v1.4.0\tWASM 支持 redis 调用；简化 HTTPS 证书管理\t2024-05 v2.0.0\tIstio/Envoy 内核版本升级，更丰富的 API 网关能力\t2024-07","keywords":"Higress roadmap","version":"Next"},{"title":"Higress Terminology","type":0,"sectionRef":"#","url":"/zh-cn/docs/overview/terminology","content":"","keywords":"Higress","version":"Next"},{"title":"Ingress 注解(Annotation)​","type":1,"pageTitle":"Higress Terminology","url":"/zh-cn/docs/overview/terminology#ingress-注解annotation","content":"Ingress 资源中的注解(Annotation)字段，是一个 kv 字典结构，可以通过申明式的方式来实现各种路由策略，如下所示，是使用注解实现对该 Ingress 路由开启跨域访问许可： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ingress-example annotations: higress.io/enable-cors: &quot;true&quot; spec: ingressClassName: nginx-example rules: - http: paths: - path: /test pathType: Prefix backend: service: name: test port: number: 80  Higress 支持的其他注解配置方式，请参考Ingress Annotation 配置说明 ","version":"Next","tagName":"h2"},{"title":"下游(Downstream)​","type":1,"pageTitle":"Higress Terminology","url":"/zh-cn/docs/overview/terminology#下游downstream","content":"下游指 Higress 接收到请求的来源，一般是如浏览器等客户端 ","version":"Next","tagName":"h2"},{"title":"上游(Upstream)​","type":1,"pageTitle":"Higress Terminology","url":"/zh-cn/docs/overview/terminology#上游upstream","content":"上游指 Higress 转发请求的目标后端服务 ","version":"Next","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/zh-cn/docs/overview/faq","content":"","keywords":"Higress","version":"Next"},{"title":"Q: Higress 现在适合上生产系统么？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#1","content":"A:建议升级到 v1.0.0 及以上版本 具体可以参考我们的Roadmap  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 和 Envoy Gateway 有什么区别？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#2","content":"A:Higress 是基于 Envoy 实现和扩展的，和 Envoy Gateway 一样遵循 Gateway API 标准，不同的是，还提供了： Waf 防护、认证鉴权等安全插件能力多注册中心、协议转化、限流降级等服务管理插件能力，例如，对于传统使用 Dubbo 的微服务用户希望使用原生 RPC 方式暴露对外服务，但通常提供外部访问的服务以使用 HTTP 为主，为了帮助 Dubbo 用户降低服务暴露的开发成本，Higress 提供了 HTTP 转 Dubbo 协议功能，且通过 Console 为用户提供白屏化的配置方式，某客户使用后反馈“这是业界完成度最高的 HTTP 转 Dubbo 协议”功能。支持 WASM、Lua 等自定义插件，例如 Nginx 用户，我们还会支持进程外插件，满足多语言用户诉求，尤其是 Java 用户因现阶段 Java 社区对 WebAssembly 支持尚不完善但又希望对网关进行扩展的诉求。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 和阿里巴巴的另一款开源网关 Tengine 有哪些不同？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#3","content":"A: Tengine 是基于 Nginx 实现，通过 Lua 扩展，Higress 基于 istio + Envoy，通过 WASM 扩展，在技术架构上不太一样，开发者可以根据业务场景来进行选型。Higress 已经支持 Nginx Ingress 注解平滑迁移的能力，满足部分用户期望迁移到 Higress 但又不希望重新配置网关的诉求，既可以将 Higress 作为统一接入网关使用，同时又可以享受 Ingress 的红利。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 阿里云上的 MSE 云原生网关有什么关系？是基于此孵化的开源项目吗？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#4","content":"A: MSE 云原生网关是 Higress 的商业化版本，能力上是有差异的，主要体现在性能、稳定性、易用性和安全性上，因为这些都非常依赖于云上的基础设施能力，详细资源还在整理，后续会在 MSE 的产品页和文档页进行展示，方便大家选型。当然，Higress 处于演进过程中，MSE 云原生网关上的哪些能力对外进行开源，我们会和社区一起定义，开源上我们也会规划一个插件市场。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 将流量网关、微服务网关、安全网关三合一，这种做法业内是否通用？是否是一种发展趋势？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#5","content":"A: 流量网关、微服务网关、安全网关在业界中一直都有使用，部署形态大多采用各自使用独立集群部署，在K8s 主导的容器化背景下，K8s 通过 Ingress 标准化了入口网关，传统流量网关、微服务网关、安全网关独立部署模式在 K8s 下就显得部署成本高、运维复杂，站在用户角度只需要一款功能丰富的高集成网关即可，基于此我们判断高集成网关会是未来的一种发展趋势。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 对上游进行了定制，是否存在着无法享受社区福利、还要背负生态跟进的问题？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#6","content":"A: Higress 核心代码基本采用可插拔的 Filter 扩展，功能新增也尽量遵循可扩展原则，在上游跟进上为保持自身稳定性也不会马上跟进最新版本，比如 APISIX、Kong 内核都是基于 Nginx，但他们依然发展的很好，事实也说明上游跟进不会成为项目发展障碍。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 支持 Nacos 的服务发现，是否有支持 Consul 的计划？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#7","content":"A: 预计将在 1.2.0 版本提供  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 是否有离线部署版本？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#8","content":"A: 目前还没有现成的，需要您自行构建。目前 Docker 镜像都是提供的，可以自行拉取使用。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 能脱离 K8s 环境，只基于 Docker 运行吗？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#9","content":"A: 已经支持了，可以看这里：https://higress.io/zh-cn/docs/user/quickstart#%E7%8E%AF%E5%A2%83%E4%BA%8C%E8%84%B1%E7%A6%BB-k8s-%E5%9C%A8-docker-compose-%E4%B8%AD%E4%BD%BF%E7%94%A8  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 除了运行在 K8s 上，是否支持在虚拟机和物理机上运行呢？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#10","content":"A: 同上； 也可以考虑使用 Higress 企业版，这个模式 Higress 是全托管的，无需关心 Higress 的部署和运维，可直接对接虚拟机和物理机上部署的后端服务。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 的 Dashboard 会对外开源么？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#11","content":"A: 已经开源了：https://github.com/higress-group/higress-console  ","version":"Next","tagName":"h3"},{"title":"Q: 当前开源的版本支持 Waf 功能么，有相关的最佳实践么？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#12","content":"A: 支持的，可以看这篇文档：https://higress.io/zh-cn/docs/user/waf/  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 是否支持弹性伸缩，网关是无状态的么？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#13","content":"A: Higress 基于 K8s HPA，是支持弹性伸缩的，网关无状态，是个 deployment 。  ","version":"Next","tagName":"h3"},{"title":"Q: Higress 有 roadmap 了么？​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#14","content":"A: 请参考Roadmap  ","version":"Next","tagName":"h3"},{"title":"Q: 如何加入 Higress 社区进行贡献，已经迫不及待了 ​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#15","content":"A: 我们非常欢迎大家通过各种形式参与到我们项目的建设中，包括但不限于： 架构设计模块设计代码实现Bug FixDemo 样例文档、网站和翻译 具体的参与方法可以参见我们官网的开发者指引或与 higress@googlegroups.com 联系。 实际上，我们并不拘泥于贡献的形式，开发者提出的每一个 issue，无论是 Bug Report、改进建议或者甚至是问题咨询都代表着对项目的关注和帮助。希望 Higress 项目和社区一起健康成长，成为云原生网关领域一个优秀的解决方案。  ","version":"Next","tagName":"h3"},{"title":"Q: 企业版和开源版有功能差异对比吗 ​","type":1,"pageTitle":"FAQ","url":"/zh-cn/docs/overview/faq#16","content":"A: 企业版和开源版本的功能基本一致，企业版主要是以开源版本为功能内核，提供了更多现成的解决方案，包括高可用、安全、可观测等方面，详细可以参考： MSE云原生网关和开源Higress对比 典型的企业版解决方案：同城多活  ","version":"Next","tagName":"h3"},{"title":"Higress是什么?","type":0,"sectionRef":"#","url":"/zh-cn/docs/overview/what-is-higress","content":"","keywords":"Higress","version":"Next"},{"title":"传统网关分类​","type":1,"pageTitle":"Higress是什么?","url":"/zh-cn/docs/overview/what-is-higress#传统网关分类","content":"行业中通常把网关分为两个大类：流量网关与业务网关，流量网关主要提供全局性的、与后端业务无关的策略配置，例如阿里内部的的统一接入网关Tengine就是典型的流量网关；业务网关顾名思义主要提供独立业务域级别的、与后端业务紧耦合策略配置，随着应用架构模式从单体演进到现在的分布式微服务，业务网关也有了新的叫法 - 微服务网关（图示说明如下）。在目前容器技术与K8s主导的云原生时代，下一代网关模式依然是这样吗？  ","version":"Next","tagName":"h2"},{"title":"Higress定位​","type":1,"pageTitle":"Higress是什么?","url":"/zh-cn/docs/overview/what-is-higress#higress定位","content":"在虚拟化时期的微服务架构下，业务通常采用流量网关 + 微服务网关的两层架构，流量网关负责南北向流量调度和安全防护，微服务网关负责东西向流量调度和服务治理，而在容器和 K8s 主导的云原生时代，Ingress 成为 K8s 生态的网关标准，赋予了网关新的使命，使得流量网关 + 微服务网关合二为一成为可能。 作为面向南北向的公网网关，使用Waf防护异常流量是很常规的需求，而且随着互联网环境变得越来越复杂，用户对防护的诉求是持续增强的，常规做法是将流量先接入Waf安全网关，过滤后再将流量转发给流量网关，最后到达微服务网关；Higress希望通过内置Waf模块，使得用户的请求链接只经过Higress就可以同时完成Waf防护、流量分发、微服务治理，既可以降低链路RT，也可以降低网关的运维复杂度。因此Higress实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力。  ","version":"Next","tagName":"h2"},{"title":"Higress为什么选择以Envoy + Istio为内核构建?​","type":1,"pageTitle":"Higress是什么?","url":"/zh-cn/docs/overview/what-is-higress#higress为什么选择以envoy--istio为内核构建","content":"在容器化的云原生大背景下，Kubernetes已经成为了基础设施与上层应用的标准接口，Kubernetes集群天然的内外网络隔离环境，使得外部流量进入Kubernetes集群内部需要通过入口网关，因此Kubernetes通过Ingress来规范化入口网关的定义与标准，虽然Ingress标准存在一些如路由表达能力弱等不足之处，社区已经在积极推进Gateway API标准定义来解决，但不可否认的是目前Ingress标准仍然占据主流，CNCF年度报告中也单独统计了Ingress Provider（Ingress标准的实现方统称为Ingress Provider）的使用情况。  从上述统计报告中可以看到虽然目前Nginx Ingress仍然占据K8s Ingress Provider榜首，但Envoy的增长是最快的，已经从2019年的不足20%增长为2020年的37%，且仅在Nginx Ingress之后，增长势头非常迅猛，这说明选择以Envoy为内核是符合云原生发展趋势的；而且随着Service Mesh逐步被大众认可，Istio + Envoy的体系可以同时覆盖Mesh与Ingress领域，实现以一套技术架构调度东西向、南北向全域流量的目标，这对用户来说也是非常有意义的。 ","version":"Next","tagName":"h2"},{"title":"Higress在阿里巴巴内部介绍​","type":1,"pageTitle":"Higress是什么?","url":"/zh-cn/docs/overview/what-is-higress#higress在阿里巴巴内部介绍","content":"Higress孵化自阿里巴巴内部2020年5月的&quot;本地生活战役&quot;，最初是为满足阿里巴巴集团与蚂蚁集团直接使用RPC请求互访的诉求而构建，而且借该项目也成功孵化了Dubbo 3.0的Triple协议，因此Higress也是内部第一个支持Triple协议的应用，同年Higress也成功支持了双11、双12等大促活动，后续随着业务范围的扩展，目前Higress在内部已经支持优酷、钉钉、达摩院、蚂蚁等业务，业务场景也扩展到了东西向、南北向的全域流量调度。  ","version":"Next","tagName":"h2"},{"title":"AI 缓存","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-cache","content":"","keywords":"higress ai","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 缓存","url":"/zh-cn/docs/plugins/ai/ai-cache#功能说明","content":"AI 缓存插件实现了将 LLM 响应进行抽取并缓存的功能，对于向 LLM API 高频请求相同问题的场景可以显著降低响应时延并节省成本。默认配置方式可以直接用于 openai 协议的结果缓存，同时支持流式和非流式响应的缓存。 需要数据面的proxy wasm版本大于等于0.2.100 编译时，需要带上版本的tag，例如：tinygo build -o main.wasm -scheduler=none -target=wasi -gc=custom -tags=&quot;custommalloc nottinygc_finalizer proxy_wasm_version_0_2_100&quot; ./ ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 缓存","url":"/zh-cn/docs/plugins/ai/ai-cache#配置说明","content":"名称\t数据类型\t填写要求\t默认值\t描述cacheKeyFrom.requestBody\tstring\t选填\t&quot;messages.@reverse.0.content&quot;\t从请求 Body 中基于 GJSON PATH 语法提取字符串 cacheValueFrom.responseBody\tstring\t选填\t&quot;choices.0.message.content&quot;\t从响应 Body 中基于 GJSON PATH 语法提取字符串 cacheStreamValueFrom.responseBody\tstring\t选填\t&quot;choices.0.delta.content&quot;\t从流式响应 Body 中基于 GJSON PATH 语法提取字符串 cacheKeyPrefix\tstring\t选填\t&quot;higress-ai-cache:&quot;\tRedis缓存Key的前缀 cacheTTL\tinteger\t选填\t0\t缓存的过期时间，单位是秒，默认值为0，即永不过期 redis.serviceName\tstring\t必填\t-\tredis 服务名称，带服务类型的完整 FQDN 名称，例如 my-redis.dns、redis.my-ns.svc.cluster.local redis.servicePort\tinteger\t选填\t6379\tredis 服务端口 redis.timeout\tinteger\t选填\t1000\t请求 redis 的超时时间，单位为毫秒 redis.username\tstring\t选填\t-\t登陆 redis 的用户名 redis.password\tstring\t选填\t-\t登陆 redis 的密码 returnResponseTemplate\tstring\t选填\t{&quot;id&quot;:&quot;from-cache&quot;,&quot;choices&quot;:[%s],&quot;model&quot;:&quot;gpt-4o&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;usage&quot;:{&quot;prompt_tokens&quot;:0,&quot;completion_tokens&quot;:0,&quot;total_tokens&quot;:0}}\t返回 HTTP 响应的模版，用 %s 标记需要被 cache value 替换的部分 returnStreamResponseTemplate\tstring\t选填\tdata:{&quot;id&quot;:&quot;from-cache&quot;,&quot;choices&quot;:[{&quot;index&quot;:0,&quot;delta&quot;:{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:&quot;%s&quot;},&quot;finish_reason&quot;:&quot;stop&quot;}],&quot;model&quot;:&quot;gpt-4o&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;usage&quot;:{&quot;prompt_tokens&quot;:0,&quot;completion_tokens&quot;:0,&quot;total_tokens&quot;:0}}\\n\\ndata:[DONE]\\n\\n\t返回流式 HTTP 响应的模版，用 %s 标记需要被 cache value 替换的部分 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"AI 缓存","url":"/zh-cn/docs/plugins/ai/ai-cache#配置示例","content":"redis: serviceName: my-redis.dns timeout: 2000  ","version":"Next","tagName":"h2"},{"title":"hgctl 工具使用说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/ops/hgctl","content":"","keywords":"Ingress","version":"Next"},{"title":"如何下载 hgctl​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#如何下载-hgctl","content":"通过 curl 命令下载最新版本的 hgctl 到本地  curl -Ls https://raw.githubusercontent.com/alibaba/higress/main/tools/hack/get-hgctl.sh | VERSION=latest bash  ","version":"Next","tagName":"h2"},{"title":"安装 Profile 说明​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#安装-profile-说明","content":"higress 目前支持三个内置预定义 profile 包括: local-k8s , k8s, local-docker。 local-k8s profile 安装 higress 到本地 k8s 集群比如 kind 集群，主要用于开发和测试 higress 功能。 默认安装 higress 核心组件外，还安装包括可观测组件（Grafana + Promethues）, IstioAPI, GatewayAPI组件。k8s profile 安装 higress 到 k8s 集群, 默认只安装 higress 核心组件。local-docker profile 安装 higress 到本地 docker 环境。 ","version":"Next","tagName":"h2"},{"title":"1. 查看默认 profile 列表和导出 profile​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#1-查看默认-profile-列表和导出-profile","content":"查看 profile 列表 hgctl profile list higress configuration profiles: k8s local-docker local-k8s  导出 profile local-k8s profile 到本地 local-k8s.yaml 文件 hgctl profile dump local-k8s -o ./local-k8s.yaml  ","version":"Next","tagName":"h3"},{"title":"2. 内置三个 profile 配置项说明​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#2-内置三个-profile-配置项说明","content":"profile 内容包含 global, console, gateway, controller, storage, values , charts 七大配置项。 local-k8s profile local-k8s profile 具体内容和说明如下： profile: local-k8s # profile 名称 global: install: local-k8s # 安装模式 k8s/local-k8s/local-docker ingressClass: higress # 用于过滤被 Higress Controller 监听的 Ingress 资源的 IngressClass。 enableIstioAPI: true # 若为true，Higress Controller 将同时监听 istio 资源 enableGatewayAPI: true # 若为true 激活 gateway api namespace: higress-system # higress 安装到的命名空间 console: replicas: 1 # Higress Console 的 pod 数量 o11yEnabled: true # 若为 true，将同时安装可观测性套件（Grafana + Promethues） gateway: replicas: 1 # Higress Gateway 的 pod 数量 controller: replicas: 1 # Higress Controller 的 pod 数量 # 其他自定义的 helm values values: charts: higress: url: https://higress.io/helm-charts # higress helm chart repo 地址 name: higress # higress helm chart 名称 version: latest # higress helm chart 版本 standalone: url: https://higress.io/standalone/get-higress.sh # higress standalone 安装器地址 name: standalone # higress standalone 安装器名称 version: latest # higress standalone 安装器版本  k8s profile k8s profile 和 local-k8s profile 差异主要在可观测组件（Grafana + Promethues）, IstioAPI, GatewayAPI 默认是没有激活，如果需要这些功能，需要在安装时设置这些属性 k8s profile 具体内容和说明如下： profile: k8s # profile 名称 global: install: k8s # 安装模式 k8s/local-k8s/local-docker ingressClass: higress # 用于过滤被 Higress Controller 监听的 Ingress 资源的 IngressClass。 enableIstioAPI: false # 若为true，Higress Controller 将同时监听 istio 资源 enableGatewayAPI: false # 若为true 激活 gateway api namespace: higress-system # higress 安装到的命名空间 console: replicas: 1 # Higress Console 的 pod 数量 o11yEnabled: false # 若为 true，将同时安装可观测性套件（Grafana + Promethues） gateway: replicas: 2 # Higress Gateway 的 pod 数量 controller: replicas: 1 # Higress Controller 的 pod 数量 # 其他自定义的 helm values values: charts: higress: url: https://higress.io/helm-charts # higress helm chart repo 地址 name: higress # higress helm chart 名称 version: latest # higress helm chart 版本 standalone: url: https://higress.io/standalone/get-higress.sh # higress standalone 安装器地址 name: standalone # higress standalone 安装器名称 version: latest # higress standalone 安装器版本  local-docker profile local-docker profile 具体内容和说明如下： profile: local-docker # profile 名称 global: install: local-docker # 安装模式 k8s/local-k8s/local-docker console: port: 8080 # console 监听端口 gateway: httpPort: 80 # gateway 监听 http 端口 httpsPort: 443 # gateway 监听 https 端口 metricsPort: 15020 # gateway 指标输出监听端口 controller: # 后端存储系统设置，现在支持文件系统和 nacos storage: url: file://${INSTALLPACKAGEPATH}/conf # 配置服务的 URL。若使用独立部署的 Nacos 服务（版本不低于 2.0.0），URL 格式为：nacos://192.168.0.1:8848 - 若在本地磁盘上保存配置，URL 格式为：file://opt/higress/conf ns: higress-system # 用于保存 Higress 配置的 Nacos 命名空间 ID username: # 用于访问 Nacos 的用户名。仅用于 Nacos 启动了认证的情况下 password: # 用于访问 Nacos 的用户密码。仅用于 Nacos 启动了认证的情况下 dataEncKey: # 用于加密敏感配置数据的密钥。长度必须为 32 个字符。若未设置，Higress 将自动生成一个随机的密钥。若需集群部署，此项必须设置 charts: higress: url: https://higress.io/helm-charts # higress helm chart repo 地址 name: higress # higress helm chart 名称 version: latest # higress helm chart 版本 standalone: url: https://higress.io/standalone/get-higress.sh # higress standalone 安装器地址 name: standalone # higress standalone 安装器名称 version: latest # higress standalone 安装器版本  配置服务的 URL 默认 file://${INSTALLPACKAGEPATH}/conf 是保存在本地文件系统下， 其中 ${INSTALLPACKAGEPATH} 是当前安装下 higress-standalone目录下创建 conf 目录 ","version":"Next","tagName":"h3"},{"title":"安装命令： hgctl install​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#安装命令-hgctl-install","content":"hgctl install 安装命令具体参数如下： hgctl install --help The install command generates an higress install manifest and applies it to a cluster. Usage: hgctl install [flags] Examples: # Apply a default higress installation hgctl install # Install higress on local kubernetes cluster hgctl install --set profile=local-k8s # Install higress on local docker environment with specific gateway port hgctl install --set profile=local-docker --set gateway.httpPort=80 --set gateway.httpsPort=443 # To override profile setting hgctl install --set profile=local-k8s --set global.enableIstioAPI=true --set gateway.replicas=2&quot; # To override helm setting hgctl install --set profile=local-k8s --set values.global.proxy.resources.requsts.cpu=500m&quot; Flags: --context string The name of the kubeconfig context to use. -f, --filename strings Path to file containing helm custom values -h, --help help for install --kubeconfig string Path to the kubeconfig file to use for CLI requests. -d, --manifests string Specify a path to a directory of profiles (e.g. ~/Downloads/higress/manifests). -s, --set stringArray Override an higress profile value, e.g. override profile values (--set gateway.replicas=2), or override helm values (--set values.global.proxy.resources.requsts.cpu=500m).  安装参数说明： hgctl install 核心参数就是两个 -s (--set) 和 -f (--filename) 。 --set 参数是设置 profile 配置项的值， -f 传入 helm 自定义 values 值的 yaml 文件地址。 通过 -s profile=profile 内置 profile 名称或者 profile yaml 文件地址来指定安装 profile 来源。 安装成功后，会在当前用户 $HOME 目录下写入当前安装的profile配置 ~/.hgctl/profiles/install.yaml ， 升级时根据这个 profile 来升级。（后续版本会有变化） ","version":"Next","tagName":"h2"},{"title":"安装样例说明​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#安装样例说明","content":"默认安装 hgctl install Please select higress install configration profile: 1.Install higress to local kubernetes cluster like kind etc. 2.Install higress to kubernetes cluster 3.Install higress to local docker environment Please input 1, 2 or 3 to select, input your selection:  默认安装没有指定 profile, 会提示选择安装 profile。 指定 k8s profile 安装 ， 同时激活 IstioAPI， GatewayAPI 和 helm values 自定义 console 和 gateway resources 配置。 自定义 helm values.yaml 如下： global: istioNamespace: istio-system higress-console: resources: requests: cpu: 500m memory: 512Mi higress-core: gateway: resources: requests: cpu: 2000m memory: 2048Mi limits: cpu: 2000m memory: 2048Mi  helm 自定义配置项参考文件如下： global 和 higress-core 配置项: https://github.com/alibaba/higress/blob/main/helm/core/values.yamlglobal 和 higress-console 配置项: https://github.com/higress-group/higress-console/blob/main/helm/values.yaml 安装命令如下： hgctl install --set profile=k8s --set global.enableIstioAPI=true --set global.enableGatewayAPI=true --set gateway.replicas=1 -f ./values.yaml  本地 docker 环境下安装，同时指定 gateway http 和 https 端口  hgctl install --set profile=local-docker --set gateway.httpPort=80 --set gateway.httpsPort=443  默认安装后端存储采用文件系统保存配置， 如果后端存储采用 nacos 保存， 安装时传入 --set storage.url=nacos://192.168.0.1:8848， 这里设置具体 nacos 服务地址。 安装完成后，在当前目录下创建 higress-standalone 目录，具体结构如下： ├── hgctl ├── higress-standalone │ ├── conf │ │ ├── configmaps │ │ ├── endpoints │ │ ├── http2rpcs │ │ ├── ingressclasses │ │ ├── ingresses │ │ ├── mcpbridges │ │ ├── mutatingwebhookconfigurations │ │ ├── namespaces │ │ ├── nodes │ │ ├── pods │ │ ├── secrets │ │ ├── services │ │ ├── validatingwebhookconfigurations │ │ └── wasmplugins │ ├── get-higress.sh │ └── higress │ ├── CODEOWNERS │ ├── LICENSE │ ├── README.md │ ├── VERSION │ ├── bin │ └── compose  目录和文件具体内容如下： higress-standalone/conf: 配置后端存储文件目录higress-standalone/higress: higress 安装文件目录higress-standalone/higress/compose： higress docker compose 配置目录higress-standalone/higress/bin： 管理 higress 脚本目录higress-standalone/higress/compose/.env: higress 安装后生成配置文件 安装成功后，会在当前用户 $HOME 目录下写入当前安装的 profile 配置: ~/.hgctl/profiles/install.yaml， 升级时根据这个 profile 来升级。（后续版本会有变化） ","version":"Next","tagName":"h3"},{"title":"升级命令： hgctl upgrade​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#升级命令-hgctl-upgrade","content":"升级命令参数如下： hgctl upgrade --help The upgrade command is an alias for the install command that performs additional upgrade-related checks. Usage: hgctl upgrade [flags] Flags: --context string The name of the kubeconfig context to use. -f, --filename strings Path to file containing helm custom values -h, --help help for upgrade --kubeconfig string Path to the kubeconfig file to use for CLI requests. -d, --manifests string Specify a path to a directory of profiles (e.g. ~/Downloads/higress/manifests). -s, --set stringArray Override an higress profile value, e.g. to choose a profile (--set profile=local-k8s), or override profile values (--set gateway.replicas=2), or override helm values (--set values.global.proxy.resources.requsts.cpu=500m).  升级命令参数和安装参数时一致的，核心参数就是两个 -s (--set) 和 -f (--filename) 。 主要差别是不能设置profile, 升级 profile 是来源于安装时保存： ~/.hgctl/profiles/install.yaml 。 ","version":"Next","tagName":"h2"},{"title":"Dashboard 命令: hgctl dashbaord​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#dashboard-命令--hgctl-dashbaord","content":"可以通过 hgctl dashboard 命令打开 Higress Console 管理界面， Higress Controller Debug界面， Envoy 管理界面，Grafana 和 Prometheus 管理界面 hgctl dashboard 命令参数如下： hgctl dashboard --help Usage: hgctl dashboard [flags] hgctl dashboard [command] Aliases: dashboard, dash, d Available Commands: console Open Console web UI controller Open Controller debug web UI envoy Open Envoy admin web UI grafana Open Grafana web UI prometheus Open Prometheus web UI Flags: --browser When --browser is supplied as false, hgctl dashboard will not open the browser. Default is true which means hgctl dashboard will always open a browser to view the dashboard. (default true) --context string The name of the kubeconfig context to use. -h, --help help for dashboard --kubeconfig string Path to the kubeconfig file to use for CLI requests. -n, --namespace string Namespace where the addon is running, if not specified, higress-system would be used (default &quot;higress-system&quot;) -p, --port int Local port to listen to Use &quot;hgctl dashboard [command] --help&quot; for more information about a command.  ","version":"Next","tagName":"h2"},{"title":"卸载命令: hgctl uninstall​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#卸载命令-hgctl-uninstall","content":"hgctl uninstall 命令参数如下： hgctl uninstall --help The uninstall command uninstalls higress from a cluster or local environment Usage: hgctl uninstall [flags] Examples: # Uninstall higress hgctl uninstal # Uninstall higress, istioAPI and GatewayAPI from a cluster hgctl uninstall --purge-resources Flags: --context string The name of the kubeconfig context to use. -h, --help help for uninstall --kubeconfig string Path to the kubeconfig file to use for CLI requests. --purge-resources Delete all of IstioAPI,GatewayAPI resources  hgctl uninstall 卸载时不会自动卸载 IstioAPI, GatewayAPI组件， 如果要卸载 IstioAPI, GatewayAPI组件，卸载时加上 --purge-resources。 ","version":"Next","tagName":"h2"},{"title":"插件命令： hgctl plugin 命令​","type":1,"pageTitle":"hgctl 工具使用说明","url":"/zh-cn/docs/ops/hgctl#插件命令-hgctl-plugin-命令","content":"TBD ","version":"Next","tagName":"h2"},{"title":"AI 提示词模板","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-prompt-template","content":"","keywords":"higress ai","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 提示词模板","url":"/zh-cn/docs/plugins/ai/ai-prompt-template#功能说明","content":"AI 提示词模版插件用于快速构建固定格式的 Prompt，对于特定应用需要限制问题格式的场景会比较有帮助，可以在网关上配置 Prompt 模版，并基于大模型的能力来提供对应的 API。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 提示词模板","url":"/zh-cn/docs/plugins/ai/ai-prompt-template#配置说明","content":"名称\t数据类型\t填写要求\t默认值\t描述templates\tarray of object\t必填\t-\t模板设置 template object 配置说明： 名称\t数据类型\t填写要求\t默认值\t描述name\tstring\t必填\t-\t模板名称 template.model\tstring\t必填\t-\t模型名称 template.messages\tarray of object\t必填\t-\t大模型输入 message object 配置说明： 名称\t数据类型\t填写要求\t默认值\t描述role\tstring\t必填\t-\t角色 content\tstring\t必填\t-\t消息 配置示例如下： templates: - name: &quot;developer-chat&quot; template: model: gpt-3.5-turbo messages: - role: system content: &quot;You are a {{program}} expert, in {{language}} programming language.&quot; - role: user content: &quot;Write me a {{program}} program.&quot;  使用以上配置的请求body示例： { &quot;template&quot;: &quot;developer-chat&quot;, &quot;properties&quot;: { &quot;program&quot;: &quot;quick sort&quot;, &quot;language&quot;: &quot;python&quot; } }  ","version":"Next","tagName":"h2"},{"title":"AI 提示词修饰","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-prompt-decorator","content":"","keywords":"higress ai","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 提示词修饰","url":"/zh-cn/docs/plugins/ai/ai-prompt-decorator#功能说明","content":"AI 提示词修饰插件用于对 Prompt 进行调整，支持在用户输入的 Prompt 前后添加额外的 Prompt，用户可以使用 Higress AI 网关来统一处理应用逻辑中需要操控 Prompt 的地方，让所有 LLM API 流量都经过 Higress 进行处理，自动完成 Prompt 的统一操控。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 提示词修饰","url":"/zh-cn/docs/plugins/ai/ai-prompt-decorator#配置说明","content":"名称\t数据类型\t填写要求\t默认值\t描述decorators\tarray of object\t必填\t-\t修饰设置 template object 配置说明： 名称\t数据类型\t填写要求\t默认值\t描述name\tstring\t必填\t-\t修饰名称 decorator.prepend\tarray of message object\t必填\t-\t在初始输入之前插入的语句 decorator.append\tarray of message object\t必填\t-\t在初始输入之后插入的语句 message object 配置说明： 名称\t数据类型\t填写要求\t默认值\t描述role\tstring\t必填\t-\t角色 content\tstring\t必填\t-\t消息 示例 配置示例如下： decorators: - name: &quot;hangzhou-guide&quot; decorator: prepend: - role: system content: &quot;You will always respond in the Chinese language.&quot; - role: user content: &quot;Assume you are from Hangzhou.&quot; append: - role: user content: &quot;Don't introduce Hangzhou's food.&quot;  使用以上配置发起请求： { &quot;model&quot;: &quot;gpt-3.5-turbo&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Please introduce your home.&quot; } ] }  响应如下： { &quot;id&quot;: &quot;chatcmpl-9UYwQlEg6GwAswEZBDYXl41RU4gab&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 1717071182, &quot;model&quot;: &quot;gpt-3.5-turbo-0125&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;杭州是一个美丽的城市，有着悠久的历史和富有特色的文化。这里风景优美，有西湖、雷峰塔等著名景点，吸引着许多游客前来观光。杭州人民热情好客，城市宁静安逸，是一个适合居住和旅游的地方。&quot; }, &quot;logprobs&quot;: null, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;usage&quot;: { &quot;prompt_tokens&quot;: 49, &quot;completion_tokens&quot;: 117, &quot;total_tokens&quot;: 166 }, &quot;system_fingerprint&quot;: null }  ","version":"Next","tagName":"h2"},{"title":"AI 内容安全","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-security-guard","content":"","keywords":"higress ai","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 内容安全","url":"/zh-cn/docs/plugins/ai/ai-security-guard#功能说明","content":"大模型通常是通过学习互联网上广泛可用的数据来训练的，它们有可能在过程中学习到并复现有害内容或不良言论，因此，当大模型未经过适当的过滤和监控就生成回应时，它们可能产生包含有害语言、误导信息、歧视性言论甚至是违反法律法规的内容。正是因为这种潜在的风险，大模型中的内容安全就显得异常重要。 在 Higress 中，通过简单的配置即可对接阿里云内容安全，为大模型问答的合规性保驾护航，内容安全提供了多种检测范围，用户可以在控制台进行配置：  ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 内容安全","url":"/zh-cn/docs/plugins/ai/ai-security-guard#配置说明","content":"Name\tType\tRequirement\tDefault\tDescriptionserviceSource\tstring\trequried\t-\t服务来源，填dns serviceName\tstring\trequried\t-\t服务名 servicePort\tstring\trequried\t-\t服务端口 domain\tstring\trequried\t-\t阿里云内容安全endpoint ak\tstring\trequried\t-\t阿里云AK sk\tstring\trequried\t-\t阿里云SK ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"AI 内容安全","url":"/zh-cn/docs/plugins/ai/ai-security-guard#配置示例","content":"serviceSource: &quot;dns&quot; serviceName: &quot;safecheck&quot; servicePort: 443 domain: &quot;green-cip.cn-shanghai.aliyuncs.com&quot; ak: &quot;XXXXXXXXX&quot; sk: &quot;XXXXXXXXXXXXXXX&quot;  配置后，如果请求/响应中包含了非法内容，被内容安全拦截后，网关会返回内容安全建议的回答：  ","version":"Next","tagName":"h2"},{"title":"AI 统计","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-statistics","content":"","keywords":"higress ai","version":"Next"},{"title":"AI 检索增强生成","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-rag","content":"","keywords":"higress ai rag","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 检索增强生成","url":"/zh-cn/docs/plugins/ai/ai-rag#功能说明","content":"基于 AI 检索增强生成（RAG）插件，可以通过对接阿里云向量检索服务实现 LLM-RAG 应用的开发，流程如图所示：  ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 检索增强生成","url":"/zh-cn/docs/plugins/ai/ai-rag#配置说明","content":"名称\t数据类型\t填写要求\t默认值\t描述dashscope.apiKey\tstring\t必填\t-\t用于在访问通义千问服务时进行认证的令牌。 dashscope.serviceName\tstring\t必填\t-\t通义千问服务名 dashscope.servicePort\tint\t必填\t-\t通义千问服务端口 dashscope.domain\tstring\t必填\t-\t访问通义千问服务时域名 dashvector.apiKey\tstring\t必填\t-\t用于在访问阿里云向量检索服务时进行认证的令牌。 dashvector.serviceName\tstring\t必填\t-\t阿里云向量检索服务名 dashvector.servicePort\tint\t必填\t-\t阿里云向量检索服务端口 dashvector.domain\tstring\t必填\t-\t访问阿里云向量检索服务时域名 示例 dashscope: apiKey: xxxxxxxxxxxxxxx serviceName: dashscope servicePort: 443 domain: dashscope.aliyuncs.com dashvector: apiKey: xxxxxxxxxxxxxxxxxxxx serviceName: dashvector servicePort: 443 domain: vrs-cn-xxxxxxxxxxxxxxx.dashvector.cn-hangzhou.aliyuncs.com collection: xxxxxxxxxxxxxxx  CEC-Corpus 数据集包含 332 篇突发事件的新闻报道的语料和标注数据，提取其原始的新闻稿文本，将其向量化后添加到阿里云向量检索服务。文本向量化的教程可以参考《基于向量检索服务与灵积实现语义搜索》。 以下为使用 RAG 进行增强的例子，原始请求为： 海南追尾事故，发生在哪里？原因是什么？人员伤亡情况如何？  未经过 RAG 插件处理 LLM 返回的结果为： 抱歉，作为AI模型，我无法实时获取和更新新闻事件的具体信息，包括地点、原因、人员伤亡等细节。对于此类具体事件，建议您查阅最新的新闻报道或官方通报以获取准确信息。您可以访问主流媒体网站、使用新闻应用或者关注相关政府部门的公告来获取这类动态资讯。  经过 RAG 插件处理后 LLM 返回的结果为： 海南追尾事故发生在海文高速公路文昌至海口方向37公里处。关于事故的具体原因，交警部门当时仍在进一步调查中，所以根据提供的信息无法确定事故的确切原因。人员伤亡情况是1人死亡（司机当场死亡），另有 8 人受伤（包括 2 名儿童和 6 名成人），所有受伤人员都被解救并送往医院进行治疗。  ","version":"Next","tagName":"h2"},{"title":"功能说明​","type":1,"pageTitle":"AI 统计","url":"/zh-cn/docs/plugins/ai/ai-statistics#功能说明","content":"相比于传统微服务，LLM 应用中主要通过 token 来衡量流量大小，针对此特点，AI 统计插件提供了路由级、服务级、模型级的 token 用量观测能力，包括日志、监控以及告警。 AI 统计插件需要对接 ai-proxy 插件，如果不接 ai-proxy 插件的话，则只支持 openai 协议。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 统计","url":"/zh-cn/docs/plugins/ai/ai-statistics#配置说明","content":"名称\t数据类型\t填写要求\t默认值\t描述enable\tbool\t必填\t-\t是否开启ai统计功能 开启后 metrics 示例： route_upstream_model_input_token{ai_route=&quot;openai&quot;,ai_cluster=&quot;qwen&quot;,ai_model=&quot;qwen-max&quot;} 21 route_upstream_model_output_token{ai_route=&quot;openai&quot;,ai_cluster=&quot;qwen&quot;,ai_model=&quot;qwen-max&quot;} 17  日志示例： { &quot;model&quot;: &quot;qwen-max&quot;, &quot;input_token&quot;: &quot;21&quot;, &quot;output_token&quot;: &quot;17&quot;, &quot;authority&quot;: &quot;dashscope.aliyuncs.com&quot;, &quot;bytes_received&quot;: &quot;336&quot;, &quot;bytes_sent&quot;: &quot;1675&quot;, &quot;duration&quot;: &quot;1590&quot;, &quot;istio_policy_status&quot;: &quot;-&quot;, &quot;method&quot;: &quot;POST&quot;, &quot;path&quot;: &quot;/v1/chat/completions&quot;, &quot;protocol&quot;: &quot;HTTP/1.1&quot;, &quot;request_id&quot;: &quot;5895f5a9-e4e3-425b-98db-6c6a926195b7&quot;, &quot;requested_server_name&quot;: &quot;-&quot;, &quot;response_code&quot;: &quot;200&quot;, &quot;response_flags&quot;: &quot;-&quot;, &quot;route_name&quot;: &quot;openai&quot;, &quot;start_time&quot;: &quot;2024-06-18T09:37:14.078Z&quot;, &quot;trace_id&quot;: &quot;-&quot;, &quot;upstream_cluster&quot;: &quot;qwen&quot;, &quot;upstream_service_time&quot;: &quot;496&quot;, &quot;upstream_transport_failure_reason&quot;: &quot;-&quot;, &quot;user_agent&quot;: &quot;PostmanRuntime/7.37.3&quot;, &quot;x_forwarded_for&quot;: &quot;-&quot; }  ","version":"Next","tagName":"h2"},{"title":"AI 请求/响应转换","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-transformer","content":"","keywords":"higress ai transformer","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 请求/响应转换","url":"/zh-cn/docs/plugins/ai/ai-transformer#功能说明","content":"通过配置 AI 请求/响应转换插件，用户可以不用写代码，直接使用自然语言的方式对网关的请求/响应进行修改。例如测试人员在测试 API 时，对待测 API 进行插件配置，将原始请求/响应作为 example，来生成进行边界条件测试的请求/响应。大模型很多时候会比人考虑的更全面，更容易测试出一些边界 case。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI 请求/响应转换","url":"/zh-cn/docs/plugins/ai/ai-transformer#配置说明","content":"名称\t数据类型\t填写要求\t默认值\t描述request.enable\tbool\t必填\t-\t是否在request阶段开启转换 request.prompt\tstring\t必填\t-\trequest阶段转换使用的prompt response.enable\tstring\t必填\t-\t是否在response阶段开启转换 response.prompt\tstring\t必填\t-\tresponse阶段转换使用的prompt provider.serviceName\tstring\t必填\t-\tDNS类型的服务名，目前仅支持通义千问 provider.domain\tstring\t必填\t-\tLLM服务域名 provider.apiKey\tstring\t必填\t-\t阿里云dashscope服务的API Key ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"AI 请求/响应转换","url":"/zh-cn/docs/plugins/ai/ai-transformer#配置示例","content":"request: enable: false prompt: &quot;如果请求path是以/httpbin开头的，帮我去掉/httpbin前缀，其他的不要改。&quot; response: enable: true prompt: &quot;帮我修改以下HTTP应答信息，要求：1. content-type修改为application/json；2. body由xml转化为json；3. 移除content-length。&quot; provider: serviceName: qwen domain: dashscope.aliyuncs.com apiKey: xxxxxxxxxxxxx  访问原始的 httbin 的 /xml 接口，结果为： &lt;?xml version='1.0' encoding='us-ascii'?&gt; &lt;!-- A SAMPLE set of slides --&gt; &lt;slideshow title=&quot;Sample Slide Show&quot; date=&quot;Date of publication&quot; author=&quot;Yours Truly&quot; &gt; &lt;!-- TITLE SLIDE --&gt; &lt;slide type=&quot;all&quot;&gt; &lt;title&gt;Wake up to WonderWidgets!&lt;/title&gt; &lt;/slide&gt; &lt;!-- OVERVIEW --&gt; &lt;slide type=&quot;all&quot;&gt; &lt;title&gt;Overview&lt;/title&gt; &lt;item&gt;Why &lt;em&gt;WonderWidgets&lt;/em&gt; are great&lt;/item&gt; &lt;item/&gt; &lt;item&gt;Who &lt;em&gt;buys&lt;/em&gt; WonderWidgets&lt;/item&gt; &lt;/slide&gt; &lt;/slideshow&gt;  使用以上配置，通过网关访问 httpbin 的 /xml 接口，结果为： { &quot;slideshow&quot;: { &quot;title&quot;: &quot;Sample Slide Show&quot;, &quot;date&quot;: &quot;Date of publication&quot;, &quot;author&quot;: &quot;Yours Truly&quot;, &quot;slides&quot;: [ { &quot;type&quot;: &quot;all&quot;, &quot;title&quot;: &quot;Wake up to WonderWidgets!&quot; }, { &quot;type&quot;: &quot;all&quot;, &quot;title&quot;: &quot;Overview&quot;, &quot;items&quot;: [ &quot;Why &lt;em&gt;WonderWidgets&lt;/em&gt; are great&quot;, &quot;&quot;, &quot;Who &lt;em&gt;buys&lt;/em&gt; WonderWidgets&quot; ] } ] } }  ","version":"Next","tagName":"h2"},{"title":"Basic 认证","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/authentication/basic-auth","content":"","keywords":"higress auth","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#功能说明","content":"basic-auth 插件实现了基于 HTTP Basic Auth 标准进行认证鉴权的功能。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#配置字段","content":"","version":"Next","tagName":"h2"},{"title":"全局配置​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#全局配置","content":"名称\t数据类型\t填写要求\t默认值\t描述consumers\tarray of object\t必填\t-\t配置服务的调用者，用于对请求进行认证 global_auth\tbool\t选填\t-\t若配置为 true，则全局生效认证机制; 若配置为 false，则只对做了配置的域名和路由生效认证机制; 若不配置则仅当没有域名和路由配置时全局生效（兼容机制） consumers 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述credential\tstring\t必填\t-\t配置该 consumer 的访问凭证 name\tstring\t必填\t-\t配置该 consumer 的名称 ","version":"Next","tagName":"h3"},{"title":"域名和路由级配置​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#域名和路由级配置","content":"名称\t数据类型\t填写要求\t默认值\t描述allow\tarray of string\t必填\t-\t对于符合匹配条件的请求，配置允许访问的 consumer 名称 注意： 对于通过认证鉴权的请求，请求的 header 会被添加一个 X-Mse-Consumer 字段，用以标识调用者的名称。 ","version":"Next","tagName":"h3"},{"title":"配置示例​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"对特定路由或域名开启认证和鉴权​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#对特定路由或域名开启认证和鉴权","content":"以下配置将对网关特定路由或域名开启 Basic Auth 认证和鉴权，注意凭证信息中的用户名和密码之间使用 &quot;:&quot; 分隔，credential 字段不能重复 全局配置 consumers: - credential: 'admin:123456' name: consumer1 - credential: 'guest:abc' name: consumer2 global_auth: false  路由级配置 对 route-a 和 route-b 这两个路由做如下配置： allow: - consumer1  对 *.example.com 和 test.com 在这两个域名做如下配置: allow: - consumer2  若是在控制台进行配置，此例指定的 route-a 和 route-b 即在控制台创建路由时填写的路由名称，当匹配到这两个路由时，将允许 name 为 consumer1 的调用者访问，其他调用者不允许访问； 此例指定的 *.example.com 和 test.com 用于匹配请求的域名，当发现域名匹配时，将允许 name 为 consumer2 的调用者访问，其他调用者不允许访问。 根据该配置，下列请求可以允许访问。 请求指定用户名密码。 # 假设以下请求将会匹配到 route-a 路由 # 使用 curl 的 -u 参数指定 curl -u admin:123456 http://xxx.hello.com/test # 或者直接指定 Authorization 请求头，用户名密码使用 base64 编码 curl -H 'Authorization: Basic YWRtaW46MTIzNDU2' http://xxx.hello.com/test  认证鉴权通过后，请求的 header 中会被添加一个 X-Mse-Consumer 字段，在此例中其值为 consumer1，用以标识调用方的名称 下列请求将拒绝访问。 请求未提供用户名密码，返回 401。 curl http://xxx.hello.com/test  请求提供的用户名密码错误，返回401。 curl -u admin:abc http://xxx.hello.com/test  根据请求的用户名和密码匹配到的调用者无访问权限，返回 403。 # consumer2 不在 route-a 的 allow 列表里 curl -u guest:abc http://xxx.hello.com/test  ","version":"Next","tagName":"h3"},{"title":"相关错误码​","type":1,"pageTitle":"Basic 认证","url":"/zh-cn/docs/plugins/authentication/basic-auth#相关错误码","content":"HTTP 状态码\t出错信息\t原因说明401\tRequest denied by Basic Auth check. No Basic Authentication information found.\t请求未提供凭证 401\tRequest denied by Basic Auth check. Invalid username and/or password\t请求凭证无效 403\tRequest denied by Basic Auth check. Unauthorized consumer\t请求的调用方无访问权限 ","version":"Next","tagName":"h2"},{"title":"HMAC 认证","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/authentication/hmac-auth","content":"","keywords":"higress auth","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#功能说明","content":"hmac-auth 插件实现了基于 HMAC 算法为 HTTP 请求生成不可伪造的签名，并基于签名实现身份认证和鉴权。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#配置字段","content":"","version":"Next","tagName":"h2"},{"title":"全局配置​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#全局配置","content":"名称\t数据类型\t填写要求\t默认值\t描述consumers\tarray of object\t必填\t-\t配置服务的调用者，用于对请求进行认证 date_offset\tnumber\t选填\t-\t配置允许的客户端最大时间偏移，单位为秒，根据请求头 Date 解析客户端 UTC 时间，可用于避免请求重放；未配置时，不做校验 global_auth\tbool\t选填\t-\t若配置为true，则全局生效认证机制; 若配置为 false，则只对做了配置的域名和路由生效认证机制; 若不配置则仅当没有域名和路由配置时全局生效（兼容机制） consumers 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述key\tstring\t必填\t-\t配置从请求的 x-ca-key 头中提取的 key secret\tstring\t必填\t-\t配置用于生成签名的 secret name\tstring\t必填\t-\t配置该 consumer 的名称 ","version":"Next","tagName":"h3"},{"title":"域名和路由级配置​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#域名和路由级配置","content":"名称\t数据类型\t填写要求\t默认值\t描述allow\tarray of string\t必填\t-\t对于符合匹配条件的请求，配置允许访问的 consumer 名称 注意： 对于通过认证鉴权的请求，请求的 header 会被添加一个 X-Mse-Consumer 字段，用以标识调用者的名称。 ","version":"Next","tagName":"h3"},{"title":"配置示例​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#配置示例","content":"以下配置将对网关特定路由或域名开启 Hmac Auth 认证和鉴权，注意 key 字段不能重复。 ","version":"Next","tagName":"h2"},{"title":"对特定路由或域名开启​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#对特定路由或域名开启","content":"全局配置 consumers: - key: appKey-example-1 secret: appSecret-example-1 name: consumer-1 - key: appKey-example-2 secret: appSecret-example-2 name: consumer-2 global_auth: false  路由级配置 对 route-a 和 route-b 这两个路由做如下配置： allow: - consumer1  对 *.exmaple.com 和 test.com 在这两个域名做如下配置： allow: - consumer2  每条匹配规则下的 allow 字段用于指定该匹配条件下允许访问的调用者列表； 若是在控制台进行配置，此例指定的 route-a 和 route-b 即在控制台创建路由时填写的路由名称，当匹配到这两个路由时，将允许 name 为 consumer1 的调用者访问，其他调用者不允许访问； 此例指定的 *.example.com 和 test.com 用于匹配请求的域名，当发现域名匹配时，将允许 name 为 consumer2 的调用者访问，其他调用者不允许访问。 认证成功后，请求的header中会被添加一个 X-Mse-Consumer 字段，其值为调用方的名称，例如 consumer-1。 ","version":"Next","tagName":"h3"},{"title":"签名机制说明​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#签名机制说明","content":"","version":"Next","tagName":"h2"},{"title":"配置准备​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#配置准备","content":"如上指引，在插件配置中配置生成和验证签名需要用的凭证配置 key: 用于请求头 x-ca-key 中设置secret: 用于生成请求签名 ","version":"Next","tagName":"h3"},{"title":"客户端签名生成方式​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#客户端签名生成方式","content":"流程简介​ 客户端生成签名一共分三步处理： 从原始请求中提取关键数据，得到一个用来签名的字符串 使用加密算法和配置的 secret 对关键数据签名串进行加密处理，得到签名 将签名所相关的所有头加入到原始HTTP请求中，得到最终HTTP请求 如下图所示：  签名串提取流程​ 客户端需要从Http请求中提取出关键数据，组合成一个签名串，生成的签名串的格式如下： HTTPMethod Accept Content-MD5 Content-Type Date Headers PathAndParameters  以上7个字段构成整个签名串，字段之间使用\\n间隔，如果Headers为空，则不需要加\\n，其他字段如果为空都需要保留\\n。签名大小写敏感。下面介绍下每个字段的提取规则： HTTPMethod：HTTP 的方法，全部大写，比如 POST Accept：请求中的 Accept 头的值，可为空。建议显式设置 Accept Header。当 Accept 为空时，部分 Http 客户端会给 Accept 设置默认值为 */*，导致签名校验失败。 Content-MD5：请求中的 Content-MD5 头的值，可为空只有在请求存在 Body 且 Body 为非 Form 形式时才计算 Content-MD5 头，下面是 Java 的 Content-MD5 值的参考计算方式： String content-MD5 = Base64.encodeBase64(MD5(bodyStream.getbytes(&quot;UTF-8&quot;)));  Content-Type：请求中的 Content-Type 头的值，可为空 Date：请求中的 Date 头的值，当未开启 date_offset 配置时，可为空，否则将用于时间偏移校验 Headers：用户可以选取指定的 header 参与签名，关于 header 的签名串拼接方式有以下规则： 参与签名计算的 Header 的 Key 按照字典排序后使用如下方式拼接 HeaderKey1 + &quot;:&quot; + HeaderValue1 + &quot;\\n&quot;\\+ HeaderKey2 + &quot;:&quot; + HeaderValue2 + &quot;\\n&quot;\\+ ... HeaderKeyN + &quot;:&quot; + HeaderValueN + &quot;\\n&quot; 某个 Header 的 Value 为空，则使用 HeaderKey+&quot;:&quot;+&quot;\\n&quot; 参与签名，需要保留 Key 和英文冒号所有参与签名的 Header 的 Key 的集合使用英文逗号分割放到 Key 为 X-Ca-Signature-Headers 的 Header 中以下 Header 不参与 Header 签名计算：X-Ca-Signature、X-Ca-Signature-Headers、Accept、Content-MD5、Content-Type、Date PathAndParameters：这个字段包含 Path，Query 和 Form 中的所有参数，具体组织形式如下： Path + &quot;?&quot; + Key1 + &quot;=&quot; + Value1 + &quot;&amp;&quot; + Key2 + &quot;=&quot; + Value2 + ... &quot;&amp;&quot; + KeyN + &quot;=&quot; + ValueN  注意： Query 和 Form 参数对的 Key 按照字典排序后使用上面的方式拼接Query 和 Form 参数为空时，则直接使用 Path，不需要添加?参数的 Value 为空时只保留 Key 参与签名，等号不需要再加入签名Query 和 Form 存在数组参数时（key 相同，value 不同的参数） ，取第一个 Value 参与签名计算 签名串提取示例​ 初始的 HTTP 请求： POST /http2test/test?param1=test HTTP/1.1 host:api.aliyun.com accept:application/json; charset=utf-8 ca_version:1 content-type:application/x-www-form-urlencoded; charset=utf-8 x-ca-timestamp:1525872629832 date:Wed, 09 May 2018 13:30:29 GMT+00:00 user-agent:ALIYUN-ANDROID-DEMO x-ca-nonce:c9f15cbf-f4ac-4a6c-b54d-f51abf4b5b44 content-length:33 username=xiaoming&amp;password=123456789  生成的正确签名串为： POST application/json; charset=utf-8 application/x-www-form-urlencoded; charset=utf-8 Wed, 09 May 2018 13:30:29 GMT+00:00 x-ca-key:203753385 x-ca-nonce:c9f15cbf-f4ac-4a6c-b54d-f51abf4b5b44 x-ca-signature-method:HmacSHA256 x-ca-timestamp:1525872629832 /http2test/test?param1=test&amp;password=123456789&amp;username=xiaoming  签名计算流程​ 客户端从 HTTP 请求中提取出关键数据组装成签名串后，需要对签名串进行加密及编码处理，形成最终的签名。 具体的加密形式如下，其中 stringToSign 是提取出来的签名串，secret 就是插件配置中填写的，sign 是最终生成的签名： Mac hmacSha256 = Mac.getInstance(&quot;HmacSHA256&quot;); byte[] secretBytes = secret.getBytes(&quot;UTF-8&quot;); hmacSha256.init(new SecretKeySpec(secretBytes, 0, secretBytes.length, &quot;HmacSHA256&quot;)); byte[] result = hmacSha256.doFinal(stringToSign.getBytes(&quot;UTF-8&quot;)); String sign = Base64.encodeBase64String(result);  总结一下，就是将 stringToSign 使用 UTF-8 解码后得到 Byte 数组，然后使用加密算法对 Byte 数组进行加密，然后使用 Base64 算法进行编码，形成最终的签名。 添加签名流程​ 客户端需要将以下四个 Header 放在 HTTP 请求中传输给 API 网关，进行签名校验： x-ca-key：取值 APP Key，必选 x-ca-signature-method：签名算法，取值 HmacSHA256 或者 HmacSHA1，可选，默认值为 HmacSHA256 x-ca-signature-headers：所有签名头的 Key 的集合，使用英文逗号分隔，可选 x-ca-signature：签名，必选 下面是携带签名的整个 HTTP 请求的示例： POST /http2test/test?param1=test HTTP/1.1 host:api.aliyun.com accept:application/json; charset=utf-8 ca_version:1 content-type:application/x-www-form-urlencoded; charset=utf-8 x-ca-timestamp:1525872629832 date:Wed, 09 May 2018 13:30:29 GMT+00:00 user-agent:ALIYUN-ANDROID-DEMO x-ca-nonce:c9f15cbf-f4ac-4a6c-b54d-f51abf4b5b44 x-ca-key:203753385 x-ca-signature-method:HmacSHA256 x-ca-signature-headers:x-ca-timestamp,x-ca-key,x-ca-nonce,x-ca-signature-method x-ca-signature:xfX+bZxY2yl7EB/qdoDy9v/uscw3Nnj1pgoU+Bm6xdM= content-length:33 username=xiaoming&amp;password=123456789  ","version":"Next","tagName":"h3"},{"title":"服务端签名验证方式​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#服务端签名验证方式","content":"流程简介​ 服务器验证客户端签名一共分四步处理： 从接收到的请求中提取关键数据，得到一个用来签名的字符串 从接收到的请求中读取 key ，通过 key 查询到对应的 secret 使用加密算法和 secret 对关键数据签名串进行加密处理，得到签名 从接收到的请求中读取客户端签名，对比服务器端签名和客户端签名的一致性 如下图所示： ","version":"Next","tagName":"h3"},{"title":"签名排错方法​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#签名排错方法","content":"网关签名校验失败时，会将服务端的签名串（StringToSign）放到 HTTP Response 的 Header 中返回到客户端，Key 为：X-Ca-Error-Message，用户只需要将本地计算的签名串（StringToSign）与服务端返回的签名串进行对比即可找到问题； 如果服务端与客户端的 StringToSign 一致请检查用于签名计算的 APP Secret 是否正确； 因为 HTTP Header 中无法表示换行，因此 StringToSign 中的换行符都被替换成#，如下所示： X-Ca-Error-Message: Server StringToSign:`GET#application/json##application/json##X-Ca-Key:200000#X-Ca-Timestamp:1589458000000#/app/v1/config/keys?keys=TEST`  ","version":"Next","tagName":"h3"},{"title":"相关错误码​","type":1,"pageTitle":"HMAC 认证","url":"/zh-cn/docs/plugins/authentication/hmac-auth#相关错误码","content":"HTTP 状态码\t出错信息\t原因说明401\tInvalid Key\t请求头未提供 x-ca-key，或者 x-ca-key 无效 401\tEmpty Signature\t请求头未提供 x-ca-signature 签名串 400\tInvalid Signature\t请求头 x-ca-signature 签名串，与服务端计算得到签名不一致 400\tInvalid Content-MD5\t请求头 content-md5 不正确 400\tInvalid Date\t根据请求头 date 计算时间偏移超过配置的 date_offset 413\tRequest Body Too Large\t请求 Body 超过限制大小：32 MB 413\tPayload Too Large\t请求 Body 超过全局配置 DownstreamConnectionBufferLimits 403\tUnauthorized Consumer\t请求的调用方无访问权限 ","version":"Next","tagName":"h2"},{"title":"Key 认证","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/authentication/key-auth","content":"","keywords":"higress auth","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"Key 认证","url":"/zh-cn/docs/plugins/authentication/key-auth#功能说明","content":"key-auth 插件实现了基于 API Key 进行认证鉴权的功能，支持从 HTTP 请求的 URL 参数或者请求头解析 API Key，同时验证该 API Key 是否有权限访问。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"Key 认证","url":"/zh-cn/docs/plugins/authentication/key-auth#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述global_auth\tbool\t选填\t-\t若配置为true，则全局生效认证机制; 若配置为false，则只对做了配置的域名和路由生效认证机制; 若不配置则仅当没有域名和路由配置时全局生效（兼容机制） consumers\tarray of object\t必填\t-\t配置服务的调用者，用于对请求进行认证 keys\tarray of string\t必填\t-\tAPI Key 的来源字段名称，可以是 URL 参数或者 HTTP 请求头名称 in_query\tbool\tin_query 和 in_header 至少有一个为 true\ttrue\t配置 true 时，网关会尝试从 URL 参数中解析 API Key in_header\tbool\tin_query 和 in_header 至少有一个为 true\ttrue\t配置 true 时，网关会尝试从 HTTP 请求头中解析 API Key consumers 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述credential\tstring\t必填\t-\t配置该 consumer 的访问凭证 name\tstring\t必填\t-\t配置该 consumer 的名称 注意： 对于通过认证鉴权的请求，请求的 header 会被添加一个 X-Mse-Consumer 字段，用以标识调用者的名称。 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"Key 认证","url":"/zh-cn/docs/plugins/authentication/key-auth#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"对特定路由或域名开启​","type":1,"pageTitle":"Key 认证","url":"/zh-cn/docs/plugins/authentication/key-auth#对特定路由或域名开启","content":"以下配置将对网关特定路由或域名开启 Key Auth 认证和鉴权，注意 credential 字段不能重复。 global_auth: true consumers: - credential: 2bda943c-ba2b-11ec-ba07-00163e1250b5 name: consumer1 - credential: c8c8e9ca-558e-4a2d-bb62-e700dcc40e35 name: consumer2 keys: - apikey - x-api-key  路由级配置 对 route-a 和 route-b 这两个路由做如下配置： allow: - consumer1  对 *.example.com 和 test.com 在这两个域名做如下配置: allow: - consumer2  根据该配置，下列请求可以允许访问。 假设以下请求会匹配到 route-a 这条路由。 将 API Key 设置在 url 参数中。 curl http://xxx.hello.com/test?apikey=2bda943c-ba2b-11ec-ba07-00163e1250b5  将 API Key 设置在 http 请求头中。 curl http://xxx.hello.com/test -H 'x-api-key: 2bda943c-ba2b-11ec-ba07-00163e1250b5'  认证鉴权通过后，请求的header中会被添加一个 X-Mse-Consumer 字段，在此例中其值为 consumer1，用以标识调用方的名称 下列请求将拒绝访问。 请求未提供 API Key，返回 401。 curl http://xxx.hello.com/test  请求提供的 API Key 无权访问，返回 401。 curl http://xxx.hello.com/test?apikey=926d90ac-ba2e-11ec-ab68-00163e1250b5  根据请求提供的 API Key匹配到的调用者无访问权限，返回 403。 # consumer2不在route-a的allow列表里 curl http://xxx.hello.com/test?apikey=c8c8e9ca-558e-4a2d-bb62-e700dcc40e35  ","version":"Next","tagName":"h3"},{"title":"网关实例级别开启​","type":1,"pageTitle":"Key 认证","url":"/zh-cn/docs/plugins/authentication/key-auth#网关实例级别开启","content":"以下配置未指定 matchRules 字段，因此将对网关实例级别开启全局 Key Auth 认证. defaultConfig consumers: - credential: 2bda943c-ba2b-11ec-ba07-00163e1250b5 name: consumer1 - credential: c8c8e9ca-558e-4a2d-bb62-e700dcc40e35 name: consumer2 keys: - apikey in_query: true  开启 matchRules 方式如下： matchRules: - config: allow: - consumer1  ","version":"Next","tagName":"h3"},{"title":"相关错误码​","type":1,"pageTitle":"Key 认证","url":"/zh-cn/docs/plugins/authentication/key-auth#相关错误码","content":"HTTP 状态码\t出错信息\t原因说明401\tRequest denied by Key Auth check. Muti API key found in request\t请求提供多个 API Key 401\tRequest denied by Key Auth check. No API key found in request\t请求未提供 API Key 401\tRequest denied by Key Auth check. Invalid API key\t不允许当前 API Key 访问 403\tRequest denied by Key Auth check. Unauthorized consumer\t请求的调用方无访问权限 ","version":"Next","tagName":"h2"},{"title":"JWT 认证","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/authentication/jwt-auth","content":"","keywords":"higress auth","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#功能说明","content":"jwt-auth 插件实现了基于 JWT(JSON Web Tokens) 进行认证鉴权的功能，支持从 HTTP 请求的 URL 参数、请求头、Cookie 字段解析 JWT，同时验证该 Token 是否有权限访问。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#配置字段","content":"","version":"Next","tagName":"h2"},{"title":"全局配置​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#全局配置","content":"名称\t数据类型\t填写要求\t默认值\t描述consumers\tarray of object\t必填\t-\t配置服务的调用者，用于对请求进行认证 global_auth\tbool\t选填\t-\t若配置为 true，则全局生效认证机制; 若配置为 false，则只对做了配置的域名和路由生效认证机制; 若不配置则仅当没有域名和路由配置时全局生效（兼容机制） consumers 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述name\tstring\t必填\t-\t配置该 consumer 的名称 jwks\tstring\t必填\t-\thttps://www.rfc-editor.org/rfc/rfc7517 指定的 json 格式字符串，是由验证 JWT 中签名的公钥（或对称密钥）组成的 Json Web Key Set issuer\tstring\t必填\t-\tJWT 的签发者，需要和 payload 中的 iss 字段保持一致 claims_to_headers\tarray of object\t选填\t-\t抽取 JWT 的 payload 中指定字段，设置到指定的请求头中转发给后端 from_headers\tarray of object\t选填\t[{&quot;name&quot;:&quot;Authorization&quot;,&quot;value_prefix&quot;:&quot;Bearer &quot;}]\t从指定的请求头中抽取 JWT from_params\tarray of string\t选填\taccess_token\t从指定的 URL 参数中抽取 JWT from_cookies\tarray of string\t选填\t-\t从指定的 cookie 中抽取 JWT clock_skew_seconds\tnumber\t选填\t60\t校验 JWT 的 exp 和 iat 字段时允许的时钟偏移量，单位为秒 keep_token\tbool\t选填\ttrue\t转发给后端时是否保留 JWT 注意： 只有当from_headers,from_params,from_cookies均未配置时，才会使用默认值 from_headers 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述name\tstring\t必填\t-\t抽取 JWT 的请求 header value_prefix\tstring\t必填\t-\t对请求 header 的 value 去除此前缀，剩余部分作为 JWT claims_to_headers 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述claim\tstring\t必填\t-\tJWT payload 中的指定字段，要求必须是字符串或无符号整数类型 header\tstring\t必填\t-\t从payload 取出字段的值设置到这个请求头中，转发给后端 override\tbool\t选填\ttrue\ttrue 时，存在同名请求头会进行覆盖；false 时，追加同名请求头 ","version":"Next","tagName":"h3"},{"title":"域名和路由级配置​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#域名和路由级配置","content":"名称\t数据类型\t填写要求\t默认值\t描述allow\tarray of string\t必填\t-\t对于符合匹配条件的请求，配置允许访问的 consumer 名称 注意： 对于通过认证鉴权的请求，请求的header会被添加一个X-Mse-Consumer字段，用以标识调用者的名称。 ","version":"Next","tagName":"h3"},{"title":"配置示例​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"对特定路由或域名开启​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#对特定路由或域名开启","content":"以下配置将对网关特定路由或域名开启 Jwt Auth 认证和鉴权，注意如果一个 JWT 能匹配多个 jwks，则按照配置顺序命中第一个匹配的 consumer。 全局配置 consumers: - name: consumer1 issuer: abcd jwks: | { &quot;keys&quot;: [ { &quot;kty&quot;: &quot;oct&quot;, &quot;kid&quot;: &quot;123&quot;, &quot;k&quot;: &quot;hM0k3AbXBPpKOGg__Ql2Obcq7s60myWDpbHXzgKUQdYo7YCRp0gUqkCnbGSvZ2rGEl4YFkKqIqW7mTHdj-bcqXpNr-NOznEyMpVPOIlqG_NWVC3dydBgcsIZIdD-MR2AQceEaxriPA_VmiUCwfwL2Bhs6_i7eolXoY11EapLQtutz0BV6ZxQQ4dYUmct--7PLNb4BWJyQeWu0QfbIthnvhYllyl2dgeLTEJT58wzFz5HeNMNz8ohY5K0XaKAe5cepryqoXLhA-V-O1OjSG8lCNdKS09OY6O0fkyweKEtuDfien5tHHSsHXoAxYEHPFcSRL4bFPLZ0orTt1_4zpyfew&quot;, &quot;alg&quot;: &quot;HS256&quot; } ] } - name: consumer2 issuer: abc jwks: | { &quot;keys&quot;: [ { &quot;kty&quot;: &quot;RSA&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;use&quot;: &quot;sig&quot;, &quot;kid&quot;: &quot;123&quot;, &quot;alg&quot;: &quot;RS256&quot;, &quot;n&quot;: &quot;i0B67f1jggT9QJlZ_8QL9QQ56LfurrqDhpuu8BxtVcfxrYmaXaCtqTn7OfCuca7cGHdrJIjq99rz890NmYFZuvhaZ-LMt2iyiSb9LZJAeJmHf7ecguXS_-4x3hvbsrgUDi9tlg7xxbqGYcrco3anmalAFxsbswtu2PAXLtTnUo6aYwZsWA6ksq4FL3-anPNL5oZUgIp3HGyhhLTLdlQcC83jzxbguOim-0OEz-N4fniTYRivK7MlibHKrJfO3xa_6whBS07HW4Ydc37ZN3Rx9Ov3ZyV0idFblU519nUdqp_inXj1eEpynlxH60Ys_aTU2POGZh_25KXGdF_ZC_MSRw&quot; } ] } global_auth: false  路由级配置 对 route-a 和 route-b 这两个路由做如下配置： allow: - consumer1  对 *.exmaple.com 和 test.com 在这两个域名做如下配置： allow: - consumer2  每条匹配规则下的 allow 字段用于指定该匹配条件下允许访问的调用者列表； 若是在控制台进行配置，此例指定的 route-a 和 route-b 即在控制台创建路由时填写的路由名称，当匹配到这两个路由时，将允许 name 为 consumer1 的调用者访问，其他调用者不允许访问； 此例指定的 *.example.com 和 test.com 用于匹配请求的域名，当发现域名匹配时，将允许 name 为 consumer2 的调用者访问，其他调用者不允许访问。 认证成功后，请求的header中会被添加一个 X-Mse-Consumer 字段，其值为调用方的名称，例如 consumer-1。 根据该配置，下列请求可以允许访问 假设以下请求会匹配到 route-a 这条路由。 将 JWT 设置在 URL 参数中。 curl 'http://xxx.hello.com/test?access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMyJ9.eyJpc3MiOiJhYmNkIiwic3ViIjoidGVzdCIsImlhdCI6MTY2NTY2MDUyNywiZXhwIjoxODY1NjczODE5fQ.-vBSV0bKeDwQcuS6eeSZN9dLTUnSnZVk8eVCXdooCQ4'  将 JWT 设置在 HTTP 请求头中。 curl http://xxx.hello.com/test -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMyJ9.eyJpc3MiOiJhYmNkIiwic3ViIjoidGVzdCIsImlhdCI6MTY2NTY2MDUyNywiZXhwIjoxODY1NjczODE5fQ.-vBSV0bKeDwQcuS6eeSZN9dLTUnSnZVk8eVCXdooCQ4'  认证鉴权通过后，请求的 header 中会被添加一个 X-Mse-Consumer 字段，在此例中其值为 consumer1，用以标识调用方的名称。 下列请求将拒绝访问 请求未提供 JWT，返回 401。 curl http://xxx.hello.com/test  根据请求提供的 JWT 匹配到的调用者无访问权限，返回 403。 ## consumer1 不在 *.example.com 的 allow 列表里 curl 'http://xxx.example.com/test' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMyJ9.eyJpc3MiOiJhYmNkIiwic3ViIjoidGVzdCIsImlhdCI6MTY2NTY2MDUyNywiZXhwIjoxODY1NjczODE5fQ.-vBSV0bKeDwQcuS6eeSZN9dLTUnSnZVk8eVCXdooCQ4'  ","version":"Next","tagName":"h3"},{"title":"常见错误码说明​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#常见错误码说明","content":"HTTP 状态码\t出错信息\t原因说明401\tJwt missing\t请求头未提供JWT 401\tJwt expired\tJWT已经过期 401\tJwt verification fails\tJWT payload校验失败，如iss不匹配 403\tAccess Denied\t无权限访问当前路由 ","version":"Next","tagName":"h3"},{"title":"机制说明​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#机制说明","content":"","version":"Next","tagName":"h2"},{"title":"1 基于 token 的认证​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#1-基于-token-的认证","content":"1.1 简介​ 很多对外开放的 API 需要识别请求者的身份，并据此判断所请求的资源是否可以返回给请求者。token 就是一种用于身份验证的机制，基于这种机制，应用不需要在服务端保留用户的认证信息或者会话信息，可实现无状态、分布式的 Web 应用授权，为应用的扩展提供了便利。 1.2 流程描述​  上图是网关利用 JWT 实现认证的整个业务流程时序图，下面我们用文字来详细描述图中标注的步骤： 客户端向 API 网关发起认证请求，请求中一般会携带终端用户的用户名和密码； 网关将请求直接转发给后端服务； 后端服务读取请求中的验证信息（比如用户名、密码）进行验证，验证通过后使用私钥生成标准的 token，返回给网关； 网关将携带 token 的应答返回给客户端，客户端需要将这个 token 缓存到本地； 客户端向 API 网关发送业务请求，请求中携带 token； 网关使用用户设定的公钥对请求中的 token 进行验证，验证通过后，将请求透传给后端服务； 后端服务进行业务处理后应答； 网关将业务应答返回给客户端。 在这个整个过程中, 网关利用 token 认证机制，实现了用户使用自己的用户体系对自己API进行授权的能力。下面我们就要介绍网关实现 token 认证所使用的结构化令牌 Json Web Token(JWT)。 1.3 JWT​ 1.3.1 简介​ Json Web Toke（JWT），是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准 RFC7519。JWT 一般可以用作独立的身份验证令牌，可以包含用户标识、用户角色和权限等信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，特别适用于分布式站点的登录场景。 1.3.2 JWT的构成​ eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 如上面的例子所示，JWT 就是一个字符串，由三部分构成： Header（头部）Payload（数据）Signature（签名） Header JWT 的头部承载两个信息： 声明类型，这里是 JWT声明加密的算法 网关支持的加密算法如下： ES256, ES384, ES512, HS256, HS384, HS512, RS256, RS384, RS512, PS256, PS384, PS512, EdDSA  完整的头部就像下面这样的 JSON： { 'typ': 'JWT', 'alg': 'HS256' }  然后将头部进行 Base64 编码（该编码是可以对称解码的），构成了第一部分。 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 Payload 载荷就是存放有效信息的地方。定义细节如下： iss：令牌颁发者。表示该令牌由谁创建，该声明是一个字符串 sub: Subject Identifier，iss 提供的终端用户的标识，在 iss 范围内唯一，最长为 255 个 ASCII 个字符，区分大小写 aud：Audience(s)，令牌的受众，分大小写的字符串数组 exp：Expiration time，令牌的过期时间戳。超过此时间的 token 会作废， 该声明是一个整数，是 1970 年 1 月 1 日以来的秒数 iat: 令牌的颁发时间，该声明是一个整数，是 1970 年 1 月 1 日以来的秒数 jti: 令牌的唯一标识，该声明的值在令牌颁发者创建的每一个令牌中都是唯一的，为了防止冲突，它通常是一个密码学随机值。这个值相当于向结构化令牌中加入了一个攻击者无法获得的随机熵组件，有利于防止令牌猜测攻击和重放攻击。  也可以新增用户系统需要使用的自定义字段，比如下面的例子添加了 name 用户昵称： { &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot; }  然后将其进行 Base64 编码，得到JWT的第二部分： JTdCJTBBJTIwJTIwJTIyc3ViJTIyJTNBJTIwJTIyMTIzNDU2Nzg5MCUyMiUyQyUwQSUyMCUyMCUyMm5hbWUlMjIlM0ElMjAlMjJKb2huJTIwRG9lJTIyJTBBJTdE Signature 这个部分需要 Base64 编码后的 Header 和 Base64 编码后的 Payload 使用 . 连接组成的字符串，然后通过 Header 中声明的加密方式进行加密（$secret 表示用户的私钥），然后就构成了 jwt 的第三部分。 var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload); var signature = HMACSHA256(encodedString, '$secret');  将这三部分用 . 连接成一个完整的字符串，就构成了 1.3.2 节最开始的 JWT 示例。 1.3.3 时效​ 网关会验证 token 中的 exp 字段，一旦这个字段过期了，网关会认为这个 token 无效而将请求直接打回。过期时间这个值必须设置。 1.3.4 JWT 的几个特点​ JWT 默认是不加密，不能将秘密数据写入 JWT。JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用HTTPS 协议传输。 ","version":"Next","tagName":"h3"},{"title":"2 用户系统如何应用 JWT 插件保护 API​","type":1,"pageTitle":"JWT 认证","url":"/zh-cn/docs/plugins/authentication/jwt-auth#2-用户系统如何应用-jwt-插件保护-api","content":"2.1 生成一对 JWK（JSON Web 密钥）​ 方法一、在线生成： 用户可以在这个站点https://mkjwk.org 生成用于 token 生成与验证的私钥与公钥， 私钥用于授权服务签发 JWT，公钥配置到 JWT 插件中用于网关对请求验签，注意网关使用的 jwks 格式配置，下图中Public Key需要放到keys结构体中，如：{&quot;keys&quot;:[{&quot;kty&quot;:&quot;RSA&quot;,&quot;e&quot;:&quot;AQAB&quot;,...}]}  方法二、本地生成： 本文应用 Java 示例说明，其他语言用户也可以找到相关的工具生成密钥对。 新建一个 Maven 项目，加入如下依赖： &lt;dependency&gt; &lt;groupId&gt;org.bitbucket.b_c&lt;/groupId&gt; &lt;artifactId&gt;jose4j&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt; &lt;/dependency&gt;  使用如下的代码生成一对RSA密钥： RsaJsonWebKey rsaJsonWebKey = RsaJwkGenerator.generateJwk(2048); final String publicKeyString = rsaJsonWebKey.toJson(JsonWebKey.OutputControlLevel.PUBLIC_ONLY); final String privateKeyString = rsaJsonWebKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE);  2.2 使用 JWK 中的私钥实现颁发 token 的认证服务​ 需要使用 2.1 节中在线生成的 Keypair JSON 字符串（三个方框内的第一个）或者本地生成的 privateKeyString JSON 字符串作为私钥来颁发 token，用于授权可信的用户访问受保护的 API，具体实现可以参考下方示例。 向客户颁发token的形式由用户根据具体的业务场景决定，可以将颁发token的功能部署到生产环境，配置成普通 API 后由访问者通过用户名密码获得，也可以直接在本地环境生成 token 后，直接拷贝给指定用户使用。 import java.security.PrivateKey; import org.jose4j.json.JsonUtil; import org.jose4j.jwk.RsaJsonWebKey; import org.jose4j.jwk.RsaJwkGenerator; import org.jose4j.jws.AlgorithmIdentifiers; import org.jose4j.jws.JsonWebSignature; import org.jose4j.jwt.JwtClaims; import org.jose4j.jwt.NumericDate; import org.jose4j.lang.JoseException; public class GenerateJwtDemo { public static void main(String[] args) throws JoseException { String keyId = &quot;uniq_key&quot;; //使用本文 2.1 节生成的 Keypair String privateKeyJson = &quot;{\\n&quot; + &quot; \\&quot;kty\\&quot;: \\&quot;RSA\\&quot;,\\n&quot; + &quot; \\&quot;d\\&quot;: &quot; + &quot;\\&quot;O9MJSOgcjjiVMNJ4jmBAh0mRHF_TlaVva70Imghtlgwxl8BLfcf1S8ueN1PD7xV6Cnq8YenSKsfiNOhC6yZ_fjW1syn5raWfj68eR7cjHWjLOvKjwVY33GBPNOvspNhVAFzeqfWneRTBbga53Agb6jjN0SUcZdJgnelzz5JNdOGaLzhacjH6YPJKpbuzCQYPkWtoZHDqWTzCSb4mJ3n0NRTsWy7Pm8LwG_Fd3pACl7JIY38IanPQDLoighFfo-Lriv5z3IdlhwbPnx0tk9sBwQBTRdZ8JkqqYkxUiB06phwr7mAnKEpQJ6HvhZBQ1cCnYZ_nIlrX9-I7qomrlE1UoQ\\&quot;,\\n&quot; + &quot; \\&quot;e\\&quot;: \\&quot;AQAB\\&quot;,\\n&quot; + &quot; \\&quot;alg\\&quot;: \\&quot;RS256\\&quot;,\\n&quot; + &quot; \\&quot;n\\&quot;: \\&quot;vCuB8MgwPZfziMSytEbBoOEwxsG7XI3MaVMoocziP4SjzU4IuWuE_DodbOHQwb_thUru57_Efe&quot; + &quot;--sfATHEa0Odv5ny3QbByqsvjyeHk6ZE4mSAV9BsHYa6GWAgEZtnDceeeDc0y76utXK2XHhC1Pysi2KG8KAzqDa099Yh7s31AyoueoMnrYTmWfEyDsQL_OAIiwgXakkS5U8QyXmWicCwXntDzkIMh8MjfPskesyli0XQD1AmCXVV3h2Opm1Amx0ggSOOiINUR5YRD6mKo49_cN-nrJWjtwSouqDdxHYP-4c7epuTcdS6kQHiQERBd1ejdpAxV4c0t0FHF7MOy9kw\\&quot;\\n&quot; + &quot;}&quot;; JwtClaims claims = new JwtClaims(); claims.setGeneratedJwtId(); claims.setIssuedAtToNow(); //过期时间一定要设置 NumericDate date = NumericDate.now(); date.addSeconds(120*60); claims.setExpirationTime(date); claims.setNotBeforeMinutesInThePast(1); claims.setSubject(&quot;YOUR_SUBJECT&quot;); claims.setAudience(&quot;YOUR_AUDIENCE&quot;); //添加自定义参数，所有值请都使用String类型 claims.setClaim(&quot;userId&quot;, &quot;1213234&quot;); claims.setClaim(&quot;email&quot;, &quot;userEmail@youapp.com&quot;); JsonWebSignature jws = new JsonWebSignature(); jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.RSA_USING_SHA256); jws.setKeyIdHeaderValue(keyId); jws.setPayload(claims.toJson()); PrivateKey privateKey = new RsaJsonWebKey(JsonUtil.parseJson(privateKeyJson)).getPrivateKey(); jws.setKey(privateKey); String jwtResult = jws.getCompactSerialization(); System.out.println(&quot;Generate Json Web token , result is &quot; + jwtResult); } }  ","version":"Next","tagName":"h3"},{"title":"AI Token 限流","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit","content":"","keywords":"higress ai rate-limit","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#功能说明","content":"ai-token-ratelimit 插件实现了基于特定键值实现 token 限流，键值来源可以是 URL 参数、HTTP 请求头、客户端 IP 地址、consumer 名称、cookie 中 key 名称。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#配置说明","content":"配置项\t数据类型\t必填\t默认值\t说明rule_name\tstring\t是\t-\t限流规则名称，根据限流规则名称 + 限流类型 + 限流 key 名称 + 限流 key 对应的实际值来拼装 redis key rule_items\tarray of object\t是\t-\t限流规则项，按照 rule_items 下的排列顺序，匹配第一个 rule_item 后命中限流规则，后续规则将被忽略 rejected_code\tint\t否\t429\t请求被限流时，返回的 HTTP 状态码 rejected_msg\tstring\t否\tToo many requests\t请求被限流时，返回的响应体 redis\tobject\t是\t-\tredis相关配置 rule_items 中每一项的配置字段说明。 配置项\t数据类型\t必填\t默认值\t说明limit_by_header\tstring\t否，limit_by_* 中选填一项\t-\t配置获取限流键值的来源 HTTP 请求头名称 limit_by_param\tstring\t否，limit_by_* 中选填一项\t-\t配置获取限流键值的来源 URL 参数名称 limit_by_consumer\tstring\t否，limit_by_* 中选填一项\t-\t根据 consumer 名称进行限流，无需添加实际值 limit_by_cookie\tstring\t否，limit_by_* 中选填一项\t-\t配置获取限流键值的来源 Cookie中 key 名称 limit_by_per_header\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 HTTP 请求头，并对每个请求头分别计算限流，配置获取限流键值的来源 HTTP 请求头名称，配置 limit_keys 时支持正则表达式或 * limit_by_per_param\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 URL 参数，并对每个参数分别计算限流，配置获取限流键值的来源 URL 参数名称，配置 limit_keys 时支持正则表达式或 * limit_by_per_consumer\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 consumer，并对每个 consumer 分别计算限流，根据 consumer 名称进行限流，无需添加实际值，配置limit_keys时支持正则表达式或* limit_by_per_cookie\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 Cookie，并对每个 Cookie 分别计算限流，配置获取限流键值的来源 Cookie 中 key 名称，配置 limit_keys 时支持正则表达式或* limit_by_per_ip\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 IP，并对每个 IP 分别计算限流，配置获取限流键值的来源 IP 参数名称，从请求头获取，以 from-header-对应的header名，示例：from-header-x-forwarded-for，直接获取对端 socket ip，配置为 from-remote-addr limit_keys\tarray of object\t是\t-\t配置匹配键值后的限流次数 limit_keys 中每一项的配置字段说明。 配置项\t数据类型\t必填\t默认值\t说明key\tstring\t是\t-\t匹配的键值，limit_by_per_header,limit_by_per_param,limit_by_per_consumer,limit_by_per_cookie 类型支持配置正则表达式（以 regexp: 开头后面跟正则表达式）或者 *（代表所有），正则表达式示例：regexp:^d.*（以d开头的所有字符串）；limit_by_per_ip 支持配置 IP 地址或 IP 段 token_per_second\tint\t否，token_per_second,token_per_minute,token_per_hour,token_per_day 中选填一项\t-\t允许每秒请求 token 数 token_per_minute\tint\t否，token_per_second,token_per_minute,token_per_hour,token_per_day 中选填一项\t-\t允许每分钟请求 token 数 token_per_hour\tint\t否，token_per_second,token_per_minute,token_per_hour,token_per_day 中选填一项\t-\t允许每小时请求 token 数 token_per_day\tint\t否，token_per_second,token_per_minute,token_per_hour,token_per_day 中选填一项\t-\t允许每天请求 token 数 redis 中每一项的配置字段说明。 配置项\t数据类型\t必填\t默认值\t说明service_name\tstring\t必填\t-\tredis 服务名称，带服务类型的完整 FQDN 名称，例如 my-redis.dns、redis.my-ns.svc.cluster.local service_port\tint\t否\t服务类型为固定地址（static service）默认值为 80，其他为 6379\t输入 redis 服务的服务端口 username\tstring\t否\t-\tredis 用户名 password\tstring\t否\t-\tredis 密码 timeout\tint\t否\t1000\tredis 连接超时时间，单位毫秒 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"识别请求参数 apikey，进行区别限流​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#识别请求参数-apikey进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_param: apikey limit_keys: - key: 9a342114-ba8a-11ec-b1bf-00163e1250b5 token_per_minute: 10 - key: a6a6d7f2-ba8a-11ec-bec2-00163e1250b5 token_per_hour: 100 - limit_by_per_param: apikey limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 apikey 对应的请求 10qds - key: &quot;regexp:^a.*&quot; token_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 apikey 对应的请求 100qd - key: &quot;regexp:^b.*&quot; token_per_minute: 100 # 兜底用，匹配所有请求，每个 apikey 对应的请求 1000qdh - key: &quot;*&quot; token_per_hour: 1000 redis: service_name: redis.static  ","version":"Next","tagName":"h3"},{"title":"识别请求头 x-ca-key，进行区别限流​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#识别请求头-x-ca-key进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_header: x-ca-key limit_keys: - key: 102234 token_per_minute: 10 - key: 308239 token_per_hour: 10 - limit_by_per_header: x-ca-key limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 apikey 对应的请求 10qds - key: &quot;regexp:^a.*&quot; token_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 apikey 对应的请求 100qd - key: &quot;regexp:^b.*&quot; token_per_minute: 100 # 兜底用，匹配所有请求，每个 apikey 对应的请求 1000qdh - key: &quot;*&quot; token_per_hour: 1000 redis: service_name: redis.static  ","version":"Next","tagName":"h3"},{"title":"根据请求头 x-forwarded-for 获取对端 IP，进行区别限流​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#根据请求头-x-forwarded-for-获取对端-ip进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_per_ip: from-header-x-forwarded-for limit_keys: # 精确 ip - key: 1.1.1.1 token_per_day: 10 # ip 段，符合这个 ip 段的 ip，每个 ip 100qpd - key: 1.1.1.0/24 token_per_day: 100 # 兜底用，即默认每个 ip 1000qpd - key: 0.0.0.0/0 token_per_day: 1000 redis: service_name: redis.static  ","version":"Next","tagName":"h3"},{"title":"识别 consumer，进行区别限流​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#识别-consumer进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_consumer: '' limit_keys: - key: consumer1 token_per_second: 10 - key: consumer2 token_per_hour: 100 - limit_by_per_consumer: '' limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 consumer 对应的请求 10qds - key: &quot;regexp:^a.*&quot; token_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 consumer 对应的请求 100qd - key: &quot;regexp:^b.*&quot; token_per_minute: 100 # 兜底用，匹配所有请求，每个 consumer 对应的请求 1000qdh - key: &quot;*&quot; token_per_hour: 1000 redis: service_name: redis.static  ","version":"Next","tagName":"h3"},{"title":"识别 cookie 中的键值对，进行区别限流​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#识别-cookie-中的键值对进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_cookie: key1 limit_keys: - key: value1 token_per_minute: 10 - key: value2 token_per_hour: 100 - limit_by_per_cookie: key1 limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 cookie 中的 value 对应的请求 10qds - key: &quot;regexp:^a.*&quot; token_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 cookie 中的 value 对应的请求 100qd - key: &quot;regexp:^b.*&quot; token_per_minute: 100 # 兜底用，匹配所有请求，每个 cookie 中的 value 对应的请求 1000qdh - key: &quot;*&quot; token_per_hour: 1000 rejected_code: 200 rejected_msg: '{&quot;code&quot;:-1,&quot;msg&quot;:&quot;Too many requests&quot;}' redis: service_name: redis.static  ","version":"Next","tagName":"h3"},{"title":"完整示例​","type":1,"pageTitle":"AI Token 限流","url":"/zh-cn/docs/plugins/ai/ai-token-ratelimit#完整示例","content":"AI Token 限流插件依赖 Redis 记录剩余可用的 token 数，因此首先需要部署 Redis 服务。 apiVersion: apps/v1 kind: Deployment metadata: name: redis labels: app: redis spec: replicas: 1 selector: matchLabels: app: redis template: metadata: labels: app: redis spec: containers: - name: redis image: redis ports: - containerPort: 6379 --- apiVersion: v1 kind: Service metadata: name: redis labels: app: redis spec: ports: - port: 6379 targetPort: 6379 selector: app: redis ---  在本例中，使用通义千问作为 AI 服务提供商。另外还需要设置 AI 统计插件，因为 AI Token 限流插件依赖 AI 统计插件计算每次请求消耗的 token 数，以下配置限制每分钟的 input 和 output token 总数为 200 个。 apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: ai-proxy namespace: higress-system spec: matchRules: - config: provider: type: qwen apiTokens: - &quot;&lt;YOUR_API_TOKEN&gt;&quot; modelMapping: 'gpt-3': &quot;qwen-turbo&quot; 'gpt-35-turbo': &quot;qwen-plus&quot; 'gpt-4-turbo': &quot;qwen-max&quot; '*': &quot;qwen-turbo&quot; ingress: - qwen url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-ai-proxy:v1.0.0 phase: UNSPECIFIED_PHASE priority: 100 --- apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: ai-statistics namespace: higress-system spec: defaultConfig: enable: true url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-ai-token-statistics:v1.0.0 phase: UNSPECIFIED_PHASE priority: 200 --- apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: ai-token-ratelimit namespace: higress-system spec: defaultConfig: rule_name: default_limit_by_param_apikey rule_items: - limit_by_param: apikey limit_keys: - key: 123456 token_per_minute: 200 redis: # 默认情况下，为了减轻数据面的压力，Higress 的 global.onlyPushRouteCluster 配置参数被设置为 true，意味着不会自动发现 Kubernetes Service # 如果需要使用 Kubernetes Service 作为服务发现，可以将 global.onlyPushRouteCluster 参数设置为 false， # 这样就可以直接将 service_name 设置为 Kubernetes Service, 而无须为 Redis 创建 McpBridge 以及 Ingress 路由 # service_name: redis.default.svc.cluster.local service_name: redis.dns service_port: 6379 url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-ai-token-ratelimit:v1.0.0 phase: UNSPECIFIED_PHASE priority: 600  注意，AI Token 限流插件中的 Redis 配置项 service_name 来自 McpBridge 中配置的服务来源，另外我们还需要在 McpBridge 中配置通义千问服务的访问地址。 apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: dashscope.aliyuncs.com name: qwen port: 443 type: dns - domain: redis.default.svc.cluster.local # Kubernetes Service name: redis type: dns port: 6379  分别创建两条路由规则。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/backend-protocol: HTTPS higress.io/destination: qwen.dns higress.io/proxy-ssl-name: dashscope.aliyuncs.com higress.io/proxy-ssl-server-name: &quot;on&quot; labels: higress.io/resource-definer: higress name: qwen namespace: higress-system spec: ingressClassName: higress rules: - host: qwen-test.com http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: redis.dns higress.io/ignore-path-case: &quot;false&quot; labels: higress.io/resource-definer: higress name: redis spec: ingressClassName: higress rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix  触发限流效果如下： curl &quot;http://qwen-test.com:18000/v1/chat/completions?apikey=123456&quot; -H &quot;Content-Type: application/json&quot; -d '{ &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;stream&quot;: false }' {&quot;id&quot;:&quot;88cfa80f-545d-93b4-8ff3-3f5245ca33ba&quot;,&quot;choices&quot;:[{&quot;index&quot;:0,&quot;message&quot;:{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:&quot;我是通义千问，由阿里云开发的AI助手。我可以回答各种问题、提供信息和与用户进行对话。有什么我可以帮助你的吗？&quot;},&quot;finish_reason&quot;:&quot;stop&quot;}],&quot;created&quot;:1719909825,&quot;model&quot;:&quot;qwen-turbo&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;usage&quot;:{&quot;prompt_tokens&quot;:13,&quot;completion_tokens&quot;:33,&quot;total_tokens&quot;:46}} curl &quot;http://qwen-test.com:18000/v1/chat/completions?apikey=123456&quot; -H &quot;Content-Type: application/json&quot; -d '{ &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;stream&quot;: false }' Too many requests # 限流成功  ","version":"Next","tagName":"h2"},{"title":"自定义插件","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/custom","content":"","keywords":"higress custom plugin","version":"Next"},{"title":"编辑 Wasm 文件​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#编辑-wasm-文件","content":"用于使用 Go 语言开发 Higress 的 Wasm 插件的SDK插件开发示例 ","version":"Next","tagName":"h2"},{"title":"构建 Wasm 镜像​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#构建-wasm-镜像","content":"你也可以选择先在本地将 wasm 构建出来，再拷贝到 Docker 镜像中。这要求你要先在本地搭建构建环境。 编译环境要求如下： Go 版本: &gt;= 1.18（需要支持泛型特性） TinyGo 版本: &gt;= 0.28.1（建议使用 0.28.1 ） 下面是本地步骤构建 request-block 插件的例子。 ","version":"Next","tagName":"h2"},{"title":"step1. 编译 wasm​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#step1-编译-wasm","content":"tinygo build -o main.wasm -scheduler=none -target=wasi -gc=custom -tags='custommalloc nottinygc_finalizer' ./main.go  ","version":"Next","tagName":"h3"},{"title":"step2. 构建并推送插件的 docker 镜像​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#step2-构建并推送插件的-docker-镜像","content":"使用这份简单的 Dockerfile FROM scratch COPY main.wasm plugin.wasm  docker build -t &lt;your_registry_hub&gt;/request-block:1.0.0 -f &lt;your_dockerfile&gt; . docker push &lt;your_registry_hub&gt;/request-block:1.0.0  ","version":"Next","tagName":"h3"},{"title":"生效 Wasm 插件​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#生效-wasm-插件","content":"","version":"Next","tagName":"h2"},{"title":"使用 Higress 控制台​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#使用-higress-控制台","content":"在插件市场中创建点击创建按钮，就可以创建自定义插件，在镜像地址一栏中填入上面构建出的 Wasm 镜像地址即可； 创建完成后，点击插件卡片的配置按钮，填入插件的配置（如果有），打开开启开关就生效了。 如果插件逻辑发生了变更，可以构建一个新的镜像，并使用不同的镜像 tag，点插件卡片右上方菜单中的编辑按钮，将 Wasm 镜像地址修改为新版本的地址即可。 ","version":"Next","tagName":"h3"},{"title":"使用 CRD​","type":1,"pageTitle":"自定义插件","url":"/zh-cn/docs/plugins/custom#使用-crd","content":"编写 WasmPlugin 资源如下： apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: request-block namespace: higress-system spec: defaultConfig: block_urls: - &quot;swagger.html&quot; url: oci://&lt;your_registry_hub&gt;/request-block:1.0.0 # 之前构建和推送的 image 地址  使用 kubectl apply -f &lt;your-wasm-plugin-yaml&gt; 使资源生效。 资源生效后，如果请求url携带 swagger.html, 则这个请求就会被拒绝，例如： curl &lt;your_gateway_address&gt;/api/user/swagger.html  HTTP/1.1 403 Forbidden date: Wed, 09 Nov 2022 12:12:32 GMT server: istio-envoy content-length: 0  ","version":"Next","tagName":"h3"},{"title":"AI 代理","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/ai/ai-proxy","content":"","keywords":"higress ai proxy","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#功能说明","content":"AI 代理插件实现了基于 OpenAI API 契约的 AI 代理功能。目前支持 OpenAI、Azure OpenAI、月之暗面（Moonshot）和通义千问等 AI 服务提供商。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#配置字段","content":"","version":"Next","tagName":"h2"},{"title":"基本配置​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#基本配置","content":"名称\t数据类型\t填写要求\t默认值\t描述provider\tobject\t必填\t-\t配置目标 AI 服务提供商的信息 provider的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述type\tstring\t必填\t-\tAI 服务提供商名称 apiTokens\tarray of string\t必填\t-\t用于在访问 AI 服务时进行认证的令牌。如果配置了多个 token，插件会在请求时随机进行选择。部分服务提供商只支持配置一个 token。 timeout\tnumber\t非必填\t-\t访问 AI 服务的超时时间。单位为毫秒。默认值为 120000，即 2 分钟 modelMapping\tmap of string\t非必填\t-\tAI 模型映射表，用于将请求中的模型名称映射为服务提供商支持模型名称。 可以使用 &quot;*&quot; 为键来配置通用兜底映射关系 protocol\tstring\t非必填\t-\t插件对外提供的 API 接口契约。目前支持以下取值：openai（默认值，使用 OpenAI 的接口契约）、original（使用目标服务提供商的原始接口契约） context\tobject\t非必填\t-\t配置 AI 对话上下文信息 context的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述fileUrl\tstring\t必填\t-\t保存 AI 对话上下文的文件 URL。仅支持纯文本类型的文件内容 serviceName\tstring\t必填\t-\tURL 所对应的 Higress 后端服务完整名称 servicePort\tnumber\t必填\t-\tURL 所对应的 Higress 后端服务访问端口 ","version":"Next","tagName":"h3"},{"title":"提供商特有配置​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#提供商特有配置","content":"OpenAI​ OpenAI 所对应的 type 为 openai。它并无特有的配置字段。 Azure OpenAI​ Azure OpenAI 所对应的 type 为 azure。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述azureServiceUrl\tstring\t必填\t-\tAzure OpenAI 服务的 URL，须包含 api-version 查询参数。 注意： Azure OpenAI 只支持配置一个 API Token。 月之暗面（Moonshot）​ 月之暗面所对应的 type 为 moonshot。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述moonshotFileId\tstring\t非必填\t-\t通过文件接口上传至月之暗面的文件 ID，其内容将被用做 AI 对话的上下文。不可与 context 字段同时配置。 通义千问（Qwen）​ 通义千问所对应的 type 为 qwen。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述qwenEnableSearch\tboolean\t非必填\t-\t是否启用通义千问内置的互联网搜索功能。 qwenFileIds\tarray of string\t非必填\t-\t通过文件接口上传至Dashscope的文件 ID，其内容将被用做 AI 对话的上下文。不可与 context 字段同时配置。 百川智能 (Baichuan AI)​ 百川智能所对应的 type 为 baichuan 。它并无特有的配置字段。 零一万物（Yi）​ 零一万物所对应的 type 为 yi。它并无特有的配置字段。 智谱AI（Zhipu AI）​ 智谱AI所对应的 type 为 zhipuai。它并无特有的配置字段。 DeepSeek（DeepSeek）​ DeepSeek所对应的 type 为 deepseek。它并无特有的配置字段。 Groq​ Groq 所对应的 type 为 groq。它并无特有的配置字段。 文心一言（Baidu）​ 文心一言所对应的 type 为 baidu。它并无特有的配置字段。 MiniMax​ MiniMax所对应的 type 为 minimax。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述minimaxGroupId\tstring\t当使用abab6.5-chat, abab6.5s-chat, abab5.5s-chat, abab5.5-chat四种模型时必填\t-\t当使用abab6.5-chat, abab6.5s-chat, abab5.5s-chat, abab5.5-chat四种模型时会使用ChatCompletion Pro，需要设置groupID Anthropic Claude​ Anthropic Claude 所对应的 type 为 claude。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述claudeVersion\tstring\t可选\t-\tClaude 服务的 API 版本，默认为 2023-06-01 Ollama​ Ollama 所对应的 type 为 ollama。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述ollamaServerHost\tstring\t必填\t-\tOllama 服务器的主机地址 ollamaServerPort\tnumber\t必填\t-\tOllama 服务器的端口号，默认为11434 混元​ 混元所对应的 type 为 hunyuan。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述hunyuanAuthId\tstring\t必填\t-\t混元用于v3版本认证的id hunyuanAuthKey\tstring\t必填\t-\t混元用于v3版本认证的key 阶跃星辰 (Stepfun)​ 阶跃星辰所对应的 type 为 stepfun。它并无特有的配置字段。 Cloudflare Workers AI​ Cloudflare Workers AI 所对应的 type 为 cloudflare。它特有的配置字段如下： 名称\t数据类型\t填写要求\t默认值\t描述cloudflareAccountId\tstring\t必填\t-\tCloudflare Account ID ","version":"Next","tagName":"h3"},{"title":"用法示例​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#用法示例","content":"","version":"Next","tagName":"h2"},{"title":"使用 OpenAI 协议代理 Azure OpenAI 服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理-azure-openai-服务","content":"使用最基本的 Azure OpenAI 服务，不配置任何上下文。 配置信息 provider: type: azure apiTokens: - &quot;YOUR_AZURE_OPENAI_API_TOKEN&quot; azureServiceUrl: &quot;https://YOUR_RESOURCE_NAME.openai.azure.com/openai/deployments/YOUR_DEPLOYMENT_NAME/chat/completions?api-version=2024-02-15-preview&quot;,  请求示例 { &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;temperature&quot;: 0.3 }  响应示例 { &quot;choices&quot;: [ { &quot;content_filter_results&quot;: { &quot;hate&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; }, &quot;self_harm&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; }, &quot;sexual&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; }, &quot;violence&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; } }, &quot;finish_reason&quot;: &quot;stop&quot;, &quot;index&quot;: 0, &quot;logprobs&quot;: null, &quot;message&quot;: { &quot;content&quot;: &quot;你好！我是一个AI助手，可以回答你的问题和提供帮助。有什么我可以帮到你的吗？&quot;, &quot;role&quot;: &quot;assistant&quot; } } ], &quot;created&quot;: 1714807624, &quot;id&quot;: &quot;chatcmpl-abcdefg1234567890&quot;, &quot;model&quot;: &quot;gpt-35-turbo-16k&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;prompt_filter_results&quot;: [ { &quot;prompt_index&quot;: 0, &quot;content_filter_results&quot;: { &quot;hate&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; }, &quot;self_harm&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; }, &quot;sexual&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; }, &quot;violence&quot;: { &quot;filtered&quot;: false, &quot;severity&quot;: &quot;safe&quot; } } } ], &quot;system_fingerprint&quot;: null, &quot;usage&quot;: { &quot;completion_tokens&quot;: 40, &quot;prompt_tokens&quot;: 15, &quot;total_tokens&quot;: 55 } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理通义千问服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理通义千问服务","content":"使用通义千问服务，并配置从 OpenAI 大模型到通义千问的模型映射关系。 配置信息 provider: type: qwen apiTokens: - &quot;YOUR_QWEN_API_TOKEN&quot; modelMapping: 'gpt-3': &quot;qwen-turbo&quot; 'gpt-35-turbo': &quot;qwen-plus&quot; 'gpt-4-turbo': &quot;qwen-max&quot; '*': &quot;qwen-turbo&quot;  请求示例 { &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;temperature&quot;: 0.3 }  响应示例 { &quot;id&quot;: &quot;c2518bd3-0f46-97d1-be34-bb5777cb3108&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;我是通义千问，由阿里云开发的AI助手。我可以回答各种问题、提供信息和与用户进行对话。有什么我可以帮助你的吗？&quot; }, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;created&quot;: 1715175072, &quot;model&quot;: &quot;qwen-turbo&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;usage&quot;: { &quot;prompt_tokens&quot;: 24, &quot;completion_tokens&quot;: 33, &quot;total_tokens&quot;: 57 } }  ","version":"Next","tagName":"h3"},{"title":"使用通义千问配合纯文本上下文信息​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用通义千问配合纯文本上下文信息","content":"使用通义千问服务，同时配置纯文本上下文信息。 配置信息 provider: type: qwen apiTokens: - &quot;YOUR_QWEN_API_TOKEN&quot; modelMapping: &quot;*&quot;: &quot;qwen-turbo&quot; context: - fileUrl: &quot;http://file.default.svc.cluster.local/ai/context.txt&quot;, serviceName: &quot;file.dns&quot;, servicePort: 80  请求示例 { &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;请概述文案内容&quot; } ], &quot;temperature&quot;: 0.3 }  响应示例 { &quot;id&quot;: &quot;cmpl-77861a17681f4987ab8270dbf8001936&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 9756990, &quot;model&quot;: &quot;moonshot-v1-128k&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;这份文案是一份关于...&quot; }, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;usage&quot;: { &quot;prompt_tokens&quot;: 20181, &quot;completion_tokens&quot;: 439, &quot;total_tokens&quot;: 20620 } }  ","version":"Next","tagName":"h3"},{"title":"使用通义千问配合其原生的文件上下文​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用通义千问配合其原生的文件上下文","content":"提前上传文件至通义千问，以文件内容作为上下文使用其 AI 服务。 配置信息 provider: type: qwen apiTokens: - &quot;YOUR_QWEN_API_TOKEN&quot; modelMapping: &quot;*&quot;: &quot;qwen-long&quot; # 通义千问的文件上下文只能在 qwen-long 模型下使用 qwenFileIds: - &quot;file-fe-xxx&quot; - &quot;file-fe-yyy&quot;  请求示例 { &quot;model&quot;: &quot;gpt-4-turbo&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;请概述文案内容&quot; } ], &quot;temperature&quot;: 0.3 }  响应示例 { &quot;output&quot;: { &quot;choices&quot;: [ { &quot;finish_reason&quot;: &quot;stop&quot;, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;您上传了两个文件，`context.txt` 和 `context_2.txt`，它们似乎都包含了关于xxxx&quot; } } ] }, &quot;usage&quot;: { &quot;total_tokens&quot;: 2023, &quot;output_tokens&quot;: 530, &quot;input_tokens&quot;: 1493 }, &quot;request_id&quot;: &quot;187e99ba-5b64-9ffe-8f69-01dafbaf6ed7&quot; }  ","version":"Next","tagName":"h3"},{"title":"使用月之暗面配合其原生的文件上下文​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用月之暗面配合其原生的文件上下文","content":"提前上传文件至月之暗面，以文件内容作为上下文使用其 AI 服务。 配置信息 provider: type: moonshot apiTokens: - &quot;YOUR_MOONSHOT_API_TOKEN&quot; moonshotFileId: &quot;YOUR_MOONSHOT_FILE_ID&quot;, modelMapping: '*': &quot;moonshot-v1-32k&quot;  请求示例 { &quot;model&quot;: &quot;gpt-4-turbo&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;请概述文案内容&quot; } ], &quot;temperature&quot;: 0.3 }  响应示例 { &quot;id&quot;: &quot;cmpl-e5ca873642ca4f5d8b178c1742f9a8e8&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 1872961, &quot;model&quot;: &quot;moonshot-v1-128k&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;文案内容是关于一个名为“xxxx”的支付平台...&quot; }, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;usage&quot;: { &quot;prompt_tokens&quot;: 11, &quot;completion_tokens&quot;: 498, &quot;total_tokens&quot;: 509 } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理 Groq 服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理-groq-服务","content":"配置信息 provider: type: groq apiTokens: - &quot;YOUR_GROQ_API_TOKEN&quot;  请求示例 { &quot;model&quot;: &quot;llama3-8b-8192&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ] }  响应示例 { &quot;id&quot;: &quot;chatcmpl-26733989-6c52-4056-b7a9-5da791bd7102&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 1715917967, &quot;model&quot;: &quot;llama3-8b-8192&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;😊 Ni Hao! (That's \\&quot;hello\\&quot; in Chinese!)\\n\\nI am LLaMA, an AI assistant developed by Meta AI that can understand and respond to human input in a conversational manner. I'm not a human, but a computer program designed to simulate conversations and answer questions to the best of my ability. I'm happy to chat with you in Chinese or help with any questions or topics you'd like to discuss! 😊&quot; }, &quot;logprobs&quot;: null, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;usage&quot;: { &quot;prompt_tokens&quot;: 16, &quot;prompt_time&quot;: 0.005, &quot;completion_tokens&quot;: 89, &quot;completion_time&quot;: 0.104, &quot;total_tokens&quot;: 105, &quot;total_time&quot;: 0.109 }, &quot;system_fingerprint&quot;: &quot;fp_dadc9d6142&quot;, &quot;x_groq&quot;: { &quot;id&quot;: &quot;req_01hy2awmcxfpwbq56qh6svm7qz&quot; } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理 Claude 服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理-claude-服务","content":"配置信息 provider: type: claude apiTokens: - &quot;YOUR_CLAUDE_API_TOKEN&quot; claudeVersion: &quot;2023-06-01&quot; modelMapping&quot;: - &quot;gpt-3&quot;: &quot;claude-3-opus-20240229&quot;, - &quot;*&quot;: &quot;claude-3-sonnet-20240229&quot;  请求示例 { &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ] }  响应示例 { &quot;id&quot;: &quot;msg_01Jt3GzyjuzymnxmZERJguLK&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;您好,我是一个由人工智能公司Anthropic开发的聊天助手。我的名字叫Claude,是一个聪明友善、知识渊博的对话系统。很高兴认识您!我可以就各种话题与您聊天,回答问题,提供建议和帮助。我会尽最大努力给您有帮助的回复。希望我们能有个愉快的交流!&quot; }, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;created&quot;: 1717385918, &quot;model&quot;: &quot;claude-3-opus-20240229&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;usage&quot;: { &quot;prompt_tokens&quot;: 16, &quot;completion_tokens&quot;: 126, &quot;total_tokens&quot;: 142 } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理混元服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理混元服务","content":"配置信息 provider: type: &quot;hunyuan&quot; hunyuanAuthKey: &quot;&lt;YOUR AUTH KEY&gt;&quot; apiTokens: - &quot;&quot; hunyuanAuthId: &quot;&lt;YOUR AUTH ID&gt;&quot; timeout: 1200000 modelMapping: &quot;*&quot;: &quot;hunyuan-lite&quot;  请求示例请求脚本：  curl --location 'http://&lt;your higress domain&gt;/v1/chat/completions' \\ --header 'Content-Type: application/json' \\ --data '{ &quot;model&quot;: &quot;gpt-3&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;你是一个名专业的开发人员！&quot; }, { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;temperature&quot;: 0.3, &quot;stream&quot;: false }'  响应示例 { &quot;id&quot;: &quot;fd140c3e-0b69-4b19-849b-d354d32a6162&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;delta&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;你好！我是一名专业的开发人员。&quot; }, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;created&quot;: 1717493117, &quot;model&quot;: &quot;hunyuan-lite&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;usage&quot;: { &quot;prompt_tokens&quot;: 15, &quot;completion_tokens&quot;: 9, &quot;total_tokens&quot;: 24 } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理百度文心一言服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理百度文心一言服务","content":"配置信息 provider: type: baidu apiTokens: - &quot;YOUR_BAIDU_API_TOKEN&quot; modelMapping: 'gpt-3': &quot;ERNIE-4.0&quot; '*': &quot;ERNIE-4.0&quot;  请求示例 { &quot;model&quot;: &quot;gpt-4-turbo&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;stream&quot;: false }  响应示例 { &quot;id&quot;: &quot;as-e90yfg1pk1&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;你好，我是文心一言，英文名是ERNIE Bot。我能够与人对话互动，回答问题，协助创作，高效便捷地帮助人们获取信息、知识和灵感。&quot; }, &quot;finish_reason&quot;: &quot;stop&quot; } ], &quot;created&quot;: 1717251488, &quot;model&quot;: &quot;ERNIE-4.0&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;usage&quot;: { &quot;prompt_tokens&quot;: 4, &quot;completion_tokens&quot;: 33, &quot;total_tokens&quot;: 37 } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理MiniMax服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理minimax服务","content":"配置信息 provider: type: minimax apiTokens: - &quot;YOUR_MINIMAX_API_TOKEN&quot; modelMapping: &quot;gpt-3&quot;: &quot;abab6.5g-chat&quot; &quot;gpt-4&quot;: &quot;abab6.5-chat&quot; &quot;*&quot;: &quot;abab6.5g-chat&quot; minimaxGroupId: &quot;YOUR_MINIMAX_GROUP_ID&quot;  请求示例 { &quot;model&quot;: &quot;gpt-4-turbo&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ], &quot;stream&quot;: false }  响应示例 { &quot;id&quot;: &quot;02b2251f8c6c09d68c1743f07c72afd7&quot;, &quot;choices&quot;: [ { &quot;finish_reason&quot;: &quot;stop&quot;, &quot;index&quot;: 0, &quot;message&quot;: { &quot;content&quot;: &quot;你好！我是MM智能助理，一款由MiniMax自研的大型语言模型。我可以帮助你解答问题，提供信息，进行对话等。有什么可以帮助你的吗？&quot;, &quot;role&quot;: &quot;assistant&quot; } } ], &quot;created&quot;: 1717760544, &quot;model&quot;: &quot;abab6.5s-chat&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;usage&quot;: { &quot;total_tokens&quot;: 106 }, &quot;input_sensitive&quot;: false, &quot;output_sensitive&quot;: false, &quot;input_sensitive_type&quot;: 0, &quot;output_sensitive_type&quot;: 0, &quot;base_resp&quot;: { &quot;status_code&quot;: 0, &quot;status_msg&quot;: &quot;&quot; } }  ","version":"Next","tagName":"h3"},{"title":"使用 OpenAI 协议代理 Cloudflare Workers AI 服务​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#使用-openai-协议代理-cloudflare-workers-ai-服务","content":"配置信息 provider: type: cloudflare apiTokens: - &quot;YOUR_WORKERS_AI_API_TOKEN&quot; cloudflareAccountId: &quot;YOUR_CLOUDFLARE_ACCOUNT_ID&quot; modelMapping: &quot;*&quot;: &quot;@cf/meta/llama-3-8b-instruct&quot;  请求示例 { &quot;model&quot;: &quot;gpt-3.5&quot;, &quot;max_tokens&quot;: 1024, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Who are you?&quot; } ] }  响应示例 { &quot;id&quot;: &quot;id-1720367803430&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 1720367803, &quot;model&quot;: &quot;@cf/meta/llama-3-8b-instruct&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;I am LLaMA, an AI assistant developed by Meta AI that can understand and respond to human input in a conversational manner. I'm not a human, but a computer program designed to simulate conversation and answer questions to the best of my knowledge. I can be used to generate text on a wide range of topics, from science and history to entertainment and culture.\\n\\nI'm a large language model, which means I've been trained on a massive dataset of text from the internet and can generate human-like responses. I can understand natural language and respond accordingly, making me suitable for tasks such as:\\n\\n* Answering questions on various topics\\n* Generating text based on a given prompt\\n* Translating text from one language to another\\n* Summarizing long pieces of text\\n* Creating chatbot dialogues\\n\\nI'm constantly learning and improving, so the more conversations I have with users like you, the better I'll become.&quot; }, &quot;logprobs&quot;: null, &quot;finish_reason&quot;: &quot;stop&quot; } ] }  ","version":"Next","tagName":"h3"},{"title":"完整配置示例​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#完整配置示例","content":"","version":"Next","tagName":"h2"},{"title":"Kubernetes 示例​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#kubernetes-示例","content":"以下以使用 OpenAI 协议代理 Groq 服务为例，展示完整的插件配置示例。 apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: ai-proxy-groq namespace: higress-system spec: matchRules: - config: provider: type: groq apiTokens: - &quot;YOUR_API_TOKEN&quot; ingress: - groq url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/ai-proxy:1.0.0 --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/backend-protocol: HTTPS higress.io/destination: groq.dns higress.io/proxy-ssl-name: api.groq.com higress.io/proxy-ssl-server-name: &quot;on&quot; labels: higress.io/resource-definer: higress name: groq namespace: higress-system spec: ingressClassName: higress rules: - host: &lt;YOUR-DOMAIN&gt; http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix --- apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: api.groq.com name: groq port: 443 type: dns  访问示例： curl &quot;http://&lt;YOUR-DOMAIN&gt;/v1/chat/completions&quot; -H &quot;Content-Type: application/json&quot; -d '{ &quot;model&quot;: &quot;llama3-8b-8192&quot;, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ] }'  ","version":"Next","tagName":"h3"},{"title":"Docker-Compose 示例​","type":1,"pageTitle":"AI 代理","url":"/zh-cn/docs/plugins/ai/ai-proxy#docker-compose-示例","content":"docker-compose.yml 配置文件： version: '3.7' services: envoy: image: higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/envoy:1.20 entrypoint: /usr/local/bin/envoy # 开启了 debug 级别日志方便调试 command: -c /etc/envoy/envoy.yaml --component-log-level wasm:debug networks: - higress-net ports: - &quot;10000:10000&quot; volumes: - ./envoy.yaml:/etc/envoy/envoy.yaml - ./plugin.wasm:/etc/envoy/plugin.wasm networks: higress-net: {}  envoy.yaml 配置文件： admin: address: socket_address: protocol: TCP address: 0.0.0.0 port_value: 9901 static_resources: listeners: - name: listener_0 address: socket_address: protocol: TCP address: 0.0.0.0 port_value: 10000 filter_chains: - filters: - name: envoy.filters.network.http_connection_manager typed_config: &quot;@type&quot;: type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager scheme_header_transformation: scheme_to_overwrite: https stat_prefix: ingress_http # Output envoy logs to stdout access_log: - name: envoy.access_loggers.stdout typed_config: &quot;@type&quot;: type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog # Modify as required route_config: name: local_route virtual_hosts: - name: local_service domains: [ &quot;*&quot; ] routes: - match: prefix: &quot;/&quot; route: cluster: claude timeout: 300s http_filters: - name: claude typed_config: &quot;@type&quot;: type.googleapis.com/udpa.type.v1.TypedStruct type_url: type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm value: config: name: claude vm_config: runtime: envoy.wasm.runtime.v8 code: local: filename: /etc/envoy/plugin.wasm configuration: &quot;@type&quot;: &quot;type.googleapis.com/google.protobuf.StringValue&quot; value: | # 插件配置 { &quot;provider&quot;: { &quot;type&quot;: &quot;claude&quot;, &quot;apiTokens&quot;: [ &quot;YOUR_API_TOKEN&quot; ] } } - name: envoy.filters.http.router clusters: - name: claude connect_timeout: 30s type: LOGICAL_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN load_assignment: cluster_name: claude endpoints: - lb_endpoints: - endpoint: address: socket_address: address: api.anthropic.com # API 服务地址 port_value: 443 transport_socket: name: envoy.transport_sockets.tls typed_config: &quot;@type&quot;: type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext &quot;sni&quot;: &quot;api.anthropic.com&quot;  访问示例： curl &quot;http://localhost:10000/v1/chat/completions&quot; -H &quot;Content-Type: application/json&quot; -d '{ &quot;model&quot;: &quot;claude-3-opus-20240229&quot;, &quot;max_tokens&quot;: 1024, &quot;messages&quot;: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; } ] }'  ","version":"Next","tagName":"h3"},{"title":"OIDC 认证","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/authentication/oidc","content":"","keywords":"higress auth","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"OIDC 认证","url":"/zh-cn/docs/plugins/authentication/oidc#功能说明","content":"oidc 插件实现了 OIDC 认证能力, 插件目前存在的 CSRF 攻击问题，不建议用于生产环境。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"OIDC 认证","url":"/zh-cn/docs/plugins/authentication/oidc#配置字段","content":"字段\t数据类型\t填写要求\t默认值\t描述issuer\tstring\t必填\t-\t设置认证服务的 issuer ，即签发人。 client_id\tstring\t必填\t-\t输入服务注册的应用 ID 。 client_secret\tstring\t必填\t-\t输入服务注册的应用 Secret 。 redirect_url\tstring\t必填\t-\t输入授权成功后的重定向地址，需要与 OIDC 中配置的重定向地址保持一致。该地址的后缀需为 (oauth2/callback)。 client_url\tstring\t必填\t-\t登陆成功跳转后的地址，如果未跳转成功，请检查设置的 cookiename 是否重复。 scopes\tArray\t必填\t-\t输入授权作用域的数组。 skip_expiry_check\tbool\t选填\tfalse\t控制是否检测 IDToken 的过期状态。 skip_nonce_check\tbool\t选填\ttrue\t控制是否检测 Nonce 值。 timeout_millis\tint\t选填\t500\t设置请求与认证服务连接的超时时长。如果频繁遇到超时错误，建议增加该时长。 cookie_name\tstring\t选填\t&quot;_oidc_wasm&quot;\t设置 cookie 的名称, 如果一个域名下多个路由设置不同的认证服务，建议设置不同名称。 cookie_domain\tstring\t必填\t-\t设置 cookie 的域名。 cookie_path\tstring\t选填\t&quot;/&quot;\t设置 cookie 的存储路径。 cookie_secure\tbool\t选填\tfalse\t控制 cookie 是否只在 HTTPS 下传输。 cookie_httponly\tbool\t选填\ttrue\t控制 cookie 是否仅限于 HTTP 传输，禁止JavaScript访问。 cookie_samesite\tstring\t选填\t&quot;Lax&quot;\t设置 cookie 的 SameSite 属性，如：&quot;Lax&quot;, &quot;none&quot;。第三方跳转一般建议默认设置为Lax service_source\tstring\t必填\t-\t类型为固定 ip 或者 DNS ,输入认证 oidc 服务的注册来源。 service_name\tstring\t必填\t-\t输入认证 oidc 服务的注册名称。 service_port\tint\t必填\t-\t输入认证 oidc 服务的服务端口。 service_host\tstring\t必填\t-\t当类型为固定ip时必须填写,输入认证 oidc 服务的主机名。 service_domain\tstring\t必填\t-\t当类型为DNS时必须填写，输入认证 oidc 服务的domain。 这是一个用于 OIDC 认证配置的表格，确保在提供所有必要的信息时遵循上述指导。 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"OIDC 认证","url":"/zh-cn/docs/plugins/authentication/oidc#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"固定 IP​","type":1,"pageTitle":"OIDC 认证","url":"/zh-cn/docs/plugins/authentication/oidc#固定-ip","content":"issuer: &quot;http://127.0.0.1:9090/realms/myrealm&quot; redirect_url: &quot;http://foo.bar.com/bar/oauth2/callback&quot; client_url: &quot;http://foo.bar.com/&quot; scopes: - &quot;openid&quot; - &quot;email&quot; cookie_name: &quot;_oauth2_wasm_keyclocak&quot; cookie_domain: &quot;foo.bar.com&quot; client_id: &quot;xxxxxxxxxxxx&quot; client_secret: &quot;xxxxxxxxxxxxxx&quot; service_host: &quot;127.0.0.1:9090&quot; service_name: &quot;keyclocak&quot; service_port: 80 service_source: &quot;ip&quot;  ","version":"Next","tagName":"h3"},{"title":"DNS域名​","type":1,"pageTitle":"OIDC 认证","url":"/zh-cn/docs/plugins/authentication/oidc#dns域名","content":"在服务来源中注册好服务后，创建对应的 ingress。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: example-ingress annotations: higress.io/destination: okta.dns higress.io/backend-protocol: &quot;HTTPS&quot; higress.io/ignore-path-case: &quot;false&quot; spec: ingressClassName: higress rules: - host: foo.bar.com http: paths: - path: / pathType: Prefix backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default  ","version":"Next","tagName":"h3"},{"title":"创建 Wasm 插件​","type":1,"pageTitle":"OIDC 认证","url":"/zh-cn/docs/plugins/authentication/oidc#创建-wasm-插件","content":"issuer: &quot;https://dev-65874123.okta.com&quot; redirect_url: &quot;http://foo.bar.com/a/oauth2/callback&quot; scopes: - &quot;openid&quot; - &quot;email&quot; client_url: &quot;http://foo.bar.com/a&quot; cookie_domain: &quot;foo.bar.com&quot; client_id: &quot;xxxxxxxxxxxxxxx&quot; client_secret: &quot;xxxxxxx&quot; service_domain: &quot;dev-65874123.okta.com&quot; service_name: &quot;okta&quot; service_port: 443 service_source: &quot;dns&quot; timeout_millis: 2000  在通过插件验证后会携带 Authorization的标头携带令牌。 ","version":"Next","tagName":"h3"},{"title":"机器人拦截","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/security/bot-detect","content":"","keywords":"higress bot detect","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"机器人拦截","url":"/zh-cn/docs/plugins/security/bot-detect#功能说明","content":"bot-detect 插件可以用于识别并阻止互联网爬虫对站点资源的爬取。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"机器人拦截","url":"/zh-cn/docs/plugins/security/bot-detect#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述allow\tarray of string\t选填\t-\t配置匹配 User-Agent 请求头的正则表达式，匹配命中时将允许其访问 deny\tarray of string\t选填\t-\t配置匹配 User-Agent 请求头的正则表达式，匹配命中时将屏蔽请求 blocked_code\tnumber\t选填\t403\t配置请求被屏蔽时返回的 HTTP 状态码 blocked_message\tstring\t选填\t-\t配置请求被屏蔽时返回的 HTTP 应答 Body allow 和 deny 字段可以均不配置，则执行默认的爬虫判断逻辑，通过配置 allow 字段可以将原本命中默认爬虫判断逻辑的请求放行，通过配置 deny 字段可以增加额外的爬虫判断逻辑。 默认的爬虫判断正则表达式集合如下： # Bots General matcher 'name/0.0' (?:\\/[A-Za-z0-9\\.]+|) {0,5}([A-Za-z0-9 \\-_\\!\\[\\]:]{0,50}(?:[Aa]rchiver|[Ii]ndexer|[Ss]craper|[Bb]ot|[Ss]pider|[Cc]rawl[a-z]{0,50}))[/ ](\\d+)(?:\\.(\\d+)(?:\\.(\\d+)|)|) # Bots General matcher 'name 0.0' (?:\\/[A-Za-z0-9\\.]+|) {0,5}([A-Za-z0-9 \\-_\\!\\[\\]:]{0,50}(?:[Aa]rchiver|[Ii]ndexer|[Ss]craper|[Bb]ot|[Ss]pider|[Cc]rawl[a-z]{0,50})) (\\d+)(?:\\.(\\d+)(?:\\.(\\d+)|)|) # Bots containing spider|scrape|bot(but not CUBOT)|Crawl ((?:[A-z0-9]{1,50}|[A-z\\-]{1,50} ?|)(?: the |)(?:[Ss][Pp][Ii][Dd][Ee][Rr]|[Ss]crape|[Cc][Rr][Aa][Ww][Ll])[A-z0-9]{0,50})(?:(?:[ /]| v)(\\d+)(?:\\.(\\d+)|)(?:\\.(\\d+)|)|) # Bots Pattern '/name-0.0' /((?:Ant-)?Nutch|[A-z]+[Bb]ot|[A-z]+[Ss]pider|Axtaris|fetchurl|Isara|ShopSalad|Tailsweep)[ \\-](\\d+)(?:\\.(\\d+)(?:\\.(\\d+))?)? # Bots Pattern 'name/0.0' \\b(008|Altresium|Argus|BaiduMobaider|BoardReader|DNSGroup|DataparkSearch|EDI|Goodzer|Grub|INGRID|Infohelfer|LinkedInBot|LOOQ|Nutch|OgScrper|PathDefender|Peew|PostPost|Steeler|Twitterbot|VSE|WebCrunch|WebZIP|Y!J-BR[A-Z]|YahooSeeker|envolk|sproose|wminer)/(\\d+)(?:\\.(\\d+)|)(?:\\.(\\d+)|) # More bots (CSimpleSpider|Cityreview Robot|CrawlDaddy|CrawlFire|Finderbots|Index crawler|Job Roboter|KiwiStatus Spider|Lijit Crawler|QuerySeekerSpider|ScollSpider|Trends Crawler|USyd-NLP-Spider|SiteCat Webbot|BotName\\/\\$BotVersion|123metaspider-Bot|1470\\.net crawler|50\\.nu|8bo Crawler Bot|Aboundex|Accoona-[A-z]{1,30}-Agent|AdsBot-Google(?:-[a-z]{1,30}|)|altavista|AppEngine-Google|archive.{0,30}\\.org_bot|archiver|Ask Jeeves|[Bb]ai[Dd]u[Ss]pider(?:-[A-Za-z]{1,30})(?:-[A-Za-z]{1,30}|)|bingbot|BingPreview|blitzbot|BlogBridge|Bloglovin|BoardReader Blog Indexer|BoardReader Favicon Fetcher|boitho.com-dc|BotSeer|BUbiNG|\\b\\w{0,30}favicon\\w{0,30}\\b|\\bYeti(?:-[a-z]{1,30}|)|Catchpoint(?: bot|)|[Cc]harlotte|Checklinks|clumboot|Comodo HTTP\\(S\\) Crawler|Comodo-Webinspector-Crawler|ConveraCrawler|CRAWL-E|CrawlConvera|Daumoa(?:-feedfetcher|)|Feed Seeker Bot|Feedbin|findlinks|Flamingo_SearchEngine|FollowSite Bot|furlbot|Genieo|gigabot|GomezAgent|gonzo1|(?:[a-zA-Z]{1,30}-|)Googlebot(?:-[a-zA-Z]{1,30}|)|Google SketchUp|grub-client|gsa-crawler|heritrix|HiddenMarket|holmes|HooWWWer|htdig|ia_archiver|ICC-Crawler|Icarus6j|ichiro(?:/mobile|)|IconSurf|IlTrovatore(?:-Setaccio|)|InfuzApp|Innovazion Crawler|InternetArchive|IP2[a-z]{1,30}Bot|jbot\\b|KaloogaBot|Kraken|Kurzor|larbin|LEIA|LesnikBot|Linguee Bot|LinkAider|LinkedInBot|Lite Bot|Llaut|lycos|Mail\\.RU_Bot|masscan|masidani_bot|Mediapartners-Google|Microsoft .{0,30} Bot|mogimogi|mozDex|MJ12bot|msnbot(?:-media {0,2}|)|msrbot|Mtps Feed Aggregation System|netresearch|Netvibes|NewsGator[^/]{0,30}|^NING|Nutch[^/]{0,30}|Nymesis|ObjectsSearch|OgScrper|Orbiter|OOZBOT|PagePeeker|PagesInventory|PaxleFramework|Peeplo Screenshot Bot|PlantyNet_WebRobot|Pompos|Qwantify|Read%20Later|Reaper|RedCarpet|Retreiver|Riddler|Rival IQ|scooter|Scrapy|Scrubby|searchsight|seekbot|semanticdiscovery|SemrushBot|Simpy|SimplePie|SEOstats|SimpleRSS|SiteCon|Slackbot-LinkExpanding|Slack-ImgProxy|Slurp|snappy|Speedy Spider|Squrl Java|Stringer|TheUsefulbot|ThumbShotsBot|Thumbshots\\.ru|Tiny Tiny RSS|Twitterbot|WhatsApp|URL2PNG|Vagabondo|VoilaBot|^vortex|Votay bot|^voyager|WASALive.Bot|Web-sniffer|WebThumb|WeSEE:[A-z]{1,30}|WhatWeb|WIRE|WordPress|Wotbox|www\\.almaden\\.ibm\\.com|Xenu(?:.s|) Link Sleuth|Xerka [A-z]{1,30}Bot|yacy(?:bot|)|YahooSeeker|Yahoo! Slurp|Yandex\\w{1,30}|YodaoBot(?:-[A-z]{1,30}|)|YottaaMonitor|Yowedo|^Zao|^Zao-Crawler|ZeBot_www\\.ze\\.bz|ZooShot|ZyBorg)(?:[ /]v?(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)|)|)|)  ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"机器人拦截","url":"/zh-cn/docs/plugins/security/bot-detect#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"放行原本命中爬虫规则的请求​","type":1,"pageTitle":"机器人拦截","url":"/zh-cn/docs/plugins/security/bot-detect#放行原本命中爬虫规则的请求","content":"allow: - &quot;.*Go-http-client.*&quot;  若不作该配置，默认的 Golang 网络库请求会被视做爬虫，被禁止访问。 ","version":"Next","tagName":"h3"},{"title":"增加爬虫判断​","type":1,"pageTitle":"机器人拦截","url":"/zh-cn/docs/plugins/security/bot-detect#增加爬虫判断","content":"deny: - &quot;spd-tools.*&quot;  根据该配置，下列请求将被禁止访问： curl http://example.com -H 'User-Agent: spd-tools/1.1' curl http://exmaple.com -H 'User-Agent: spd-tools'  ","version":"Next","tagName":"h3"},{"title":"Wasm 插件使用简介","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/intro","content":"","keywords":"higress wasm","version":"Next"},{"title":"通过 Higress 控制台进行配置​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#通过-higress-控制台进行配置","content":"Higress 控制台提供了 3 个入口进行插件配置: 全局配置：插件市场-&gt;选择插件进行配置域名级配置：域名管理-&gt;选择域名-&gt;点击策略-&gt;选择插件进行配置路由级配置: 路由配置-&gt;选择路由-&gt;点击策略-&gt;选择插件进行配置 这三个配置的生效优先级是: 路由级 &gt; 域名级 &gt; 全局 即对于没有匹配到具体路由或域名的请求才会生效全局配置 对于一般的插件，包括自定义插件在内，路由/域名级的配置字段和全局配置字段是完全一样的； 对于认证类插件(Key 认证，HMAC 认证，Basic 认证，JWT 认证等)则不同，全局配置仅做 Consumer 凭证配置，以及是否开启全局认证，而在路由/域名级通过 allow 字段配置允许访问的 Consumer 列表，详情可以查看 Key 认证的配置说明。 ","version":"Next","tagName":"h2"},{"title":"通过 Higress WasmPlugin CRD 进行配置​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#通过-higress-wasmplugin-crd-进行配置","content":"Higress WasmPlugin CRD 在 Istio WasmPlugin CRD 的基础上进行了扩展，新增以下配置字段： 字段名称\t数据类型\t填写要求\t描述defaultConfig\tobject\t选填\t插件默认配置，全局生效于没有匹配具体域名和路由配置的请求 matchRules\tarray of object\t选填\t匹配域名或路由生效的配置 matchRules 中每一项的配置字段说明： 字段名称\t数据类型\t填写要求\t配置示例\t描述ingress\tarray of string\tingress 和 domain 中必填一项\t[&quot;default/foo&quot;,&quot;default/bar&quot;]\t匹配 ingress 资源对象，匹配格式为: 命名空间/ingress名称 domain\tarray of string\tingress 和 domain 中必填一项\t[&quot;example.com&quot;,&quot;*.test.com&quot;]\t匹配域名，支持泛域名 config\tobject\t选填\t-\t匹配后生效的插件配置 以请求屏蔽插件举例说明，如果希望全局生效插件的如下配置（请查看请求屏蔽文档了解配置字段说明）： block_urls: - swagger.html - foo=bar case_sensitive: false  则对应的 WasmPlugin 需要配置如下： apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: request-block namespace: higress-system spec: defaultConfig: block_urls: - swagger.html - foo=bar case_sensitive: false url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/request-block:1.0.0  配置后下列请求将立即被禁止访问: curl http://example.com?foo=Bar curl http://example.com/foo/Swagger.html  如果希望对 default 命名空间下名称为 foo 的 Ingress (匹配 path 前缀为 /foo 的请求)生效如下配置: block_headers: - example-key - example-value  则对应的 WasmPlugin 需要配置如下： apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: request-block namespace: higress-system spec: defaultConfig: block_urls: - swagger.html - foo=bar case_sensitive: false matchRules: # 路由级生效配置 - ingress: - default/foo # default 命名空间下名为 foo 的 ingress 会执行下面这个配置 config: block_headers: - example-key - example-value url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/request-block:1.0.0  配置后，下面请求不会匹配到具体的 ingress，因此仍然命中全局默认配置，被拒绝访问： curl http://example.com?foo=Bar  下面请求由于匹配到 foo 这个 Ingress，因此走路由级的配置，不受默认配置影响，不会被拒绝访问: curl http://exmaple.com/foo/Swagger.html  因为路由级配置屏蔽了请求 Header 中出现 example-key 字符的请求，所以下面这个请求会被拒绝访问: curl http://exmaple.com/foo -H 'exmaple-key: 123'  当 matchRules 中存在多个规则时，按规则排列顺序优先匹配，建议将 ingress 匹配配置放在 domain 匹配之前，这也是 Higress 控制台的做法。 ","version":"Next","tagName":"h2"},{"title":"官方插件镜像地址​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#官方插件镜像地址","content":"插件名称\t镜像地址Key 认证\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/key-auth:1.0.0 Basic 认证\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/basic-auth:1.0.0 HMAC 认证\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/hmac-auth:1.0.0 JWT 认证\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/jwt-auth:1.0.0 机器人拦截\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/bot-detect:1.0.0 自定义应答\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/custom-response:1.0.0 请求屏蔽\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/request-block:1.0.0 基于 Key 限流\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/key-rate-limit:1.0.0 WAF 防护\thigress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/waf:1.0.0 ","version":"Next","tagName":"h3"},{"title":"Wasm 插件原理介绍​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#wasm-插件原理介绍","content":"","version":"Next","tagName":"h2"},{"title":"什么是 Wasm​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#什么是-wasm","content":"// TODO... ","version":"Next","tagName":"h3"},{"title":"插件生效流程​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#插件生效流程","content":"// TODO... ","version":"Next","tagName":"h3"},{"title":"插件执行顺序编排​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#插件执行顺序编排","content":"// TODO... ","version":"Next","tagName":"h3"},{"title":"Wasm 插件如何做到变更时流量无损​","type":1,"pageTitle":"Wasm 插件使用简介","url":"/zh-cn/docs/plugins/intro#wasm-插件如何做到变更时流量无损","content":"// TODO... ","version":"Next","tagName":"h3"},{"title":"WAF 防护","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/security/waf","content":"","keywords":"higress waf","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"WAF 防护","url":"/zh-cn/docs/plugins/security/waf#功能说明","content":"开源版 WAF 插件，支持基于 OWASP ModSecurity Core Rule Set (CRS) 的 WAF 规则配置。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"WAF 防护","url":"/zh-cn/docs/plugins/security/waf#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述useCRS\tbool\t选填\tfalse\t是否开启 OWASP CRS，详情可参考 coreruleset secRules\tarray of string\t选填\t-\t用户自定义的waf防护规则，语法规则可参考 SecLang 语法参考 和 ModSecurity 中文手册 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"WAF 防护","url":"/zh-cn/docs/plugins/security/waf#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"观察模式（只会记录日志)​","type":1,"pageTitle":"WAF 防护","url":"/zh-cn/docs/plugins/security/waf#观察模式只会记录日志","content":"useCRS: true secRules: - &quot;SecRuleEngine DetectionOnly&quot;  ","version":"Next","tagName":"h3"},{"title":"防护模式​","type":1,"pageTitle":"WAF 防护","url":"/zh-cn/docs/plugins/security/waf#防护模式","content":"useCRS: true secRules: - &quot;SecRuleEngine On&quot;  ","version":"Next","tagName":"h3"},{"title":"测试自定义规则​","type":1,"pageTitle":"WAF 防护","url":"/zh-cn/docs/plugins/security/waf#测试自定义规则","content":"useCRS: true secRules: - &quot;SecRuleEngine On&quot; - &quot;SecRule REQUEST_URI \\&quot;@streq /admin\\&quot; \\&quot;id:101,phase:1,t:lowercase,deny\\&quot;&quot;  根据该配置，以下请求将被禁止访问： curl http://example.com/admin  ","version":"Next","tagName":"h3"},{"title":"CORS","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/security/cors","content":"","keywords":"higress cors","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#功能说明","content":"cors 插件可以为服务端启用 CORS（Cross-Origin Resource Sharing，跨域资源共享）的返回 HTTP 响应头。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述allow_origins\tarray of string\t选填\t*\t允许跨域访问的 Origin，格式为 scheme://host:port，示例如 http://example.com:8081。当 allow_credentials 为 false 时，可以使用 * 来表示允许所有 Origin 通过 allow_origin_patterns\tarray of string\t选填\t-\t允许跨域访问的 Origin 模式匹配， 用 匹配域名或者端口， 比如 http://.example.com -- 匹配域名， http://.example.com:[8080,9090] -- 匹配域名和指定端口， http://.example.com:[*] -- 匹配域名和所有端口。单独 * 表示匹配所有域名和端口 allow_methods\tarray of string\t选填\tGET, PUT, POST, DELETE, PATCH, OPTIONS\t允许跨域访问的 Method，比如：GET，POST 等。可以使用 * 来表示允许所有 Method。 allow_headers\tarray of string\t选填\tDNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With， If-Modified-Since,Cache-Control,Content-Type,Authorization\t允许跨域访问时请求方携带哪些非 CORS 规范以外的 Header。可以使用 * 来表示允许任意 Header。 expose_headers\tarray of string\t选填\t-\t允许跨域访问时响应方携带哪些非 CORS 规范以外的 Header。可以使用 * 来表示允许任意 Header。 allow_credentials\tbool\t选填\tfalse\t是否允许跨域访问的请求方携带凭据（如 Cookie 等）。根据 CORS 规范，如果设置该选项为 true，在 allow_origins 不能使用 ， 替换成使用 allow_origin_patterns max_age\tnumber\t选填\t86400秒\t浏览器缓存 CORS 结果的最大时间，单位为秒。 在这个时间范围内，浏览器会复用上一次的检查结果 注意 allow_credentials 是一个很敏感的选项，请谨慎开启。开启之后，allow_credentials 和 allow_origins 为 不能同时使用，同时设置时， allow_origins 值为 &quot;&quot; 生效。allow_origins 和 allow_origin_patterns 可以同时设置， 先检查 allow_origins 是否匹配，然后再检查 allow_origin_patterns 是否匹配。非法 CORS 请求， HTTP 状态码返回是 403， 返回体内容为 &quot;Invalid CORS request&quot;。 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"允许所有跨域访问, 不允许请求方携带凭据​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#允许所有跨域访问-不允许请求方携带凭据","content":"allow_origins: - '*' allow_methods: - '*' allow_headers: - '*' expose_headers: - '*' allow_credentials: false max_age: 7200  ","version":"Next","tagName":"h3"},{"title":"允许所有跨域访问,同时允许请求方携带凭据​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#允许所有跨域访问同时允许请求方携带凭据","content":"allow_origin_patterns: - '*' allow_methods: - '*' allow_headers: - '*' expose_headers: - '*' allow_credentials: true max_age: 7200  ","version":"Next","tagName":"h3"},{"title":"允许特定子域，特定方法，特定请求头跨域访问，同时允许请求方携带凭据​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#允许特定子域特定方法特定请求头跨域访问同时允许请求方携带凭据","content":"allow_origin_patterns: - http://*.example.com - http://*.example.org:[8080,9090] allow_methods: - GET - PUT - POST - DELETE allow_headers: - Token - Content-Type - Authorization expose_headers: - '*' allow_credentials: true max_age: 7200  ","version":"Next","tagName":"h3"},{"title":"测试​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#测试","content":"","version":"Next","tagName":"h2"},{"title":"测试配置​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#测试配置","content":"apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: mcp-cors-httpbin namespace: higress-system spec: registries: - domain: httpbin.org name: httpbin port: 80 type: dns --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: httpbin.dns higress.io/upstream-vhost: &quot;httpbin.org&quot; higress.io/backend-protocol: HTTP name: ingress-cors-httpbin namespace: higress-system spec: ingressClassName: higress rules: - host: httpbin.example.com http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: mcp-cors-httpbin path: / pathType: Prefix --- apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: wasm-cors-httpbin namespace: higress-system spec: defaultConfigDisable: true matchRules: - config: allow_origins: - http://httpbin.example.net allow_origin_patterns: - http://*.example.com:[*] - http://*.example.org:[9090,8080] allow_methods: - GET - POST - PATCH allow_headers: - Content-Type - Token - Authorization expose_headers: - X-Custom-Header - X-Env-UTM allow_credentials: true max_age: 3600 configDisable: false ingress: - ingress-cors-httpbin url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/cors:1.0.0 imagePullPolicy: Always  ","version":"Next","tagName":"h3"},{"title":"请求测试​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#请求测试","content":"简单请求 curl -v -H &quot;Origin: http://httpbin2.example.org:9090&quot; -H &quot;Host: httpbin.example.com&quot; http://127.0.0.1/anything/get\\?foo\\=1 &lt; HTTP/1.1 200 OK &gt; x-cors-version: 1.0.0 &gt; access-control-allow-origin: http://httpbin2.example.org:9090 &gt; access-control-expose-headers: X-Custom-Header,X-Env-UTM &gt; access-control-allow-credentials: true  预检请求 curl -v -X OPTIONS -H &quot;Origin: http://httpbin2.example.org:9090&quot; -H &quot;Host: httpbin.example.com&quot; -H &quot;Access-Control-Request-Method: POST&quot; -H &quot;Access-Control-Request-Headers: Content-Type, Token&quot; http://127.0.0.1/anything/get\\?foo\\=1 &lt; HTTP/1.1 200 OK &lt; x-cors-version: 1.0.0 &lt; access-control-allow-origin: http://httpbin2.example.org:9090 &lt; access-control-allow-methods: GET,POST,PATCH &lt; access-control-allow-headers: Content-Type,Token,Authorization &lt; access-control-expose-headers: X-Custom-Header,X-Env-UTM &lt; access-control-allow-credentials: true &lt; access-control-max-age: 3600 &lt; date: Tue, 23 May 2023 11:41:28 GMT &lt; server: istio-envoy &lt; content-length: 0 &lt; * Connection #0 to host 127.0.0.1 left intact * Closing connection 0  非法 CORS Origin 预检请求 curl -v -X OPTIONS -H &quot;Origin: http://httpbin2.example.org&quot; -H &quot;Host: httpbin.example.com&quot; -H &quot;Access-Control-Request-Method: GET&quot; http://127.0.0.1/anything/get\\?foo\\=1 HTTP/1.1 403 Forbidden &lt; content-length: 70 &lt; content-type: text/plain &lt; x-cors-version: 1.0.0 &lt; date: Tue, 23 May 2023 11:27:01 GMT &lt; server: istio-envoy &lt; * Connection #0 to host 127.0.0.1 left intact Invalid CORS request  非法 CORS Method 预检请求 curl -v -X OPTIONS -H &quot;Origin: http://httpbin2.example.org:9090&quot; -H &quot;Host: httpbin.example.com&quot; -H &quot;Access-Control-Request-Method: DELETE&quot; http://127.0.0.1/anything/get\\?foo\\=1 &lt; HTTP/1.1 403 Forbidden &lt; content-length: 49 &lt; content-type: text/plain &lt; x-cors-version: 1.0.0 &lt; date: Tue, 23 May 2023 11:28:51 GMT &lt; server: istio-envoy &lt; * Connection #0 to host 127.0.0.1 left intact Invalid CORS request  非法 CORS Header 预检请求  curl -v -X OPTIONS -H &quot;Origin: http://httpbin2.example.org:9090&quot; -H &quot;Host: httpbin.example.com&quot; -H &quot;Access-Control-Request-Method: GET&quot; -H &quot;Access-Control-Request-Headers: TokenView&quot; http://127.0.0.1/anything/get\\?foo\\=1 &lt; HTTP/1.1 403 Forbidden &lt; content-length: 52 &lt; content-type: text/plain &lt; x-cors-version: 1.0.0 &lt; date: Tue, 23 May 2023 11:31:03 GMT &lt; server: istio-envoy &lt; * Connection #0 to host 127.0.0.1 left intact Invalid CORS request  ","version":"Next","tagName":"h3"},{"title":"参考文档​","type":1,"pageTitle":"CORS","url":"/zh-cn/docs/plugins/security/cors#参考文档","content":"https://www.ruanyifeng.com/blog/2016/04/cors.htmlhttps://fetch.spec.whatwg.org/#http-cors-protocol ","version":"Next","tagName":"h2"},{"title":"基于 Key 限流","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/traffic/key-rate-limit","content":"","keywords":"higress rate-limit","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"基于 Key 限流","url":"/zh-cn/docs/plugins/traffic/key-rate-limit#功能说明","content":"key-rate-limit 插件实现了基于特定键值实现限流，键值来源可以是 URL 参数、HTTP 请求头。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"基于 Key 限流","url":"/zh-cn/docs/plugins/traffic/key-rate-limit#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述limit_by_header\tstring\t选填，limit_by_header,limit_by_param 中选填一项\t-\t配置获取限流键值的来源 http 请求头名称 limit_by_param\tstring\t选填，limit_by_header,limit_by_param 中选填一项\t-\t配置获取限流键值的来源 URL 参数名称 limit_keys\tarray of object\t必填\t-\t配置匹配键值后的限流次数 limit_keys 中每一项的配置字段说明。 名称\t数据类型\t填写要求\t默认值\t描述key\tstring\t必填\t-\t匹配的键值 query_per_second\tnumber\t选填，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每秒请求次数 query_per_minute\tnumber\t选填，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每分钟请求次数 query_per_hour\tnumber\t选填，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每小时请求次数 query_per_day\tnumber\t选填，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每天请求次数 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"基于 Key 限流","url":"/zh-cn/docs/plugins/traffic/key-rate-limit#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"识别请求参数 apikey，进行区别限流​","type":1,"pageTitle":"基于 Key 限流","url":"/zh-cn/docs/plugins/traffic/key-rate-limit#识别请求参数-apikey进行区别限流","content":"limit_by_param: apikey limit_keys: - key: 9a342114-ba8a-11ec-b1bf-00163e1250b5 query_per_second: 10 - key: a6a6d7f2-ba8a-11ec-bec2-00163e1250b5 query_per_minute: 100  ","version":"Next","tagName":"h3"},{"title":"识别请求头 x-ca-key，进行区别限流​","type":1,"pageTitle":"基于 Key 限流","url":"/zh-cn/docs/plugins/traffic/key-rate-limit#识别请求头-x-ca-key进行区别限流","content":"limit_by_header: x-ca-key limit_keys: - key: 102234 query_per_second: 10 - key: 308239 query_per_hour: 10  ","version":"Next","tagName":"h3"},{"title":"IP 限制","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/traffic/ip-restriction","content":"","keywords":"higress","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"IP 限制","url":"/zh-cn/docs/plugins/traffic/ip-restriction#功能说明","content":"ip-restriction 插件可以通过将 IP 地址列入白名单或黑名单来限制对服务或路由的访问。支持对单个 IP 地址、多个 IP 地址和类似 10.10.10.0/24 的 CIDR 范围的限制。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"IP 限制","url":"/zh-cn/docs/plugins/traffic/ip-restriction#配置说明","content":"配置项\t类型\t必填\t默认值\t说明ip_source_type\tstring\t否\torigin-source\t可选值：1. 对端 socket ip：origin-source; 2. 通过 header 获取：header ip_header_name\tstring\t否\tx-forwarded-for\t当 ip_source_type 为 header 时，指定自定义 IP 来源头 allow\tarray\t否\t[]\t白名单列表 deny\tarray\t否\t[]\t黑名单列表 status\tint\t否\t403\t拒绝访问时的 HTTP 状态码 message\tstring\t否\tYour IP address is blocked.\t拒绝访问时的返回信息 ip_source_type: origin-source allow: - 10.0.0.1 - 192.168.0.0/16  ip_source_type: header ip_header_name: x-real-iP deny: - 10.0.0.1 - 192.169.0.0/16  ","version":"Next","tagName":"h2"},{"title":"请求屏蔽","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/traffic/request-block","content":"","keywords":"higress","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#功能说明","content":"request-block 插件实现了基于 URL、请求头等特征屏蔽 HTTP 请求，可以用于防护部分站点资源不对外部暴露。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述block_urls\tarray of string\t选填，block_urls,block_headers,block_bodies 中至少必填一项\t-\t配置用于匹配需要屏蔽 URL 的字符串 block_exact_urls\tarray of string\t选填，block_urls,block_headers,block_bodies 中至少必填一项\t-\t配置用于匹配需要精确屏蔽 URL 的字符串 block_regexp_urls\tarray of string\t选填，block_urls,block_headers,block_bodies 中至少必填一项\t-\t配置用于匹配需要屏蔽 URL 的正则表达式 block_headers\tarray of string\t选填，block_urls,block_headers,block_bodies 中至少必填一项\t-\t配置用于匹配需要屏蔽请求 Header 的字符串 block_bodies\tarray of string\t选填，block_urls,block_headers,block_bodies 中至少必填一项\t-\t配置用于匹配需要屏蔽请求 Body 的字符串 blocked_code\tnumber\t选填\t403\t配置请求被屏蔽时返回的 HTTP 状态码 blocked_message\tstring\t选填\t-\t配置请求被屏蔽时返回的 HTTP 应答 Body case_sensitive\tbool\t选填\ttrue\t配置匹配时是否区分大小写，默认区分 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"屏蔽请求 URL 路径​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#屏蔽请求-url-路径","content":"block_urls: - swagger.html - foo=bar case_sensitive: false  根据该配置，下列请求将被禁止访问： curl http://example.com?foo=Bar curl http://exmaple.com/Swagger.html  ","version":"Next","tagName":"h3"},{"title":"屏蔽请求 Header​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#屏蔽请求-header","content":"block_headers: - example-key - example-value  根据该配置，下列请求将被禁止访问： curl http://example.com -H 'example-key: 123' curl http://exmaple.com -H 'my-header: example-value'  ","version":"Next","tagName":"h3"},{"title":"屏蔽请求 Body​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#屏蔽请求-body","content":"block_bodies: - &quot;hello world&quot; case_sensitive: false  根据该配置，下列请求将被禁止访问： curl http://example.com -d 'Hello World' curl http://exmaple.com -d 'hello world'  ","version":"Next","tagName":"h3"},{"title":"对特定路由或域名开启​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#对特定路由或域名开启","content":"# 使用 matchRules 字段进行细粒度规则配置 matchRules: # 规则一：按 Ingress 名称匹配生效 - ingress: - default/foo - default/bar block_bodies: - &quot;hello world&quot; # 规则二：按域名匹配生效 - domain: - &quot;*.example.com&quot; - test.com block_urls: - &quot;swagger.html&quot; block_bodies: - &quot;hello world&quot;  此例 ingress 中指定的 default/foo 和 default/bar 对应 default 命名空间下名为 foo 和 bar 的 Ingress，当匹配到这两个 Ingress 时，将使用此段配置； 此例 domain 中指定的 *.example.com 和 test.com 用于匹配请求的域名，当发现域名匹配时，将使用此段配置； 配置的匹配生效顺序，将按照 matchRules 下规则的排列顺序，匹配第一个规则后生效对应配置，后续规则将被忽略。 ","version":"Next","tagName":"h3"},{"title":"请求 Body 大小限制​","type":1,"pageTitle":"请求屏蔽","url":"/zh-cn/docs/plugins/traffic/request-block#请求-body-大小限制","content":"当配置了 block_bodies 时，仅支持小于 32 MB 的请求 Body 进行匹配。若请求 Body 大于此限制，并且不存在匹配到的 block_urls 和 block_headers 项时，不会对该请求执行屏蔽操作。 当配置了 block_bodies 时，若请求 Body 超过全局配置 DownstreamConnectionBufferLimits，将返回 413 Payload Too Large。 ","version":"Next","tagName":"h2"},{"title":"基于 Key 集群限流","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit","content":"","keywords":"higress rate-limit","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#功能说明","content":"cluster-key-rate-limit 插件基于 Redis 实现集群限流，适用于需要跨多个 Higress Gateway 实例实现全局一致速率限制的场景。 限流所使用的 Key 可以来源于 URL 参数、HTTP 请求头、客户端 IP 地址、消费者名称或 Cookie 中的 Key。 ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#配置说明","content":"配置项\t类型\t必填\t默认值\t说明rule_name\tstring\t是\t-\t限流规则名称，根据限流规则名称 + 限流类型 + 限流 key 名称 + 限流 key 对应的实际值来拼装 redis key rule_items\tarray of object\t是\t-\t限流规则项，按照 rule_items 下的排列顺序，匹配第一个 rule_item 后命中限流规则，后续规则将被忽略 show_limit_quota_header\tbool\t否\tfalse\t响应头中是否显示 X-RateLimit-Limit（限制的总请求数）和 X-RateLimit-Remaining（剩余还可以发送的请求数） rejected_code\tint\t否\t429\t请求被限流时，返回的 HTTP 状态码 rejected_msg\tstring\t否\tToo many requests\t请求被限流时，返回的响应体 redis\tobject\t是\t-\tredis 相关配置 rule_items 中每一项的配置字段说明。 配置项\t类型\t必填\t默认值\t说明limit_by_header\tstring\t否，limit_by_* 中选填一项\t-\t配置获取限流键值的来源 HTTP 请求头名称 limit_by_param\tstring\t否，limit_by_* 中选填一项\t-\t配置获取限流键值的来源 URL 参数名称 limit_by_consumer\tstring\t否，limit_by_* 中选填一项\t-\t根据 consumer 名称进行限流，无需添加实际值 limit_by_cookie\tstring\t否，limit_by_* 中选填一项\t-\t配置获取限流键值的来源 Cookie中 key 名称 limit_by_per_header\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 HTTP 请求头，并对每个请求头分别计算限流，配置获取限流键值的来源 HTTP 请求头名称，配置 limit_keys 时支持正则表达式或 * limit_by_per_param\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 URL 参数，并对每个参数分别计算限流，配置获取限流键值的来源 URL 参数名称，配置 limit_keys 时支持正则表达式或 * limit_by_per_consumer\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 consumer，并对每个 consumer 分别计算限流，根据 consumer 名称进行限流，无需添加实际值，配置 limit_keys 时支持正则表达式或 * limit_by_per_cookie\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 Cookie，并对每个 Cookie 分别计算限流，配置获取限流键值的来源 Cookie中 key 名称，配置 limit_keys 时支持正则表达式或 * limit_by_per_ip\tstring\t否，limit_by_* 中选填一项\t-\t按规则匹配特定 IP，并对每个 IP 分别计算限流，配置获取限流键值的来源 IP 参数名称，从请求头获取，以 from-header-对应的header名，示例：from-header-x-forwarded-for，直接获取对端 socket ip，配置为 from-remote-addr limit_keys\tarray of object\t是\t-\t配置匹配键值后的限流次数 limit_keys 中每一项的配置字段说明。 配置项\t类型\t必填\t默认值\t说明key\tstring\t是\t-\t匹配的键值，limit_by_per_header,limit_by_per_param,limit_by_per_consumer,limit_by_per_cookie 类型支持配置正则表达式（以regexp:开头后面跟正则表达式）或者（代表所有），正则表达式示例：`regexp:^d.（以d开头的所有字符串）；limit_by_per_ip`支持配置 IP 地址或 IP 段 query_per_second\tint\t否，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每秒请求次数 query_per_minute\tint\t否，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每分钟请求次数 query_per_hour\tint\t否，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每小时请求次数 query_per_day\tint\t否，query_per_second,query_per_minute,query_per_hour,query_per_day 中选填一项\t-\t允许每天请求次数 redis 中每一项的配置字段说明。 配置项\t类型\t必填\t默认值\t说明service_name\tstring\t必填\t-\tredis 服务名称，带服务类型的完整 FQDN 名称，例如 my-redis.dns、redis.my-ns.svc.cluster.local service_port\tint\t否\t服务类型为固定地址（static service）默认值为80，其他为6379\t输入redis服务的服务端口 username\tstring\t否\t-\tredis 用户名 password\tstring\t否\t-\tredis 密码 timeout\tint\t否\t1000\tredis 连接超时时间，单位毫秒 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"识别请求参数 apikey，进行区别限流​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#识别请求参数-apikey进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_param: apikey limit_keys: - key: 9a342114-ba8a-11ec-b1bf-00163e1250b5 query_per_minute: 10 - key: a6a6d7f2-ba8a-11ec-bec2-00163e1250b5 query_per_hour: 100 - limit_by_per_param: apikey limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 apikey 对应的请求 10qds - key: &quot;regexp:^a.*&quot; query_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 apikey 对应的请求 100qd - key: &quot;regexp:^b.*&quot; query_per_minute: 100 # 兜底用，匹配所有请求，每个 apikey 对应的请求 1000qdh - key: &quot;*&quot; query_per_hour: 1000 redis: service_name: redis.static show_limit_quota_header: true  ","version":"Next","tagName":"h3"},{"title":"识别请求头 x-ca-key，进行区别限流​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#识别请求头-x-ca-key进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_header: x-ca-key limit_keys: - key: 102234 query_per_minute: 10 - key: 308239 query_per_hour: 10 - limit_by_per_header: x-ca-key limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 apikey 对应的请求 10qds - key: &quot;regexp:^a.*&quot; query_per_second: 10 # 正则表达式，匹配以b开头的所有字符串，每个 apikey 对应的请求 100qd - key: &quot;regexp:^b.*&quot; query_per_minute: 100 # 兜底用，匹配所有请求，每个 apikey 对应的请求 1000qdh - key: &quot;*&quot; query_per_hour: 1000 redis: service_name: redis.static show_limit_quota_header: true  ","version":"Next","tagName":"h3"},{"title":"根据请求头 x-forwarded-for 获取对端 IP，进行区别限流​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#根据请求头-x-forwarded-for-获取对端-ip进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_per_ip: from-header-x-forwarded-for limit_keys: # 精确 IP - key: 1.1.1.1 query_per_day: 10 # IP 段，符合这个 IP 段的 IP，每个 IP 100qpd - key: 1.1.1.0/24 query_per_day: 100 # 兜底用，即默认每个 IP 1000 qpd - key: 0.0.0.0/0 query_per_day: 1000 redis: service_name: redis.static show_limit_quota_header: true  ","version":"Next","tagName":"h3"},{"title":"识别 consumer，进行区别限流​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#识别-consumer进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_consumer: '' limit_keys: - key: consumer1 query_per_second: 10 - key: consumer2 query_per_hour: 100 - limit_by_per_consumer: '' limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 consumer 对应的请求 10qds - key: &quot;regexp:^a.*&quot; query_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 consumer 对应的请求 100qd - key: &quot;regexp:^b.*&quot; query_per_minute: 100 # 兜底用，匹配所有请求，每个 consumer 对应的请求 1000qdh - key: &quot;*&quot; query_per_hour: 1000 redis: service_name: redis.static show_limit_quota_header: true  ","version":"Next","tagName":"h3"},{"title":"识别 Cookie 中的键值对，进行区别限流​","type":1,"pageTitle":"基于 Key 集群限流","url":"/zh-cn/docs/plugins/traffic/cluster-key-rate-limit#识别-cookie-中的键值对进行区别限流","content":"rule_name: default_rule rule_items: - limit_by_cookie: key1 limit_keys: - key: value1 query_per_minute: 10 - key: value2 query_per_hour: 100 - limit_by_per_cookie: key1 limit_keys: # 正则表达式，匹配以 a 开头的所有字符串，每个 cookie 中的 value 对应的请求 10qds - key: &quot;regexp:^a.*&quot; query_per_second: 10 # 正则表达式，匹配以 b 开头的所有字符串，每个 cookie 中的 value 对应的请求 100qd - key: &quot;regexp:^b.*&quot; query_per_minute: 100 # 兜底用，匹配所有请求，每个 cookie 中的 value 对应的请求 1000qdh - key: &quot;*&quot; query_per_hour: 1000 rejected_code: 200 rejected_msg: '{&quot;code&quot;:-1,&quot;msg&quot;:&quot;Too many requests&quot;}' redis: service_name: redis.static show_limit_quota_header: true  ","version":"Next","tagName":"h3"},{"title":"请求校验","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/traffic/request-validation","content":"","keywords":"higress","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#功能说明","content":"request-validation 插件用于提前验证向上游服务转发的请求。该插件使用 JSON Schema 机制进行数据验证，可以验证请求的 Body 以及 Header 的数据。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述header_schema\tobject\t选填\t-\t配置用于验证请求 Header 的JSON Schema body_schema\tobject\t选填\t-\t配置用于验证请求 Body 的 JSON Schema rejected_code\tnumber\t选填\t403\t配置请求被拒绝时返回的 HTTP 状态码 rejected_msg\tstring\t选填\t-\t配置请求被拒绝时返回的 HTTP 应答 Body enable_swagger\tbool\t选填\tfalse\t配置是否开启 Swagger 文档验证 enable_oas3\tbool\t选填\tfalse\t配置是否开启 OAS3 文档验证 校验规则对 Header 和 Body 是一样的，下面以 Body 为例说明。 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"枚举（Enum）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#枚举enum验证","content":"body_schema: type: object required: - enum_payload properties: enum_payload: type: string enum: - &quot;enum_string_1&quot; - &quot;enum_string_2&quot; default: &quot;enum_string_1&quot;  ","version":"Next","tagName":"h3"},{"title":"布尔（Boolean）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#布尔boolean验证","content":"body_schema: type: object required: - boolean_payload properties: boolean_payload: type: boolean default: true  ","version":"Next","tagName":"h3"},{"title":"数字范围（Number or Integer）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#数字范围number-or-integer验证","content":"body_schema: type: object required: - integer_payload properties: integer_payload: type: integer minimum: 1 maximum: 10  ","version":"Next","tagName":"h3"},{"title":"字符串长度（String）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#字符串长度string验证","content":"body_schema: type: object required: - string_payload properties: string_payload: type: string minLength: 1 maxLength: 10  ","version":"Next","tagName":"h3"},{"title":"正则表达式（Regex）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#正则表达式regex验证","content":"body_schema: type: object required: - regex_payload properties: regex_payload: type: string minLength: 1 maxLength: 10 pattern: &quot;^[a-zA-Z0-9_]+$&quot;  ","version":"Next","tagName":"h3"},{"title":"数组（Array）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#数组array验证","content":"body_schema: type: object required: - array_payload properties: array_payload: type: array minItems: 1 items: type: integer minimum: 1 maximum: 10 uniqueItems: true default: [1, 2, 3]  ","version":"Next","tagName":"h3"},{"title":"多字段组合（Combined）验证​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#多字段组合combined验证","content":"body_schema: type: object required: - boolean_payload - array_payload - regex_payload properties: boolean_payload: type: boolean array_payload: type: array minItems: 1 items: type: integer minimum: 1 maximum: 10 uniqueItems: true default: [1, 2, 3] regex_payload: type: string minLength: 1 maxLength: 10 pattern: &quot;^[a-zA-Z0-9_]+$&quot;  ","version":"Next","tagName":"h3"},{"title":"自定义拒绝信息​","type":1,"pageTitle":"请求校验","url":"/zh-cn/docs/plugins/traffic/request-validation#自定义拒绝信息","content":"body_schema: type: object required: - boolean_payload properties: boolean_payload: type: boolean rejected_code: 403 rejected_msg: &quot;请求被拒绝&quot;  ","version":"Next","tagName":"h3"},{"title":"缓存控制","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/transformation/cache-control","content":"","keywords":"higress transformer","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"缓存控制","url":"/zh-cn/docs/plugins/transformation/cache-control#功能说明","content":"cache-control 插件实现了基于 URL 文件后缀来为请求的响应头部添加 Expires 和 Cache-Control 头部，从而方便浏览器对特定后缀的文件进行缓存，例如 jpg、png 等图片文件。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"缓存控制","url":"/zh-cn/docs/plugins/transformation/cache-control#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述suffix\tstring\t选填，表示匹配的文件后缀名，例如 jpg、png 等。 如果需要匹配多种后缀，需要用 \\| 进行分割，例如 png\\|jpg。 如果不填写，表示匹配所有后缀\t-\t配置用于匹配的请求文件后缀 expires\tstring\t必填，表示缓存的最长时间。 当填入的字符串为数字时，单位为秒，例如需要缓存 1 小时，需填写 3600。 另外，还可以填写 epoch 或 max ，与 nginx 中语义相同。\t-\t配置缓存的最大时间 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"缓存控制","url":"/zh-cn/docs/plugins/transformation/cache-control#配置示例","content":"缓存后缀为 jpg, png, jpeg 的文件，缓存时间为一小时。 suffix: jpg|png|jpeg expires: 3600  根据该配置，下列请求在访问时，将会在响应头中添加 Expires 和 Cache-Control 字段，且过期时间为 1 小时后。 curl http://example.com/test.png curl http://exmaple.com/test.jpg  缓存所有文件，且缓存至最大时间 “Thu, 31 Dec 2037 23:55:55 GMT” expires: max  ","version":"Next","tagName":"h2"},{"title":"自定义应答","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/transformation/custom-response","content":"","keywords":"higress transformer","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"自定义应答","url":"/zh-cn/docs/plugins/transformation/custom-response#功能说明","content":"custom-response 插件支持配置自定义的响应，包括自定义 HTTP 应答状态码、HTTP 应答头，以及 HTTP 应答 Body。可以用于 Mock 响应，也可以用于判断特定状态码后给出自定义应答，例如在触发网关限流策略时实现自定义响应。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"自定义应答","url":"/zh-cn/docs/plugins/transformation/custom-response#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述status_code\tnumber\t选填\t200\t自定义 HTTP 应答状态码 headers\tarray of string\t选填\t-\t自定义 HTTP 应答头，key 和 value 用=分隔 body\tstring\t选填\t-\t自定义 HTTP 应答 Body enable_on_status\tarray of number\t选填\t-\t匹配原始状态码，生成自定义响应，不填写时，不判断原始状态码 ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"自定义应答","url":"/zh-cn/docs/plugins/transformation/custom-response#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"Mock 应答场景​","type":1,"pageTitle":"自定义应答","url":"/zh-cn/docs/plugins/transformation/custom-response#mock-应答场景","content":"status_code: 200 headers: - Content-Type=application/json - Hello=World body: &quot;{\\&quot;hello\\&quot;:\\&quot;world\\&quot;}&quot;  根据该配置，请求将返回自定义应答如下： HTTP/1.1 200 OK Content-Type: application/json Hello: World Content-Length: 17 {&quot;hello&quot;:&quot;world&quot;}  ","version":"Next","tagName":"h3"},{"title":"触发限流时自定义响应​","type":1,"pageTitle":"自定义应答","url":"/zh-cn/docs/plugins/transformation/custom-response#触发限流时自定义响应","content":"enable_on_status: - 429 status_code: 302 headers: - Location=https://example.com  触发网关限流时一般会返回 429 状态码，这时请求将返回自定义应答如下： HTTP/1.1 302 Found Location: https://example.com  从而实现基于浏览器 302 重定向机制，将限流后的用户引导到其他页面，比如可以是一个 CDN 上的静态页面。 如果希望触发限流时，正常返回其他应答，参考 Mock 应答场景配置相应的字段即可。 ","version":"Next","tagName":"h3"},{"title":"对特定路由或域名开启​","type":1,"pageTitle":"自定义应答","url":"/zh-cn/docs/plugins/transformation/custom-response#对特定路由或域名开启","content":"# 使用 matchRules 字段进行细粒度规则配置 matchRules: # 规则一：按 Ingress 名称匹配生效 - ingress: - default/foo - default/bar body: &quot;{\\&quot;hello\\&quot;:\\&quot;world\\&quot;}&quot; # 规则二：按域名匹配生效 - domain: - &quot;*.example.com&quot; - test.com enable_on_status: - 429 status_code: 200 headers: - Content-Type=application/json body: &quot;{\\&quot;errmsg\\&quot;: \\&quot;rate limited\\&quot;}&quot;  此例 ingress 中指定的 default/foo 和 default/bar 对应 default 命名空间下名为 foo 和 bar 的 Ingress，当匹配到这两个 Ingress 时，将使用此段配置； 此例 domain 中指定的 *.example.com 和 test.com 用于匹配请求的域名，当发现域名匹配时，将使用此段配置； 配置的匹配生效顺序，将按照 matchRules 下规则的排列顺序，匹配第一个规则后生效对应配置，后续规则将被忽略。 ","version":"Next","tagName":"h3"},{"title":"DeGraphQL","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/transformation/de-graphql","content":"","keywords":"higress transformer","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#功能说明","content":"de-graphql 插件用于将 Restful API 转换为 GraphQL 请求。 ","version":"Next","tagName":"h2"},{"title":"GraphQL 简介​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#graphql-简介","content":"","version":"Next","tagName":"h2"},{"title":"GraphQL 端点​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#graphql-端点","content":"REST API 有多个端点，GraphQL API 只有一个端点。 https://api.github.com/graphql  ","version":"Next","tagName":"h3"},{"title":"与 GraphQL 通信​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#与-graphql-通信","content":"由于 GraphQL 操作由多行 JSON 组成，可以使用 curl 或任何其他采用 HTTP 的库。 在 REST 中，HTTP 谓词确定执行的操作。 在 GraphQL 中，执行查询要提供 JSON 请求体，因此 HTTP 谓词为 POST。 唯一的例外是内省查询，它是一种简单的 GET 到终结点查询。 ","version":"Next","tagName":"h3"},{"title":"GraphQL POST 请求参数​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#graphql-post-请求参数","content":"标准的 GraphQL POST 请求情况如下： 添加 HTTP 请求头： Content-Type: application/json使用 JSON 格式的请求体JSON 请求体包含三个字段 query：查询文档，必填variables：变量，选填operationName：操作名称，选填，查询文档有多个操作时必填 { &quot;query&quot;: &quot;{viewer{name}}&quot;, &quot;operationName&quot;: &quot;&quot;, &quot;variables&quot;: { &quot;name&quot;: &quot;value&quot; } }  ","version":"Next","tagName":"h3"},{"title":"GraphQL 基本参数类型​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#graphql-基本参数类型","content":"基本参数类型包含： String, Int, Float, Boolean[类型]代表数组，例如：[Int]代表整型数组GraphQL 基本参数传递 小括号内定义形参，注意：参数需要定义类型!（叹号）代表参数不能为空 query ($owner : String!, $name : String!) { repository(owner: $owner, name: $name) { name forkCount description } }  ","version":"Next","tagName":"h3"},{"title":"GitHub GraphQL 测试​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#github-graphql-测试","content":"使用 curl 命令查询 GraphQL， 用有效 JSON 请求体发出 POST 请求。 有效请求体必须包含一个名为 query 的字符串。  curl https://api.github.com/graphql -X POST \\ -H &quot;Authorization: bearer &lt;PAT&gt;&quot; \\ -d &quot;{\\&quot;query\\&quot;: \\&quot;query { viewer { login }}\\&quot;}&quot; { &quot;data&quot;: { &quot;viewer&quot;: { &quot;login&quot;: &quot;2456868764&quot; } } }  curl 'https://api.github.com/graphql' -X POST \\ -H 'Authorization: bearer &lt;PAT&gt;' \\ -d '{&quot;query&quot;:&quot;query ($owner: String!, $name: String!) {\\n repository(owner: $owner, name: $name) {\\n name\\n forkCount\\n description\\n }\\n}\\n&quot;,&quot;variables&quot;:{&quot;owner&quot;:&quot;2456868764&quot;,&quot;name&quot;:&quot;higress&quot;}}' { &quot;data&quot;: { &quot;repository&quot;: { &quot;name&quot;: &quot;higress&quot;, &quot;forkCount&quot;: 149, &quot;description&quot;: &quot;Next-generation Cloud Native Gateway | 下一代云原生网关&quot; } } }  ","version":"Next","tagName":"h3"},{"title":"DeGraphQL 插件​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#degraphql-插件","content":"","version":"Next","tagName":"h2"},{"title":"参数配置​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#参数配置","content":"参数\t描述\t默认gql\tgraphql 查询\t不能为空 endpoint\tgraphql 查询端点\t/graphql timeout\t查询连接超时，单位毫秒\t5000 domain\t服务域名，当服务来源是dns配置\t ","version":"Next","tagName":"h3"},{"title":"插件使用​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#插件使用","content":"测试配置。 apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: api.github.com name: github port: 443 type: dns --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: github.dns higress.io/upstream-vhost: &quot;api.github.com&quot; higress.io/backend-protocol: HTTPS name: github-api namespace: higress-system spec: ingressClassName: higress rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: /api pathType: Prefix --- apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: de-graphql-github-api namespace: higress-system spec: matchRules: - ingress: - github-api config: timeout: 5000 endpoint: /graphql domain: api.github.com gql: | query ($owner:String! $name:String!){ repository(owner:$owner, name:$name) { name forkCount description } } url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/de-graphql:1.0.0  测试结果。 curl &quot;http://localhost/api?owner=alibaba&amp;name=higress&quot; -H &quot;Authorization: Bearer some-token&quot; { &quot;data&quot;: { &quot;repository&quot;: { &quot;description&quot;: &quot;Next-generation Cloud Native Gateway&quot;, &quot;forkCount&quot;: 149, &quot;name&quot;: &quot;higress&quot; } } }  ","version":"Next","tagName":"h3"},{"title":"参考文档​","type":1,"pageTitle":"DeGraphQL","url":"/zh-cn/docs/plugins/transformation/de-graphql#参考文档","content":"https://github.com/graphql/graphql-spechttps://docs.github.com/zh/graphql/guides/forming-calls-with-graphqlhttps://github.com/altair-graphql/altair ","version":"Next","tagName":"h2"},{"title":"Ingress Annotaion 配置说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/annotation","content":"","keywords":"Ingress","version":"Next"},{"title":"Ingress Annotation​","type":1,"pageTitle":"Ingress Annotaion 配置说明","url":"/zh-cn/docs/user/annotation#ingress-annotation","content":"","version":"Next","tagName":"h2"},{"title":"特殊说明​","type":1,"pageTitle":"Ingress Annotaion 配置说明","url":"/zh-cn/docs/user/annotation#特殊说明","content":"Annotation Key 前缀​ 以下出现的Nginx Ingress Annotation都已被Higress支持，您可以根据使用习惯继续使用Nginx Ingress的Annotation前缀nginx.ingress.kubernetes.io，或者使用Higress Ingress的Annotation前缀higress.io，两者是等价的。 作用域说明​ Ingress：作用域为Ingress的Annotation的作用范围仅限当前Ingress上定义的路由规则。域名：作用域为域名的Annotation，其作用范围为所有Ingress上出现的相同Host。服务：作用域为服务的Annotation，其作用范围为所有Ingress上出现的相同Service。 ","version":"Next","tagName":"h3"},{"title":"流量治理​","type":1,"pageTitle":"Ingress Annotaion 配置说明","url":"/zh-cn/docs/user/annotation#流量治理","content":"灰度发布​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/canary\tIngress\t兼容\t开启或关闭灰度发布 nginx.ingress.kubernetes.io/canary-by-header\tIngress\t兼容\t基于Request Header Key 流量切分 nginx.ingress.kubernetes.io/canary-by-header-value\tIngress\t兼容\t基于Request Header Value 流量切分，Value为精确匹配 nginx.ingress.kubernetes.io/canary-by-header-pattern\tIngress\t兼容\t基于Request Header Value 流量切分，Value为正则匹配 nginx.ingress.kubernetes.io/canary-by-cookie\tIngress\t兼容\t基于Request Cookie Key 流量切分 nginx.ingress.kubernetes.io/canary-weight\tIngress\t兼容\t基于权重 流量切分 nginx.ingress.kubernetes.io/canary-weight-total\tIngress\t兼容\t权重总和 Fallback（容灾）​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/default-backend\tIngress\t兼容\t容灾服务。当Ingress定义的服务没有可用节点时，请求会自动转发该容灾服务。 nginx.ingress.kubernetes.io/custom-http-errors\tIngress\t兼容\t该注解和default-backend一起工作。当后端服务返回指定HTTP响应码，原始请求会被再次转发至容灾服务。 &gt; 注意：转发至容灾服务时，请求的Path会被重写为/，该行为与ingress-nginx保持一致 重写​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/rewrite-target\tIngress\t兼容\t将Ingress定义的原path重写为指定目标，支持Group Capture. nginx.ingress.kubernetes.io/upstream-vhost\tIngress\t兼容\t匹配Ingress定义的路由的请求在转发给后端服务时，修改头部host值为指定值。 重定向​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/ssl-redirect\tIngress\t兼容\tHTTP 重定向为HTTPS nginx.ingress.kubernetes.io/force-ssl-redirect\tIngress\t兼容\tHTTP 重定向为HTTPS nginx.ingress.kubernetes.io/permanent-redirect\tIngress\t兼容\t永久重定向 nginx.ingress.kubernetes.io/permanent-redirect-code\tIngress\t兼容\t永久重定向状态码 nginx.ingress.kubernetes.io/temporal-redirect\tIngress\t兼容\t临时重定向 nginx.ingress.kubernetes.io/app-root\tIngress\t兼容\t修改应用根路径，对于访问/的请求将会被重定向为设置的新路径 跨域​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/enable-cors\tIngress\t兼容\t开启或关闭跨域 nginx.ingress.kubernetes.io/cors-allow-origin\tIngress\t兼容\t允许的第三方站点 nginx.ingress.kubernetes.io/cors-allow-methods\tIngress\t兼容\t允许的请求方法，如GET、POST、PUT等 nginx.ingress.kubernetes.io/cors-allow-headers\tIngress\t兼容\t允许的请求Header nginx.ingress.kubernetes.io/cors-expose-headers\tIngress\t兼容\t允许的暴露给浏览器的响应Header nginx.ingress.kubernetes.io/cors-allow-credentials\tIngress\t兼容\t是否允许携带凭证信息 nginx.ingress.kubernetes.io/cors-max-age\tIngress\t兼容\t预检结果的最大缓存时间 超时​ 注解\t作用域\t支持度\t说明higress.io/timeout\tIngress\tHigress 扩展\t请求的超时时间，单位为秒。默认未配置超时时间。超时设置作用在应用层，非传输层TCP。 单机限流​ 注解\t作用域\t支持度\t说明higress.io/route-limit-rpm\tIngress\tHigress 扩展\t该Ingress定义的路由在每个网关实例上每分钟最大请求次数。瞬时最大请求次数为该值乘以limit-burst-multiplier。 higress.io/route-limit-rps\tIngress\tHigress 扩展\t该Ingress定义的路由在每个网关实例上每秒最大请求次数。瞬时最大请求次数为该值乘以limit-burst-multiplier。 higress.io/route-limit-burst-multiplier\tIngress\tHigress 扩展\t瞬时最大请求次数的因子，默认为5。 重试​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/proxy-next-upstream-tries\tIngress\t兼容\t请求的最大重试次数。默认3次。 nginx.ingress.kubernetes.io/proxy-next-upstream-timeout\tIngress\t兼容\t请求重试的超时时间，单位秒。默认未配置超时时间。 nginx.ingress.kubernetes.io/proxy-next-upstream\tIngress\t兼容\t请求重试条件，参考http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream 后端服务使用的协议​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/backend-protocol\t服务\t部分兼容。不支持AJP和FCGI\t指定后端服务使用的协议，默认为HTTP，支持HTTP、HTTP2、HTTPS、GRPC和GRPCS 负载均衡​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/load-balance\t服务\t部分兼容。不支持ewma算法\t后端服务的普通负载均衡算法。默认为round_robin。 合法值如下： - round_robin：基于轮询的负载均衡。 - least_conn：基于最小请求数的负载均衡。 - random：基于随机的负载均衡。 &gt; 注意：Higress不支持ewma算法，若配置为ewma算法，会回退到round_robin算法。 nginx.ingress.kubernetes.io/upstream-hash-by\t服务\t部分兼容。暂不支持Nginx变量、常量的组合使用方式\t基于一致Hash的负载均衡算法，Higress支持以下几种形式： 1. Higress支持配置部分nginx变量： - $request_uri：请求的Path（包括路径参数）作为Hash Key - $host：请求的Host作为Hash Key - $remote_addr：请求的客户端IP作为Hash Key。 2. 基于请求header的一致性Hash。您只需配置为$http_headerName。 3. 基于请求路径参数的一致性Hash。您只需配置为$arg_varName Cookie亲和性​ 注解\t作用\t支持度\t说明nginx.ingress.kubernetes.io/affinity\t服务\t兼容\t亲和性种类，目前只支持cookie，默认为cookie。 nginx.ingress.kubernetes.io/affinity-mode\t服务\t部分兼容。暂不支持persistent模式\t亲和性模式，云原生网关目前只支持balanced模式，默认为balanced模式。 nginx.ingress.kubernetes.io/session-cookie-name\t服务\t兼容\t配置指定Cookie的值作为Hash Key nginx.ingress.kubernetes.io/session-cookie-path\t服务\t兼容\t当指定Cookie不存在，生成的Cookie的Path值，默认为/ nginx.ingress.kubernetes.io/session-cookie-max-age\t服务\t兼容\t当指定Cookie不存在，生成的Cookie的过期时间，单位为秒，默认为Session会话级别。 nginx.ingress.kubernetes.io/session-cookie-expires\t服务\t兼容\t当指定Cookie不存在，生成的Cookie的过期时间，单位为秒，默认为Session会话级别。 IP访问控制​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/whitelist-source-range\tIngress\t兼容\t指定路由上的IP白名单，支持IP地址或CIDR地址块，以逗号分隔。 ","version":"Next","tagName":"h3"},{"title":"安全防护​","type":1,"pageTitle":"Ingress Annotaion 配置说明","url":"/zh-cn/docs/user/annotation#安全防护","content":"客户端与网关之前的通信加密​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/ssl-cipher\t域名\t兼容\t指定tls的加密套件，可以指定多个，英文逗号分隔，仅当tls握手时采用TLSv1.0-1.2生效。 默认加密套件如下： - ECDHE-ECDSA-AES128-GCM-SHA256 - ECDHE-RSA-AES128-GCM-SHA256 - ECDHE-ECDSA-AES128-SHA - ECDHE-RSA-AES128-SHA - AES128-GCM-SHA256 - AES128-SHA - ECDHE-ECDSA-AES256-GCM-SHA384 - ECDHE-RSA-AES256-GCM-SHA384 - ECDHE-ECDSA-AES256-SHA - ECDHE-RSA-AES256-SHA - AES256-GCM-SHA384 - AES256-SHA nginx.ingress.kubernetes.io/auth-tls-secret\t域名\t部分兼容。secret名字格式必须是：(该域名证书所在的secret的名字)-cacert\t网关使用的CA证书，用于验证MTLS握手期间，客户端提供的证书。该注解主要应用于网关需要验证客户端身份的场景。 网关与后端服务之间通信加密​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/proxy-ssl-secret\t服务\t兼容\t网关使用的客户端证书，用于后端服务对网关进行身份认证 nginx.ingress.kubernetes.io/proxy-ssl-name\t服务\t兼容\tTLS握手期间使用的SNI nginx.ingress.kubernetes.io/proxy-ssl-server-name\t服务\t兼容\t开启或关闭TLS握手期间使用SNI 安全认证​ Basic​ 注解\t作用域\t支持度\t说明nginx.ingress.kubernetes.io/auth-type\tIngress\t部分兼容。暂只支持Basic。\t认证类型 nginx.ingress.kubernetes.io/auth-secret\tIngress\t兼容\tSecret名字，格式支持&lt;namespace&gt;/&lt;name&gt;，包含被授予能够访问该Ingress上定义的路由的访问权限的用户名和密码。 nginx.ingress.kubernetes.io/auth-secret-type\tIngress\t兼容\tSecret内容格式。 - auth-file：data的key为auth；value为用户名和密码，多帐号回车分隔 - auth-map：data的key为用户名；value为密码 nginx.ingress.kubernetes.io/auth-realm\tIngress\t兼容\t保护域。相同的保护域共享用户名和密码。 ","version":"Next","tagName":"h3"},{"title":"备注​","type":1,"pageTitle":"Ingress Annotaion 配置说明","url":"/zh-cn/docs/user/annotation#备注","content":"关于以上提到的Nginx Ingress Annotation的更多信息，请参阅官方文档（https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#annotations）。 ","version":"Next","tagName":"h2"},{"title":"请求/响应转换","type":0,"sectionRef":"#","url":"/zh-cn/docs/plugins/transformation/transformer","content":"","keywords":"higress transformer","version":"Next"},{"title":"功能说明​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#功能说明","content":"transformer 插件可以对请求/响应头、请求查询参数、请求/响应体参数进行转换，支持的转换操作类型包括删除、重命名、更新、添加、追加、映射、去重。 ","version":"Next","tagName":"h2"},{"title":"配置字段​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#配置字段","content":"名称\t数据类型\t填写要求\t默认值\t描述reqRules\tstring\t选填，reqRules 和 respRules 至少填一个\t-\t请求转换器配置，指定转换操作类型以及请求头、请求查询参数、请求体的转换规则 respRules\tstring\t选填，reqRules 和 respRules 至少填一个\t-\t响应转换器配置，指定转换操作类型以及响应头、响应体的转换规则 reqRules 和 respRules 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述operate\tstring\t必填，可选值为 remove, rename, replace, add, append, map, dedupe\t-\t指定转换操作类型，支持的操作类型有删除 (remove)、重命名 (rename)、更新 (replace)、添加 (add)、追加 (append)、映射 (map)、去重 (dedupe)，当存在多项不同类型的转换规则时，按照上述操作类型顺序依次执行 mapSource\tstring\t选填，可选值为 headers, querys,body\t-\t仅在 operate 为 map 时有效。指定映射来源，若不填该字段，则默认映射来源为自身 headers\tarray of object\t选填\t-\t指定请求/响应头转换规则 querys\tarray of object\t选填\t-\t指定请求查询参数转换规则 body\tarray of object\t选填\t-\t指定请求/响应体参数转换规则，请求体转换允许 content-type 为 application/json, application/x-www-form-urlencoded, multipart/form-data；响应体转换仅允许 content-type 为 application/json headers, querys, body 中每一项的配置字段说明如下： 名称\t数据类型\t填写要求\t默认值\t描述key\tstring\t选填\t-\t在 operate 为 remove 时使用，用法详见转换操作类型 oldKey\tstring\t选填\t-\t在 operate 为 rename 时使用，用法详见转换操作类型 newKey\tstring\t选填\t-\t在 operate为 rename 时使用，用法详见转换操作类型 key\tstring\t选填\t-\t在 operate 为 replace 时使用，用法详见转换操作类型 newValue\tstring\t选填\t-\t在 operate 为 replace 时使用，用法详见转换操作类型 key\tstring\t选填\t-\t在 operate 为 add 时使用，用法详见转换操作类型 value\tstring\t选填\t-\t在 operate 为 add时使用，用法详见转换操作类型 key\tstring\t选填\t-\t在 operate 为 append 时使用，用法详见转换操作类型 appendValue\tstring\t选填\t-\t在 operate 为 append 时使用，用法详见转换操作类型 fromKey\tstring\t选填\t-\t在 operate 为 map 时使用，用法详见转换操作类型 toKey\tstring\t选填\t-\t在 operate 为 map 时使用，用法详见转换操作类型 key\tstring\t选填\t-\t在 operate 为 dedupe 时使用，用法详见转换操作类型 strategy\tstring\t选填\t-\t在 operate 为 dedupe 时使用，用法详见转换操作类型 value_type\tstring\t选填，可选值为 object, boolean, number, string\tstring\t当 content-type: application/json 时，该字段指定请求/响应体参数的值类型 host_pattern\tstring\t选填\t-\t指定请求主机名匹配规则，当转换操作类型为 replace, add, append 时有效 path_pattern\tstring\t选填\t-\t指定请求路径匹配规则，当转换操作类型为 replace, add, append 时有效 注意： request transformer 支持以下转换对象：请求头部、请求查询参数、请求体（application/json, application/x-www-form-urlencoded, multipart/form-data）response transformer 支持以下转换对象：响应头部、响应体（application/json）插件支持双向转换能力，即单个插件能够完成对请求和响应都做转换转换操作类型的执行顺序，为配置文件中编写的顺序，如：remove → rename → replace → add → append → map → dedupe或者dedupe → map → append → add → replace → rename → remove等当转换对象为 headers 时，key 不区分大小写；当为 headers 且为 rename, map 操作时，value 也不区分大小写（因为此时该字段具有 key 含义）；而 querys 和 body 的 key, value 字段均区分大小写value_type 仅对 content-type 为 application/json 的请求/响应体有效host_pattern 和 path_pathern 支持 RE2 语法，仅对 replace, add, append 操作有效，且在一项转换规则中两者只能选填其一，若均填写，则 host_pattern 生效，而 path_pattern 失效 ","version":"Next","tagName":"h2"},{"title":"Higress参数配置","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/configurations","content":"","keywords":"Higress","version":"Next"},{"title":"Global参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#global参数","content":"参数\t参数说明\t默认值global.ingressClass\tIngressClass 参数用于筛选 Higress 控制器要监听的 Ingress 资源。在集群内部署了多个网关时，可以使用这一参数来区分每个网关的职责范围 。IngressClass 有一些特殊的取值：1. 如果设置为“nginx”，Higress Controller 将监听 Ingress 为 nginx 或为空的 Ingress 资源。2. 如果设为空，Higress Controller 将监听 K8s 集群内的全部 Ingress 资源。\thigress global.watchNamespace\t如果值不为空，Higress Controller 将只会监听指定命名空间下的资源。当基于 K8s 命名空间进行业务系统隔离时，若需要对每个命名空间部署一套独立的网关，可以通过这一参数来限制 Higress 监听指定命名空间内的 Ingress。\t&quot;&quot; global.disableAlpnH2\t是否在 ALPN 中禁用 HTTP/2 协议\tfalse global.enableStatus\t若为true， Higress Controller 将会更新 Ingress 资源的 status 字段。为避免从 Nginx Ingress 迁移过程中，覆盖 Ingress 对象的 status 字段，可以将这一参数设置为false，这样 Higress 默认就不会将入口 IP 写入 Ingress 的 status 字段。\ttrue global.local\t如果要安装至本地 K8s 集群（如 Kind、Rancher Desktop 等），请设置为 true\tfalse global.enableIstioAPI\t若为 true，Higress Controller 将同时监听 istio 资源\tfalse global.enableGatewayAPI\t若为 true，Higress Controller 将同时监听 Gateway API 资源\tfalse global.imagePullPolicy\t如果不希望使用默认行为，则可以指定镜像拉取策略。默认行为：最新的镜像将始终以 Always 方式拉取，否则将以 IfNotPresent 方式拉取。\t&quot;&quot; global.imagePullSecrets\t为所有 ServiceAccount 配置 ImagePullSecrets，即在同一命名空间中列出的一组密钥，用于拉取任何引用此 ServiceAccount 的 pod 中的镜像。对于不使用 ServiceAccount 的组件（例如 grafana、servicegraph、tracing），ImagePullSecrets 将被添加到相应的 Deployment（StatefulSet）对象中。对于配置了私有 Docker Registry 的任何集群，都必须设置此项。\t[] global.defaultUpstreamConcurrencyThreshold\t单个数据面实例和后端服务之间的最大并发（不同服务独立计算），注意过多并发可能导致网关内存过高，请相应调高数据面内存限制\t10000 global.o11y.enabled\t若为 true，将同时安装可观测性套件（Grafana、Promethues、Loki、PromTail 等）。\tfalse global.pvc.rwxSupported\tRwxSupported 参数用于指示是否支持读写多个 Pod，即是否支持共享卷。如果该参数设置为 true，则表明支持共享卷，多个 Pod 可以同时挂载该 PVC，进行读写操作。如果设置为 false，则表明不支持共享卷，只有一个 Pod 可以挂载该 PVC 进行读写操作。\ttrue global.onlyPushRouteCluster\t若为true，Higress Controller 将会只推送被路由关联的服务\ttrue global.priorityClassName\tHigress Controller 和 Higress Gateway Pod 的 PriorityClass 名称\t ","version":"Next","tagName":"h2"},{"title":"meshConfig参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#meshconfig参数","content":"参数\t参数说明\t默认值higress-core.meshConfig.enablePrometheusMerge\t用于启用或禁用将 Prometheus 指标进行合并的选项。通过启用它，Istio 将能够将来自多个代理的指标进行聚合和展示。\ttrue higress-core.meshConfig.rootNamespace\t表示根命名空间。如果未指定，则默认为 &quot;istio-system&quot;。\tnull higress-core.meshConfig.trustDomain\t表示信任域。默认为 &quot;cluster.local&quot;。信任域用于确定服务之间的安全通信，它将用于生成服务的证书和 JWT Token。\tcluster.local ","version":"Next","tagName":"h2"},{"title":"Gateway参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#gateway参数","content":"参数\t参数说明\t默认值higress-core.gateway.replicas\tHigress Gateway 的 pod 数量。\t2 higress-core.gateway.rbac.enabled\t如果启用，则将创建 roles 以便从 Gateways 访问证书。但在使用 http://gateway-api.org/ 时，这不是必需的\ttrue higress-core.gateway.serviceAccount.create\t指定是否创建 ServiceAccount, 否则，使用默认值。\ttrue higress-core.gateway.serviceAccount.annotations\t指定需要添加到 ServiceAccount 上的注释。\t{} higress-core.gateway.serviceAccount.name\t指定要使用的 ServiceAccount 的名称。\t&quot;&quot; higress-core.gateway.env\t指定 Gateway 使用的环境变量。\t{} higress-core.gateway.hostNetwork\t指定是否使用宿主机网络。\tfalse higress-core.gateway.labels\t指定应用于所有 gateway 资源的标签。\t{} higress-core.gateway.annotations\t指定要应用于所有 gateway 资源的注释。\t{} higress-core.gateway.podAnnotations.prometheus.io/port\t指定 Prometheus 监控的端口。\t15020 higress-core.gateway.podAnnotations.prometheus.io/scrape\t指示 Prometheus 是否应该监控该 Pod 。如果该值为&quot;true&quot;，则 Prometheus 将监控该 Pod ；如果该值为 &quot;false&quot; ，则不会监控该 Pod 。\ttrue higress-core.gateway.podAnnotations.prometheus.io/path\t指定 Prometheus 监控该 Pod 时，需要访问的 URL 路径。在这里设置为&quot;/stats/prometheus&quot;。\t/stats/prometheus higress-core.gateway.service.type\t指定 Service 的类型\tLoadBalancer higress-core.gateway.service.loadBalancerIP\t指定 LoadBalancer 的 IP 地址\t&quot;&quot; higress-core.gateway.service.loadBalancerSourceRanges\t指定 LoadBalancer 允许的源 IP 范围。\t[] higress-core.gateway.service.annotations\t指定要应用到 Service 上的注释。\t{} higress-core.gateway.service.externalTrafficPolicy\t指定 Service 的外部流量策略。\t&quot;&quot; higress-core.gateway.rollingMaxSurge\t指定滚动更新期间的最大扩容数量\t100% higress-core.gateway.rollingMaxUnavailable\t指定滚动更新期间的最大不可用数量。\t25% higress-core.gateway.resources.limits.cpu\t指定 gateway 容器的CPU请求资源限制。\t2000m higress-core.gateway.resources.limits.memory\t指定 gateway 容器的内存请求资源限制。\t2048Mi higress-core.gateway.resources.requests.cpu\t指定 gateway 容器的CPU请求资源。\t2000m higress-core.gateway.resources.requests.memory\t指定 gateway 容器的内存请求资源。\t2048Mi higress-core.gateway.autoscaling.enabled\t指定是否启用 gateway Pod 自动缩放。\tfalse higress-core.gateway.autoscaling.minReplicas\t允许的最小副本数。\t1 higress-core.gateway.autoscaling.maxReplicas\t允许的最大副本数。\t5 higress-core.gateway.autoscaling.targetCPUUtilizationPercentage\t表示 HPA 应该尝试将 Pod 的 CPU 利用率维持在什么水平。\t80 higress-core.gateway.nodeSelector\t节点选择器，用于确定 gatyway 容器将部署在哪些节点上。\t{} higress-core.gateway.tolerations\t容忍度，用于允许 gateway 容器调度到具有指定污点的节点。\t[] higress-core.gateway.affinity\t亲和性，用于控制 gateway容器如何调度，使其与其他 Pod 或节点保持亲和或反亲和。\t{} higress-core.gateway.networkGateway\t用于指定网络网关的名称或 IP 地址。\t&quot;&quot; ","version":"Next","tagName":"h2"},{"title":"Controller参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#controller参数","content":"参数\t参数说明\t默认值higress-core.controller.replicas\tHigress Controller 的 pod 数量。\t1 higress-core.controller.env\t指定容器所需的任何环境变量。\t{} higress-core.controller.labels\t指定部署 controller 容器的标签\t{} higress-core.controller.probe.httpGet.path\t容器的健康检查配置信息，使用 HTTP GET 请求检查容器的 /ready 路径\t/ready higress-core.controller.probe.httpGet.port\t指定健康检查配置端口。\t8888 higress-core.controller.probe.initialDelaySeconds\t指定容器启动后首次进行健康检查的延迟时间。\t1 higress-core.controller.probe.periodSeconds\t指定进行健康检查的时间间隔。\t3 higress-core.controller.probe.timeoutSeconds\t指定等待健康检查响应的超时时间\t5 higress-core.controller.imagePullSecrets\t指定用于拉取容器镜像的密钥信息\t[] higress-core.controller.rbac.create\t定义是否应该创建与此部署相关的 RBAC 规则。\ttrue higress-core.controller.serviceAccount.create\t指定是否应该创建 serviceAccount 。\ttrue higress-core.controller.serviceAccount.annotations\t指定要添加到 serviceAccount 的注释。\t{} higress-core.controller.serviceAccount.name\t指定要使用的 serviceAccount 的名称，如果未设置且 create 为 true ，则使用 fullname 模板生成名称。\t&quot;&quot; higress-core.controller.podAnnotations\t指定要添加到 controller 容器的注释。\t{} higress-core.controller.podSecurityContext\t指定 Pod 的安全上下文。\t{} higress-core.controller.service.type\t指定 Service 的类型为 ClusterIP。\tClusterIP higress-core.controller.securityContext\t指定 controller 容器的安全上下文。\t{} higress-core.controller.resources.requests.cpu\t分配给 controller 的 CPU 资源请求。\t500m higress-core.controller.resources.requests.memory\t分配给 controller 的内存资源请求。\t2048Mi higress-core.controller.resources.limits.cpu\t分配给 controller 的 CPU 资源请求限制。\t1000m higress-core.controller.resources.limits.memory\t分配给 controller 的内存资源请求限制。\t2048Mi higress-core.controller.nodeSelector\t用于指定 Pod 调度到特定节点的标签选择器\t{} higress-core.controller.tolerations\t用于指定 Pod 的容忍性，即容忍某些节点上的特定污点。\t[] higress-core.controller.affinity\t用于指定 Pod 的亲和性，即将 Pod 调度到特定节点或节点组。\t{} higress-core.controller.autoscaling.enabled\t指定是否启用 Pod 的自动缩放。\tfalse higress-core.controller.autoscaling.minReplicas\t指定自动缩放的最小 Pod 数量。\t1 higress-core.autoscaling.maxReplicas\t指定自动缩放的最大 Pod 数量。\t5 higress-core.autoscaling.targetCPUUtilizationPercentage\t指定自动缩放调整 Pod 数量的目标 CPU 利用率百分比。\t80 ","version":"Next","tagName":"h2"},{"title":"Pilot参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#pilot参数","content":"参数\t参数说明\t默认值higress-core.pilot.autoscaleEnabled\t是否启用 Pilot 的自动伸缩。\tfalse higress-core.pilot.autoscaleMin\t自动伸缩时最小的副本数。\t1 higress-core.pilot.autoscaleMax\t自动伸缩时最大的副本数。\t5 higress-core.pilot.replicaCount\tPilot 的 pod 数量。\t1 higress-core.pilot.rollingMaxSurge\t在进行滚动更新时，允许同时增加的 Pod 数量的最大比例。\t100% higress-core.pilot.rollingMaxUnavailable\t在进行滚动更新时，允许同时不可用的 Pod 数量的最大比例。\t25% higress-core.pilot.traceSampling\t指定应用程序的跟踪采样率，这里是1.0（即100%）。\t1 higress-core.pilot.resources.requests.cpu\t分配给 pilot 的 CPU 资源请求。\t500m higress-core.pilot.resources.requests.memory\t分配给 pilot 的内存资源请求。\t2048Mi higress-core.pilot.env.PILOT_SCOPE_GATEWAY_TO_NAMESPACE\t如果设置为 true ，则使网关只能访问其所在的命名空间中的服务。\ttrue higress-core.pilot.env.PILOT_ENABLE_METADATA_EXCHANGE\t如果设置为 false ，则禁用与 Envoy 之间的元数据交换。\tfalse higress-core.pilot.env.PILOT_ENABLE_CROSS_CLUSTER_WORKLOAD_ENTRY\t如果设置为 false ，则禁用跨集群工作负载入口。\tfalse higress-core.pilot.env.VALIDATION_ENABLED\t如果设置为 false ，则禁用对配置文件的验证。\tfalse higress-core.pilot.cpu.targetAverageUtilization\t指定 Pod 应该尝试达到的 CPU 利用率百分比，以便触发自动缩放。例如，如果设置为80，则当 Pod 的 CPU 利用率达到80％时，将启动更多的 Pod 以处理更多的负载。\t80 higress-core.pilot.enableProtocolSniffingForOutbound\t是否在出站流量上启用协议嗅探，这里是 true 。\ttrue higress-core.pilot.enableProtocolSniffingForInbound\t是否在入站流量上启用协议嗅探，这里是 true 。\ttrue higress-core.pilot.nodeSelector\t指定应该部署此应用程序的节点标签。\t{} higress-core.pilot.podAnnotations\t指定要添加到 Pod 的注释。\t{} higress-core.pilot.serviceAnnotations\t指定要添加到 Service 的注释。\t{} higress-core.pilot.jwksResolverExtraRootCA\t提供 PEM 格式的根证书，以便在解析 JWKS URI 时由 pilot 信任。\t&quot;&quot; higress-core.pilot.configSource.subscribedResources\t指定配置源的来源，如果未指定，则使用默认的 MCP 。指定订阅的 Kubernetes 资源列表。\t[] higress-core.pilot.plugins\t指定要启用的插件列表。\t[] higress-core.pilot.keepaliveMaxServerConnectionAge\t限制 gateway 与 controller 连接的最长时间。\t30m higress-core.pilot.deploymentLabels\t为部署添加额外的标签。\t{} higress-core.pilot.configMap\t安装由values.yaml生成的 mesh config ，如果为 false ，则 Pilot 将使用默认值（默认情况下）或用户提供的值，如果为 false ，则 Pilot 将使用默认值（默认情况下）或用户提供的值\ttrue higress-core.pilot.podLabels\t为 Pod 添加额外的标签，以用于监控和日志记录配置。\t{} ","version":"Next","tagName":"h2"},{"title":"SkyWalking参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#skywalking参数","content":"参数\t参数说明\t默认值higress-core.skywalking.enabled\t是否启用 SkyWalking\tfalse higress-core.skywalking.service.address\tSkyWalking 服务地址，如果不指定则使用默认值\t~ higress-core.skywalking.service.port\tSkyWalking 服务端口，默认为 11800\t11800 ","version":"Next","tagName":"h2"},{"title":"控制台参数​","type":1,"pageTitle":"Higress参数配置","url":"/zh-cn/docs/user/configurations#控制台参数","content":"参数\t参数说明\t默认值higress-console.replicaCount\tHigress Console 的 pod 数量\t1 higress-console.dnsPolicy\t指定 DNS 策略，这里为 ClusterFirst 。\tClusterFirst higress-console.restartPolicy\t指定重启策略，这里指定为 Always 。\tAlways higress-console.service.type\t指定控制台 service 类型。\tClusterIP higress-console.resources.requests.cpu\t分配给 console 的 CPU 资源请求。\t250m higress-console.resources.requests.memory\t分配给 console 的内存资源请求。\t512Mi higress-console.web.login.prompt\t登录页面上显示的提示信息，默认为空。\t&quot;&quot; higress-console.certmanager.enabled\t指定是否启用证书管理器。\tfalse higress-console.certmanager.replicas\tCertmanage pod 的数量。\t1 higress-console.o11y.grafana.replicas\tGrafana pod 的数量。\t1 higress-console.o11y.grafana.storage\t分配给 Grafana 的存储类大小。\t1Gi higress-console.o11y.grafana.pvc.storageClassName\tGrafana 的存储类名称。\t&quot;&quot; higress-console.o11y.prometheus.replicas\tPrometheus pod 的数量。\t1 higress-console.o11y.prometheus.storage\t分配给 prometheus 的存储类大小。\t1Gi higress-console.o11y.prometheus.pvc.storageClassName\tPrometheus 的存储类名称。\t&quot;&quot; higress-console.o11y.prometheus.resources.limits.cpu\t分配给 prometheus 的 CPU 资源限制。\t500m higress-console.o11y.prometheus.resources.limits.memory\t分配给 prometheus 的内存资源限制。\t2Gi ","version":"Next","tagName":"h2"},{"title":"通过Ingress Annotation实现高阶流量治理","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/annotation-use-case","content":"","keywords":"Ingress Annotation","version":"Next"},{"title":"前提条件​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#前提条件","content":"安装Higress已拥有一个Kubernetes集群，且配置了kubectl命令行工具 ","version":"Next","tagName":"h2"},{"title":"灰度发布​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#灰度发布","content":"Higress提供复杂的路由处理能力，支持基于Header、Cookie以及权重的灰度发布功能。灰度发布功能可以通过设置注解来实现，为了启用灰度发布功能，需要设置注解higress.io/canary: &quot;true&quot;。通过不同注解可以实现不同的灰度发布功能。 说明：当多种方式同时配置时，灰度方式选择优先级为：基于Header &gt; 基于Cookie &gt; 基于权重（从高到低）。 ","version":"Next","tagName":"h2"},{"title":"基于Header灰度发布​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#基于header灰度发布","content":"只配置higress.io/canary-by-header：基于Request Header的名称进行流量切分。当请求包含该Header并其值为always时，请求流量会被分配到灰度服务入口；其他情况时，请求流量不会分配到灰度服务。同时配置higress.io/canary-by-header和higress.io/canary-by-header-value：基于Request Header的名称和值进行流量切分。当请求中的header的名称和header的值与该配置匹配时，请求流量会被分配到灰度服务；其他情况时，请求流量不会分配到灰度服务。 Higress灰度发布时支持多个版本服务（无上限）。 请求Header为higress：always时将访问灰度服务demo-service-canary；其他情况将访问正式服务demo-service，配置如下： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-by-header: &quot;higress&quot; name: demo-canary spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: demo spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service port: number: 80 path: /hello pathType: Exact  请求Header为higress：v1时将访问灰度服务demo-service-canary-v1；请求Header为higress：v2时将访问灰度服务demo-service-canary-v2；其他情况将访问正式服务demo-service，配置如下： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-by-header: &quot;higress&quot; higress.io/canary-by-header-value: &quot;v1&quot; name: demo-canary-v1 spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary-v1 port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-by-header: &quot;higress&quot; higress.io/canary-by-header-value: &quot;v2&quot; name: demo-canary-v2 spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary-v2 port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: demo spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service port: number: 80 path: /hello pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"基于Cookie灰度发布​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#基于cookie灰度发布","content":"higress.io/canary-by-cookie：基于Cookie的Key进行流量切分。当请求的Cookie中含有该Key且其值为always时，请求流量将被分配到灰度服务；其他情况时，请求流量将不会分配到灰度服务。 说明：基于Cookie的灰度发布不支持自定义设置Key对应的值，只能是always。 请求的Cookie为demo=always时将访问灰度服务demo-service-canary；其他情况将访问正式服务demo-service。配置如下： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-by-cookie: &quot;demo&quot; name: demo-canary spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: demo spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service port: number: 80 path: /hello pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"基于权重灰度发布​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#基于权重灰度发布","content":"higress.io/canary-weight：设置请求到指定服务的百分比（值为0~100的整数）higress.io/canary-weight-total：设置权重总和，默认为100 配置灰度服务demo-service-canary-v1的权重为30%，配置灰度服务demo-service-canary-v2的权重为20%，配置正式服务demo-service的权重为50%。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-weight: &quot;30&quot; name: demo-canary-v1 spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary-v1 port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-weight: &quot;20&quot; name: demo-canary-v2 spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary-v2 port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: demo spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service port: number: 80 path: /hello pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"跨域​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#跨域","content":"跨域资源共享CORS（Cross-Origin Resource Sharing）是指允许Web应用服务器进行跨域访问控制，从而实现跨域数据安全传输。 higress.io/enable-cors：&quot;true&quot; or &quot;false&quot;。开启或关闭跨域。higress.io/cors-allow-origin：允许的第三方站点，支持泛域名，逗号分隔；支持通配符。默认值为，即允许所有第三方站点。higress.io/cors-allow-methods：允许的请求方法，如GET、POST，逗号分隔；支持通配符*。默认值为GET, PUT, POST, DELETE, PATCH, OPTIONS。higress.io/cors-allow-headers：允许的请求头部，逗号分隔；支持通配符*。默认值为DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization。higress.io/cors-expose-headers：允许的响应头部，逗号分隔。higress.io/cors-allow-credentials：&quot;true&quot; or &quot;false&quot;。是否允许携带凭证信息。默认允许。higress.io/cors-max-age：预检结果的最大缓存时间，单位为秒；默认值为1728000。 跨域请求被限制为只能来自example.com域的请求，并且HTTP方法只能是GET和POST，允许的请求头部为X-Foo-Bar，不允许携带凭证信息。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/enable-cors: &quot;true&quot; higress.io/cors-allow-origin: &quot;example.com&quot; higress.io/cors-allow-methods: &quot;GET,POST&quot; higress.io/cors-allow-headers: &quot;X-Foo-Bar&quot; higress.io/cors-allow-credentials: &quot;false&quot; name: demo spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service port: number: 80 path: /hello pathType: Exact  ","version":"Next","tagName":"h2"},{"title":"Rewrite重写Path和Host​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#rewrite重写path和host","content":"在请求转发给目标后端服务之前，重写可以修改原始请求的路径（Path）和主机域（Host)。 higress.io/rewrite-target：重写Path，支持捕获组（Capture Group)。higress.io/upstream-vhost：重写Host。 ","version":"Next","tagName":"h2"},{"title":"Rewrite重写Path​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#rewrite重写path","content":"将请求example.com/test在转发至后端服务之前，重写为example.com/dev apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/rewrite-target: &quot;/dev&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  将请求example.com/v1/app在转发至后端服务之前，去掉Path前缀/v1 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/rewrite-target: &quot;/$2&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /v1(/|$)(.*) pathType: ImplementationSpecific  将请求example.com/v1/app在转发至后端服务之前，将Path前缀/v1更改为/v2 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/rewrite-target: &quot;/v2/$2&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /v1(/|$)(.*) pathType: ImplementationSpecific  ","version":"Next","tagName":"h3"},{"title":"Rewrite重写Host​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#rewrite重写host","content":"将请求example.com/test在转发至后端服务之前，重写为test.com/test apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/upstream-vhost: &quot;test.com&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"重定向​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#重定向","content":"通过重定向可以将原始客户端请求更改为目标请求。 ","version":"Next","tagName":"h2"},{"title":"配置HTTP重定向至HTTPS​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#配置http重定向至https","content":"higress.io/ssl-redirect：HTTP重定向到HTTPShigress.io/force-ssl-redirect: HTTP重定向到HTTPS 说明：Higress对于以上两个注解不区分对待，都是强制将HTTP重定向到HTTPS。 将请求http://example.com/test重定向为https://example.com/test。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/ssl-redirect: &quot;true&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"永久重定向​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#永久重定向","content":"higress.io/permanent-redirect：永久重定向的目标url，必须包含scheme（http or https)。higress.io/permanent-redirect-code：永久重定向的HTTP状态码，默认为301。 将请求http://example.com/test永久重定向为http://example.com/app。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/permanent-redirect: &quot;http://example.com/app&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"临时重定向​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#临时重定向","content":"higress.io/temporal-redirect：临时重定向的目标url，必须包含scheme（http or https)。 将请求http://example.com/test临时重定向为http://example.com/app。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/temporal-redirect: &quot;http://example.com/app&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"Header控制​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#header控制","content":"通过Header控制，您可以在转发请求到后端服务之前对请求Header进行增删改，在收到响应转发给客户端时对响应Header进行增删改。 ","version":"Next","tagName":"h2"},{"title":"请求Header控制​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#请求header控制","content":"higress.io/request-header-control-add：请求在转发给后端服务时，添加指定Header。若该Header存在，则其值拼接在原有值后面。语法如下： 单个Header：Key Value多个Header：使用yaml特殊符号 |，每对Key Value单独处于一行 higress.io/request-header-control-update：请求在转发给后端服务时，修改指定Header。若该header存在，则其值覆盖原有值。语法如下： 单个Header：Key Value多个Header：使用yaml特殊符号 |，每对Key Value单独处于一行 higress.io/request-header-control-remove：请求在转发给后端服务时，删除指定Header。语法如下： 单个Header：Key多个Header：逗号分隔 对于请求example.com/test添加两个Header，foo: bar和test: true。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/request-header-control-add: | foo bar test true name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  Header控制可以结合灰度发布，对灰度流量进行染色。请求Header为higress：v1时将访问灰度服务demo-service-canary-v1，并添加Header，stage: gray；其他情况将访问正式服务demo-service，并添加Header，stage: production。配置如下： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/canary: &quot;true&quot; higress.io/canary-by-header: &quot;higress&quot; higress.io/canary-by-header-value: &quot;v1&quot; higress.io/request-header-control-add: &quot;stage gray&quot; name: demo-canary-v1 spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service-canary-v1 port: number: 80 path: /hello pathType: Exact --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/request-header-control-add: &quot;stage production&quot; name: demo spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo-service port: number: 80 path: /hello pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"响应Header控制​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#响应header控制","content":"higress.io/response-header-control-add：请求在收到后端服务响应之后并且转发响应给客户端之前，添加指定Header。若该Header存在，则其值拼接在原有值后面。语法如下： 单个Header：Key Value多个Header：使用yaml特殊符号 |，每对Key Value单独处于一行 higress.io/response-header-control-update：请求在收到后端服务响应之后并且转发响应给客户端之前，修改指定Header。若该header存在，则其值覆盖原有值。语法如下： 单个Header：Key Value多个Header：使用yaml特殊符号 |，每对Key Value单独处于一行 higress.io/response-header-control-remove：请求在收到后端服务响应之后并且转发响应给客户端之前，删除指定Header。语法如下： 单个Header：Key多个Header：逗号分隔 对于请求example.com/test的响应删除Header：req-cost-time。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/response-header-control-remove: &quot;req-cost-time&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"重试​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#重试","content":"Higress提供路由级别的重试设置，可以为出错的请求调用自动进行重试。您可以按需设置重试条件，例如建立连接失败，或者后端服务不可用以及对指定HTTP状态码的响应等进行请求重试。 higress.io/proxy-next-upstream-tries：请求的最大重试次数。默认3次。higress.io/proxy-next-upstream-timeout：请求重试的超时时间，单位秒。默认未配置超时时间。higress.io/proxy-next-upstream：请求重试条件，逗号分隔；默认值为&quot;error,timeout&quot;。合法值如下： error：建立连接失败，请求出错5xx。timeout：建立连接超时，请求出错5xx。invalid_header：请求出错5xx。http_xxx：针对具体响应状态码的情况进行重试。例如http_502，http_403。non_idempotent：对于非幂等请求出错时进行重试。默认情况下，Higress针对非幂等POST、PATCH请求出错时不会进行重试，配置non_idempotent可以开启重试。off：关闭重试。 设置example/test请求的最大重试次数为2，重试超时时间为5s，只有在响应状态码为502才重试，并且开启非幂等重试。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/proxy-next-upstream-tries: &quot;2&quot; higress.io/proxy-next-upstream-timeout: &quot;5&quot; higress.io/proxy-next-upstream: &quot;http_502,non_idempotent&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h2"},{"title":"超时​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#超时","content":"Higress提供路由级别的超时设置，与nginx ingress不同，没有区分连接/读写超时，而是面向的接口处理总延时进行配置，在未进行配置时默认不限制，例如后端未返回应答，网关将无限等待。 设置超时时间为5s： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/timeout: &quot;5&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h2"},{"title":"单机限流​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#单机限流","content":"提示Higress商业版具备全局限流能力，详情查看商业版文档中全局限流一节的介绍 支持针对路由级别的单机限流策略，在设定的时间周期内，限制每个网关副本匹配在某个路由上的请求数量不大于阈值。该限流是针对单机级别，即配置的阈值在每个网关实例进行流控。 higress.io/route-limit-rpm：该Ingress定义的路由在每个网关实例上每分钟最大请求次数。瞬时最大请求次数为该值乘以limit-burst-multiplier。higress.io/route-limit-rps：该Ingress定义的路由在每个网关实例上每秒最大请求次数。瞬时最大请求次数为该值乘以limit-burst-multiplier。higress.io/route-limit-burst-multiplier：瞬时最大请求次数的因子，默认为5。 例如： 限制example.com/test的请求每分钟最大请求数为100，瞬时请求数200。配置如下： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/route-limit-rpm: &quot;100&quot; higress.io/route-limit-burst-multiplier: &quot;2&quot; name: demo spec: ingressClassName: mse rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  限制example.com/test的请求每秒最大请求数为10，瞬时请求数50。配置如下： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/route-limit-rps: &quot;10&quot; # 默认为5 # higress.io/route-limit-burst-multiplier: &quot;5&quot; name: demo spec: ingressClassName: mse rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h2"},{"title":"配置后端服务协议：HTTPS或GRPC​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#配置后端服务协议https或grpc","content":"Higress默认使用HTTP协议转发请求到后端业务容器。当您的业务容器为HTTPS协议时，可以通过使用注解higress.io/backend-protocol: &quot;HTTPS&quot;；当您的业务容器为GRPC服务时，可以通过使用注解higress.io/backend-protocol: &quot;GRPC&quot;。 说明：相比Nginx Ingress的优势，如果您的后端服务所属的K8s Service资源中关于Port Name的定义为grpc或http2，您无需配置注解higress.io/backend-protocol: &quot;GRPC&quot;，Higress会自动使用GRPC或者HTTP2。 请求example.com/test转发至后端服务使用HTTPS协议。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/backend-protocol: &quot;HTTPS&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: / pathType: Exact  请求example/grpcbin.GRPCBin转发至后端服务使用GRPC协议。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/backend-protocol: &quot;GRPC&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /grpcbin.GRPCBin pathType: Prefix  ","version":"Next","tagName":"h2"},{"title":"配置后端服务的负载均衡算法​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#配置后端服务的负载均衡算法","content":"负载均衡决定着网关在转发请求至后端服务时如何选择节点。 ","version":"Next","tagName":"h2"},{"title":"普通负载均衡算法​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#普通负载均衡算法","content":"higress.io/load-balance：后端服务的普通负载均衡算法。默认为round_robin。合法值如下： round_robin：基于轮询的负载均衡。least_conn：基于最小请求数的负载均衡。random：基于随机的负载均衡。 设置后端服务demo-service的负载均衡算法为least_conn。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/load-balance: &quot;least_conn&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /order pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"基于一致性Hash的负载均衡算法​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#基于一致性hash的负载均衡算法","content":"基于一致性Hash的负载均衡算法具备请求亲和性，具有相同特征的请求会始终负载到相同节点上。Higress支持基于部分Nginx 变量、请求Header和请求路径参数作为Hash Key。 higress.io/upstream-hash-by：基于一致Hash的负载均衡算法。Higress支持以下几种形式： 支持配置部分nginx变量： $request_uri：请求的Path（包括路径参数）作为Hash Key$host：请求的Host作为Hash Key$remote_addr：请求的客户端IP作为Hash Key 基于请求header的一致性Hash。您只需配置为$http_headerName。基于请求路径参数的一致性Hash。您只需配置为$arg_varName。 基于请求的客户端IP作为Hash Key，同一个客户端IP的请求始终负载到同一个节点。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/upstream-hash-by: &quot;$remote_addr&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  基于请求Header x-stage作为Hash key，带有x-stage头部的请求且值相同的请求始终负载到同一个节点。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/upstream-hash-by: &quot;$http_x-stage&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  基于请求路径参数 x-stage作为Hash key，带有路径参数x-stage的请求且值相同的请求始终负载到同一个节点。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/upstream-hash-by: &quot;$arg_x-stage&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h3"},{"title":"Cookie亲和性 （会话保持）​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#cookie亲和性-会话保持","content":"具备相同的Cookie的请求会被网关始终负载到同一个节点，并且如果第一次访问携带Cookie，Higress会在第一次响应时为客户端生成一个Cookie，用来保证后续的请求被网关始终负载到相同节点。 higress.io/affinity：亲和性种类，目前只支持cookie，默认为cookie。higress.io/affinity-mode：亲和性模式，Higress目前只支持balanced模式，默认为balanced模式。higress.io/session-cookie-name：配置指定Cookie的值作为Hash Key，默认为INGRESSCOOKIEhigress.io/session-cookie-path：当指定Cookie不存在，生成的Cookie的Path值，默认为/higress.io/session-cookie-max-age：当指定Cookie不存在，生成的Cookie的过期时间，单位为秒，默认为Session会话级别。higress.io/session-cookie-expires：当指定Cookie不存在，生成的Cookie的过期时间，单位为秒，默认为Session会话级别。 说明：max-age和expires都可以用来指定cookie过期时间。当session-cookie-max-age和session-cookie-expires同时配置时，Higress优先选取session-cookie-max-age作为过期时间。 开启Cookie亲和性，利用Higress的默认配置，即Cookie的名字为INGRESSCOOKIE，Path为/，Cookie的生命周期为Session会话级别。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/affinity: &quot;cookie&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  开启Cookie亲和性，Cookie的名字为test，Path为/，Cookie的过期时间为10s。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/affinity: &quot;cookie&quot; higress.io/session-cookie-name: &quot;test&quot; higress.io/session-cookie-max-age: &quot;10&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h2"},{"title":"网关与客户端双向认证(MTLS)​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#网关与客户端双向认证mtls","content":"当开启HTTPS时，网关与客户端默认是基于单向TLS认证，可以通过下面注解开启双向TLS认证，即让服务端同时校验客户端的合法性。 higress.io/auth-tls-secret: 网关使用的CA证书，用于验证MTLS握手期间，客户端提供的证书。该注解主要应用于网关需要验证客户端身份的场景。secret名字格式必须是：(该域名证书所在的secret的名字)-cacert 例如: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: # 这里的要求是必须以域名上配置证书secret名称后缀加上-cacert higress.io/auth-tls-secret: tls-secret-cacert name: bar namespace: default spec: ingressClassName: higress rules: - host: bar.com http: paths: - backend: service: name: bar-service port: number: 5678 path: / pathType: Prefix tls: - hosts: - bar.com secretName: tls-secret --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: foo namespace: default spec: ingressClassName: higress rules: - host: foo.com http: paths: - backend: service: name: foo-service port: number: 5678 path: / pathType: Prefix tls: - hosts: - foo.com secretName: tls-secret  tls-secret-cacert 这个 secret 的内容中必须有 cacert 这个key，例如： apiVersion: v1 data: cacert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURDekNDQWZPZ0F3SUJBZ0lVQ0tMSGM5SFhBbEFYNUdFR2dHVk1zVXhzUFhBd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0ZURVRNQkVHQTFVRUF3d0tSWGhoYlhCc1pTQkRRVEFlRncweU16RXlNakl3T1RNek1ESmFGdzB5TkRFeQpNakV3T1RNek1ESmFNQlV4RXpBUkJnTlZCQU1NQ2tWNFlXMXdiR1VnUTBFd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDaW1jaWQ4VWx4VzA4a1RTcmc1UnAzTlMvSmFMQWt3bVZzeWdEanc0TUEKSjh6Q2FWWHFmU2xpbCtTRFdLcllRYUtPQ1JRWjlWdXBwODl4UnRJTkpUVmlBZUpHYzh6SDY2Sy82aUZJZ2N4ZQplczVaaDdqQXdENzZ4eEtMUjJPbkRSb0xpVlFVOGxkekVNclVHRytCOXJ1TzFsNjkxNlRjQ0dqS3VGUklQNzJCCjlJcEI0ekxZUUNLWldmZ1cxVmU0alpYTUZ0MVhUc0dWdkhCaEt0MSt5eXMrNnc3WndxMW43NysxdXcya2dmM3cKaXNCbXBzTlRPVVJSZzVvdEdYVUUxaGl3dC9KeW9PQkt1YmVyY2dwd05OYzAvNHZ6eWRHMm83UFFpTHcyallPbwppbFptYUZzVXEyclU4S0hCdWlSbVkyTXlOWEU2R0liY29sVGZRQWM2NE5EWEFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlNOZC9vYTkyemFGWFNaRVJoRXJMSElqRE8zYWpBZkJnTlZIU01FR0RBV2dCU05kL29hOTJ6YUZYU1oKRVJoRXJMSElqRE8zYWpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBTwpjMDNIYWFDRHhhR0phdzlrYkJxMW1DbUVvR3pWZ0loYkhveTQ0Q0IxbGpnS0xOWHo2bnZ5bDVCdWRzWXJkT1lXCmJMMEJGdGxLbWRqeUFHemtnOThGSkpVNExTVFM1ZDNySlBkQU1lcXFOQ2R5NVh0c2l2VDlIbzh5QVBiUGFmZlkKTmozN29JVEQrdXhQbTNVMGhOTU5YSGdGdnJ4bGV6U2MyOHFWL1VxVDBWcnNJR3IyblNiaEYrR3g1WS92aTZocQp5RTJsYWJXdDQ3VlBYcTNFL2lHRWhTSmFndTdhN2xBSDhYWWlqMUtCMkU4bjlERy80R2ZDMEVpTnNXbUpzWVNjCk9tdXlmRGpXaHQ2LzlUVkh4YkNZMzZGQ08vOTcraThqUGhxVlkxRlJzUG5WRUtiRXBNemdXb3Y0UXNKeHoxS3gKdHN2eHlVRnJsaU5wUk1OQmVEODIKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo= kind: Secret metadata: name: tls-secret-cacert namespace: default type: Opaque  ","version":"Next","tagName":"h2"},{"title":"网关与后端服务双向认证（MTLS)​","type":1,"pageTitle":"通过Ingress Annotation实现高阶流量治理","url":"/zh-cn/docs/user/annotation-use-case#网关与后端服务双向认证mtls","content":"默认情况下，Higress默认使用HTTP协议转发请求到后端业务容器。你可以通过使用注解higress.io/backend-protocol: &quot;HTTPS&quot;配置Higress访问后端服务使用HTTPS协议，但这是单向TLS，也就是说只有Higress会验证后端服务提供的证书，且一般后端服务使用的证书需要是权威CA签发的。另一种更安全的模式是零信任，网关会验证后端服务的证书是否合法，同样后端服务也会验证网关提供的证书是否合法，这就是MTLS，网关与后端服务进行双向认证。 higress.io/proxy-ssl-secret：网关使用的客户端证书，用于后端服务对网关进行身份认证，格式为 secretNamespace/secretName。higress.io/proxy-ssl-name：TLS握手期间使用的SNI。higress.io/proxy-ssl-server-name：on or off。开启或关闭TLS握手期间使用SNI。 网关与后端服务进行双向认证，网关使用的secret name为gateway-cert，命名空为default。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/proxy-ssl-secret: &quot;default/gateway-cert&quot; name: demo spec: ingressClassName: higress rules: - host: example.com http: paths: - backend: service: name: demo-service port: number: 80 path: /test pathType: Exact  ","version":"Next","tagName":"h2"},{"title":"转换操作类型​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#转换操作类型","content":"操作类型\tkey 字段含义\tvalue 字段含义\t描述删除 remove\t目标 key\t无需设置\t若存在指定的 key，则删除；否则无操作 重命名 rename\t目标 oldKey\t新的 key 名称 newKey\t若存在指定的 oldKey:value，则将其键名重命名为 newKey，得到 newKey:value；否则无操作 更新 replace\t目标 key\t新的 value 值 newValue\t若存在指定的 key:value，则将其 value 更新为 newValue，得到 key:newValue；否则无操作 添加 add\t添加的 key\t添加的 value\t若不存在指定的 key:value，则添加；否则无操作 追加 append\t目标 key\t追加的 value值 appendValue\t若存在指定的 key:value，则追加 appendValue 得到 key:[value..., appendValue]；否则相当于执行 add 操作，得到 key:appendValue 映射 map\t映射来源 fromKey\t映射目标 toKey\t若存在指定的 fromKey:fromValue，则将其值 fromValue 映射给 toKey 的值，得到 toKey:fromValue，同时保留 fromKey:fromValue（注：若 toKey 已存在则其值会被覆盖）；否则无操作 去重 dedupe\t目标 key\t指定去重策略 strategy\tstrategy 可选值为：RETAIN_UNIQUE, RETAIN_LAST, RETAIN_FIRST。RETAIN_UNIQUE：按顺序保留所有唯一值，如 k1:[v1,v2,v3,v3,v2,v1]，去重后得到 k1:[v1,v2,v3]。RETAIN_LAST：保留最后一个值，如 k1:[v1,v2,v3]，去重后得到 k1:v3。RETAIN_FIRST (默认值)：保留第一个值，如 k1:[v1,v2,v3]，去重后得到 k1:v1（注：若去重后只剩下一个元素 v1 时，键值对变为 k1:v1, 而不是 k1:[v1]） ","version":"Next","tagName":"h2"},{"title":"配置示例​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#配置示例","content":"","version":"Next","tagName":"h2"},{"title":"请求转换​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#请求转换","content":"转换请求头部 reqRules: - operate: remove headers: - key: X-remove - operate: rename headers: - oldKey: X-not-renamed newKey: X-renamed - operate: replace headers: - key: X-replace newValue: replaced - operate: add headers: - key: X-add-append value: host-$1 host_pattern: ^(.*)\\.com$ - operate: append headers: - key: X-add-append appendValue: path-$1 path_pattern: ^.*?\\/(\\w+)[\\?]{0,1}.*$ - operate: map headers: - fromKey: X-add-append toKey: X-map - operate: dedupe headers: - key: X-dedupe-first strategy: RETAIN_FIRST - key: X-dedupe-last strategy: RETAIN_LAST - key: X-dedupe-unique strategy: RETAIN_UNIQUE  发送请求 $ curl -v console.higress.io/get -H 'host: foo.bar.com' \\ -H 'X-remove: exist' -H 'X-not-renamed:test' -H 'X-replace:not-replaced' \\ -H 'X-dedupe-first:1' -H 'X-dedupe-first:2' -H 'X-dedupe-first:3' \\ -H 'X-dedupe-last:a' -H 'X-dedupe-last:b' -H 'X-dedupe-last:c' \\ -H 'X-dedupe-unique:1' -H 'X-dedupe-unique:2' -H 'X-dedupe-unique:3' \\ -H 'X-dedupe-unique:3' -H 'X-dedupe-unique:2' -H 'X-dedupe-unique:1' # httpbin 响应结果 { &quot;args&quot;: {}, &quot;headers&quot;: { ... &quot;X-Add-Append&quot;: &quot;host-foo.bar,path-get&quot;, ... &quot;X-Dedupe-First&quot;: &quot;1&quot;, &quot;X-Dedupe-Last&quot;: &quot;c&quot;, &quot;X-Dedupe-Unique&quot;: &quot;1,2,3&quot;, ... &quot;X-Map&quot;: &quot;host-foo.bar,path-get&quot;, &quot;X-Renamed&quot;: &quot;test&quot;, &quot;X-Replace&quot;: &quot;replaced&quot; }, ... }  转换请求查询参数 reqRules: - operate: remove querys: - key: k1 - operate: rename querys: - oldKey: k2 newKey: k2-new - operate: replace querys: - key: k2-new newValue: v2-new - operate: add querys: - key: k3 value: v31-$1 path_pattern: ^.*?\\/(\\w+)[\\?]{0,1}.*$ - operate: append querys: - key: k3 appendValue: v32 - operate: map querys: - fromKey: k3 toKey: k4 - operate: dedupe querys: - key: k4 strategy: RETAIN_FIRST  发送请求 $ curl -v &quot;console.higress.io/get?k1=v11&amp;k1=v12&amp;k2=v2&quot; # httpbin 响应结果 { &quot;args&quot;: { &quot;k2-new&quot;: &quot;v2-new&quot;, &quot;k3&quot;: [ &quot;v31-get&quot;, &quot;v32&quot; ], &quot;k4&quot;: &quot;v31-get&quot; }, ... &quot;url&quot;: &quot;http://foo.bar.com/get?k2-new=v2-new&amp;k3=v31-get&amp;k3=v32&amp;k4=v31-get&quot; }  转换请求体 reqRules: - operate: remove body: - key: a1 - operate: rename body: - oldKey: a2 newKey: a2-new - operate: replace body: - key: a3 newValue: t3-new value_type: string - operate: add body: - key: a1-new value: t1-new value_type: string - operate: append body: - key: a1-new appendValue: t1-$1-append value_type: string host_pattern: ^(.*)\\.com$ - operate: map body: - fromKey: a1-new toKey: a4 - operate: dedupe body: - key: a4 strategy: RETAIN_FIRST  发送请求： 1. Content-Type: application/json $ curl -v -x POST console.higress.io/post -H 'host: foo.bar.com' \\ -H 'Content-Type: application/json' -d '{&quot;a1&quot;:&quot;t1&quot;,&quot;a2&quot;:&quot;t2&quot;,&quot;a3&quot;:&quot;t3&quot;}' # httpbin 响应结果 { ... &quot;headers&quot;: { ... &quot;Content-Type&quot;: &quot;application/json&quot;, ... }, &quot;json&quot;: { &quot;a1-new&quot;: [ &quot;t1-new&quot;, &quot;t1-foo.bar-append&quot; ], &quot;a2-new&quot;: &quot;t2&quot;, &quot;a3&quot;: &quot;t3-new&quot;, &quot;a4&quot;: &quot;t1-new&quot; }, ... }  2. Content-Type: application/x-www-form-urlencoded $ curl -v -X POST console.higress.io/post -H 'host: foo.bar.com' \\ -d 'a1=t1&amp;a2=t2&amp;a3=t3' # httpbin 响应结果 { ... &quot;form&quot;: { &quot;a1-new&quot;: [ &quot;t1-new&quot;, &quot;t1-foo.bar-append&quot; ], &quot;a2-new&quot;: &quot;t2&quot;, &quot;a3&quot;: &quot;t3-new&quot;, &quot;a4&quot;: &quot;t1-new&quot; }, &quot;headers&quot;: { ... &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, ... }, ... }  3. Content-Type: multipart/form-data $ curl -v -X POST console.higress.io/post -H 'host: foo.bar.com' \\ -F a1=t1 -F a2=t2 -F a3=t3 # httpbin 响应结果 { ... &quot;form&quot;: { &quot;a1-new&quot;: [ &quot;t1-new&quot;, &quot;t1-foo.bar-append&quot; ], &quot;a2-new&quot;: &quot;t2&quot;, &quot;a3&quot;: &quot;t3-new&quot;, &quot;a4&quot;: &quot;t1-new&quot; }, &quot;headers&quot;: { ... &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=------------------------1118b3fab5afbc4e&quot;, ... }, ... }  ","version":"Next","tagName":"h3"},{"title":"响应转换​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#响应转换","content":"与 Request Transformer 类似，在此仅说明转换 JSON 形式的请求/响应体时的注意事项： key 嵌套 . 1.通常情况下，指定的 key 中含有 . 表示嵌套含义，如下： respRules: - operate: add body: - key: foo.bar value: value  $ curl -v console.higress.io/get # httpbin 响应结果 { ... &quot;foo&quot;: { &quot;bar&quot;: &quot;value&quot; }, ... }  2.当使用 \\. 对 key 中的 . 进行转义后，表示非嵌套含义，如下： 当使用双引号括住字符串时使用 \\\\. 进行转义 respRules: - operate: add body: - key: foo\\.bar value: value  $ curl -v console.higress.io/get # httpbin 响应结果 { ... &quot;foo.bar&quot;: &quot;value&quot;, ... }  访问数组元素 .index 可以通过数组下标 `array.index 访问数组元素，下标从 0 开始： { &quot;users&quot;: [ { &quot;123&quot;: { &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18 } }, { &quot;456&quot;: { &quot;name&quot;: &quot;lisi&quot;, &quot;age&quot;: 19 } } ] }  1.移除 user 第一个元素： reqRules: - operate: remove body: - key: users.0  $ curl -v -X POST console.higress.io/post \\ -H 'Content-Type: application/json' \\ -d '{&quot;users&quot;:[{&quot;123&quot;:{&quot;name&quot;:&quot;zhangsan&quot;}},{&quot;456&quot;:{&quot;name&quot;:&quot;lisi&quot;}}]}' # httpbin 响应结果 { ... &quot;json&quot;: { &quot;users&quot;: [ { &quot;456&quot;: { &quot;name&quot;: &quot;lisi&quot; } } ] }, ... }  2.将 users 第一个元素的 key 为 123 重命名为 msg: reqRules: - operate: rename body: - oldKey: users.0.123 newKey: users.0.first  $ curl -v -X POST console.higress.io/post \\ -H 'Content-Type: application/json' \\ -d '{&quot;users&quot;:[{&quot;123&quot;:{&quot;name&quot;:&quot;zhangsan&quot;}},{&quot;456&quot;:{&quot;name&quot;:&quot;lisi&quot;}}]}' # httpbin 响应结果 { ... &quot;json&quot;: { &quot;users&quot;: [ { &quot;msg&quot;: { &quot;name&quot;: &quot;zhangsan&quot; } }, { &quot;456&quot;: { &quot;name&quot;: &quot;lisi&quot; } } ] }, ... }  遍历数组元素 .# 可以使用 array.# 对数组进行遍历操作： ❗️该操作目前只能用在 replace 上，请勿在其他转换中尝试该操作，以免造成无法预知的结果 { &quot;users&quot;: [ { &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18 }, { &quot;name&quot;: &quot;lisi&quot;, &quot;age&quot;: 19 } ] }  reqRules: - operate: replace body: - key: users.#.age newValue: 20  $ curl -v -X POST console.higress.io/post \\ -H 'Content-Type: application/json' \\ -d '{&quot;users&quot;:[{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18},{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:19}]}' # httpbin 响应结果 { ... &quot;json&quot;: { &quot;users&quot;: [ { &quot;age&quot;: &quot;20&quot;, &quot;name&quot;: &quot;zhangsan&quot; }, { &quot;age&quot;: &quot;20&quot;, &quot;name&quot;: &quot;lisi&quot; } ] }, ... }  ","version":"Next","tagName":"h3"},{"title":"特殊用法​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#特殊用法","content":"","version":"Next","tagName":"h2"},{"title":"实现基于 Body 参数路由​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#实现基于-body-参数路由","content":"需要数据面的 proxy wasm 版本大于等于 0.2.100。 编译时，需要带上版本的 tag，例如：tinygo build -o main.wasm -scheduler=none -target=wasi -gc=custom -tags=&quot;custommalloc nottinygc_finalizer proxy_wasm_version_0_2_100&quot; ./ 配置示例： reqRules: - operate: map headers: - fromKey: userId toKey: x-user-id mapSource: body  此规则将请求 body 中的 userId 解析出后，设置到请求 Header x-user-id 中，这样就可以基于 Higress 请求 Header 匹配路由的能力来实现基于 Body 参数的路由了。 此配置同时支持 application/json 和 application/x-www-form-urlencoded 两种类型的请求 Body。 举例来说： 对于 application/json 类型的 Body curl localhost -d '{&quot;userId&quot;:12, &quot;userName&quot;:&quot;johnlanni&quot;}' -H 'content-type:application/json'  将从 JSON 中提取出 userId 字段的值，设置到 x-user-id 中，后端服务收到的请求头将增加：x-usr-id: 12。 因为在插件新增这个 Header 后，网关将重新计算路由，所以可以实现网关路由配置根据这个请求头来匹配路由到特定的目标服务。 对于 application/x-www-form-urlencoded 类型的 Body curl localhost -d 'userId=12&amp;userName=johnlanni'  将从 k1=v1&amp;k2=v2 这样的表单格式中提取出 userId 字段的值，设置到 x-user-id 中，后端服务收到的请求头将增加：x-usr-id: 12。 因为在插件新增这个Header后，网关将重新计算路由，所以可以实现网关路由配置根据这个请求头来匹配路由到特定的目标服务。 ","version":"Next","tagName":"h3"},{"title":"JSON Path 支持​","type":1,"pageTitle":"请求/响应转换","url":"/zh-cn/docs/plugins/transformation/transformer#json-path-支持","content":"可以根据 GJSON Path 语法，从复杂的 JSON 中提取出字段。 比较常用的操作举例，对于以下 JSON: { &quot;name&quot;: {&quot;first&quot;: &quot;Tom&quot;, &quot;last&quot;: &quot;Anderson&quot;}, &quot;age&quot;:37, &quot;children&quot;: [&quot;Sara&quot;,&quot;Alex&quot;,&quot;Jack&quot;], &quot;fav.movie&quot;: &quot;Deer Hunter&quot;, &quot;friends&quot;: [ {&quot;first&quot;: &quot;Dale&quot;, &quot;last&quot;: &quot;Murphy&quot;, &quot;age&quot;: 44, &quot;nets&quot;: [&quot;ig&quot;, &quot;fb&quot;, &quot;tw&quot;]}, {&quot;first&quot;: &quot;Roger&quot;, &quot;last&quot;: &quot;Craig&quot;, &quot;age&quot;: 68, &quot;nets&quot;: [&quot;fb&quot;, &quot;tw&quot;]}, {&quot;first&quot;: &quot;Jane&quot;, &quot;last&quot;: &quot;Murphy&quot;, &quot;age&quot;: 47, &quot;nets&quot;: [&quot;ig&quot;, &quot;tw&quot;]} ] }  可以实现这样的提取: name.last &quot;Anderson&quot; name.first &quot;Tom&quot; age 37 children [&quot;Sara&quot;,&quot;Alex&quot;,&quot;Jack&quot;] children.0 &quot;Sara&quot; children.1 &quot;Alex&quot; friends.1 {&quot;first&quot;: &quot;Roger&quot;, &quot;last&quot;: &quot;Craig&quot;, &quot;age&quot;: 68} friends.1.first &quot;Roger&quot;  现在如果想从上面这个 JSON 格式的 body 中提取出 friends 中第二项的 first 字段，来设置到 Header x-first-name 中，同时抽取 last 字段，来设置到 Header x-last-name 中，则可以使用这份插件配置： reqRules: - operate: map headers: - fromKey: friends.1.first toKey: x-first-name - fromKey: friends.1.last toKey: x-last-name mapSource: body  ","version":"Next","tagName":"h3"},{"title":"Higress 对接 Dubbo 服务","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/dubbo","content":"","keywords":"Dubbo discovery","version":"Next"},{"title":"前提条件​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#前提条件","content":"Higress目前支持的Dubbo框架的版本为2.x。若您使用Dubbo3.0，要求使用dubbo协议（目前暂不支持Triple协议。Triple协议底层基于gRPC，可以直接代理，无需做协议转化）。 ","version":"Next","tagName":"h2"},{"title":"部署Dubbo服务​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#部署dubbo服务","content":"您可以选用Naocs或者Zookeeper任意一种作为注册中心，部署一个Dubbo服务。具体可以参考以下文档： https://cn.dubbo.apache.org/zh-cn/overview/what/ecosystem/registry/nacos/ https://cn.dubbo.apache.org/zh-cn/overview/what/ecosystem/registry/zookeeper/ 假设我们现在已经部署了如下一个Dubbo服务，其服务名为com.alibaba.nacos.example.dubbo.service.DemoService，并指定了该服务的version为“1.0.0”，group为“dev”，下面我们将介绍如何为该服务配置协议转换。 package com.alibaba.nacos.example.dubbo.service; public interface DemoService { String sayName(String name); }  ","version":"Next","tagName":"h2"},{"title":"通过Ingress转发请求到Dubbo服务​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#通过ingress转发请求到dubbo服务","content":"Higress可以通过McpBridge来对接Nacos或者Zookeeper作为服务来源。这里我们以Nacos为例，假设Naocs的ip地址为192.xxx.xx.32，我们可以在K8s集群中apply以下资源来配置McpBridge apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: 192.xxx.xx.32 nacosGroups: - DEFAULT_GROUP name: nacos-service-resource port: 8848 type: nacos2  通过McpBridge，我们可以直接从Nacos中发现Dubbo服务，并为其创建路由。 接下来我们创建如下Ingress，从而创建一条指向Dubbo服务的HTTP路由： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: providers:com.alibaba.nacos.example.dubbo.service.DemoService:1.0.0:dev.DEFAULT-GROUP.public.nacos higress.io/rpc-destination-name: httproute-http2rpc-demo name: httproute-http2rpc-demo-ingress namespace: higress-system spec: ingressClassName: higress rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: /dubbo pathType: Prefix  这样，path前缀为/dubbo的请求就会被路由到我们刚刚创建的Dubbo服务上。 ","version":"Next","tagName":"h2"},{"title":"通过Higress自定义的CRD-Http2Rpc配置HTTP到Dubbo的协议转换规则​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#通过higress自定义的crd-http2rpc配置http到dubbo的协议转换规则","content":"经过上述步骤，我们已经通过Ingress将path前缀为/dubbo的请求路由到我们的Dubbo服务上。但光是这样是无法正常通信的，因为Dubbo服务使用的是定制的Dubbo协议，无法天然与HTTP协议进行兼容。因此接下来我们还要配置具体的HTTP到Dubbo的协议转换规则，从而实现用HTTP请求来调用Dubbo服务。 apiVersion: networking.higress.io/v1 kind: Http2Rpc metadata: name: httproute-http2rpc-demo namespace: higress-system spec: dubbo: service: com.alibaba.nacos.example.dubbo.service.DemoService version: 1.0.0 group: dev methods: - serviceMethod: sayName headersAttach: &quot;*&quot; httpMethods: - &quot;GET&quot; httpPath: &quot;/dubbo/hello&quot; params: - paramKey: p paramSource: QUERY paramType: &quot;java.lang.String&quot;  在以上Http2Rpc中，我们配置了将path为/dubbo/hello的HTTP请求转发到Dubbo服务com.alibaba.nacos.example.dubbo.service.DemoService:1.0.0:dev中，并调用其sayName方法，而该方法的参数则通过HTTP url中的的query参数p来指定。 ","version":"Next","tagName":"h2"},{"title":"请求验证​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#请求验证","content":"通过以上配置，我们就可以执行以下curl命令来调用这个dubbo服务了： $curl &quot;localhost/dubbo/hello?p=abc&quot; {&quot;result&quot;:&quot;Service [name :demoService , port : 20880] sayName(\\&quot;abc\\&quot;) : Hello,abc&quot;}  ","version":"Next","tagName":"h2"},{"title":"将整个请求body作为方法参数​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#将整个请求body作为方法参数","content":"Http2Rpc支持将整个请求body序列化为Dubbo方法的入参，如下所示： apiVersion: networking.higress.io/v1 kind: Http2Rpc metadata: name: httproute-http2rpc-demo namespace: higress-system spec: dubbo: service: com.alibaba.nacos.example.dubbo.service.DemoService version: 1.0.0 group: dev methods: - serviceMethod: sayName headersAttach: &quot;*&quot; httpMethods: - &quot;POST&quot; httpPath: &quot;/dubbo/hello&quot; paramFromEntireBody: paramType: &quot;java.lang.String&quot;  通过paramFromEntireBody字段，即可将整个请求body序列化为Dubbo方法的入参。参数的类型通过paramFromEntireBody.paramType字段来指定。该场景适用于Dubbo方法只有一个参数的情况，如果同时指定了paramFromEntireBody和params，params字段的内容将被忽略。 通过以上配置，我们可以执行以下命令来调用dubbo服务，注意请求的body必须符合json格式： $curl &quot;localhost/dubbo/hello&quot; -X POST -d '&quot;abc&quot;' {&quot;result&quot;:&quot;Service [name :demoService , port : 20880] sayName(\\&quot;abc\\&quot;) : Hello,abc&quot;}  ","version":"Next","tagName":"h2"},{"title":"配置参考​","type":1,"pageTitle":"Higress 对接 Dubbo 服务","url":"/zh-cn/docs/user/dubbo#配置参考","content":"Http2Rpc的相关配置项参考HTTP转Dubbo配置说明 ","version":"Next","tagName":"h2"},{"title":"全局配置说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/configmap","content":"","keywords":"Ingress","version":"Next"},{"title":"通用全局配置​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#通用全局配置","content":"Higress 的全局配置 ConfigMap 对象 higress-config 增加 higress 项， 参考配置如下： apiVersion: v1 data: higress: |- tracing: enable: true sampling: 100 timeout: 500 skywalking: service: skywalking-oap-server.op-system.svc.cluster.local port: 11800 gzip: enable: false minContentLength: 1024 contentType: - text/html - application/json - text/css - application/javascript - application/xhtml+xml - image/svg+xml disableOnEtagHeader: true memoryLevel: 5 windowBits: 12 chunkSize: 4096 compressionLevel: BEST_COMPRESSION compressionStrategy: DEFAULT_STRATEGY addXRealIpHeader: false disableXEnvoyHeaders: false downstream: connectionBufferLimits: 32768 http2: initialConnectionWindowSize: 1048576 initialStreamWindowSize: 65535 maxConcurrentStreams: 100 idleTimeout: 180 maxRequestHeadersKb: 60 upstream: connectionBufferLimits: 1048576 idleTimeout: 10 ... kind: ConfigMap metadata: name: higress-config namespace: higress-system  ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#配置说明","content":"字段\t类型\t说明\t默认addXRealIpHeader\tboolean\t是否添加 x-real-ip 请求头，如果是true，则会为请求头添加 x-real-ip 参数\tfalse disableXEnvoyHeaders\tboolean\t是否关闭附加在转发请求中的 x-envoy 前缀请求头（例如 x-envoy-original-path），如果是true，则会关闭\tfalse downstream\t参考下面 downstream 设置\tdownstream 设置\t参考下面 downstream 默认值 upstream\t参考下面 upstream 设置\tupstream 设置\t参考下面 upstream 默认值 tracing\t参考下面 tracing 设置\ttracing 设置\t参考下面 tracing 默认值 gzip\t参考下面 gzip 设置\tgzip 设置\t参考下面 gzip 默认值 Tracing 配置说明​ 字段\t类型\t说明\t默认enable\tboolean\t是否开启 tracing 功能\tfalse sampling\tfloat\t采样率，0.0 - 100.0 之间\t100.0 timeout\tint\t链路跟踪中间件 grpc 连接超时，单位毫秒\t500 skywalking\t参考下面 skywalking 设置\tskywalking 配置\t未设置 zipkin\t参考下面 zipkin 设置\tzipkin 配置\t未设置 skywalking 配置​ 字段\t类型\t说明\t默认service\tstring\tSkywalking grpc 服务地址\t空 port\tstring\tSkywalking grpc 服务端口\t空 access_token\tstring\tSkywalking grpc 服务访问凭证\t空 zipkin 配置​ 字段\t类型\t说明\t默认service\tstring\tzipkin 服务地址\t空 port\tstring\tzipkin 服务端口\t空 注意： skywalking 和 zipkin 不能同时设置，只有一个配置能生效 Gzip 配置说明​ 字段\t类型\t说明\t默认enable\tboolean\t是否开启 gzip 功能\tfalse minContentLength\tint\t启用压缩输出最少字节长度\t1024 contentType\tarray\t启用压缩输出content-type类型\ttext/html,application/json,text/css, application/javascript,application/xhtml+xml, image/svg+xml disableOnEtagHeader\tboolean\t如果是true时, 当 response 包含 etag header时会关闭 gzip功能\ttrue memoryLevel\tint\t从 1 到 9 控制 zlib用到内存.\t5 windowBits\tint\t从 9 到 15 表示压缩算法窗口大小.\t12 chunkSize\tint\tzlib buffer大小\t4096 compressionLevel\tstring\tzlib 压缩比率\tBEST_COMPRESSION compressionStrategy\tstring\tzlib 压缩策略\tDEFAULT_STRATEGY 关于 gzip 参数配置详细说明可以参考 envoy gzip压缩文档： https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/compression/gzip/compressor/v3/gzip.proto#envoy-v3-api-msg-extensions-compression-gzip-compressor-v3-gzip Downstream 配置说明​ 字段\t类型\t说明\t默认connectionBufferLimits\tint\t连接缓冲区大小，单位字节\t32768 http2\t参考下面 http2 设置\thttp2 设置\t参考下面 http2 默认值 idleTimeout\tint\t连接空闲超时时间，单位秒，0表示关闭该配置\t180 maxRequestHeadersKb\tint\t最大请求头大小，单位Kb，最大为8192Kb\t60 http2 配置说明​ 字段\t类型\t说明\t默认initialConnectionWindowSize\tint\thttp2 连接窗口大小，单位字节，范围为65535～2147483647\t1048576 initialStreamWindowSize\tint\thttp2 流窗口大小，单位字节，范围为65535～2147483647\t65535 maxConcurrentStreams\tint\thttp2 最大并发流数量，范围为1～2147483647\t100 Upstream 配置说明​ 字段\t类型\t说明\t默认connectionBufferLimits\tint\t连接缓冲区大小，单位字节\t1048576 idleTimeout\tint\t连接空闲超时时间(空闲定义是没有未处理完的请求，如果有请求在处理中，不会判定为idle)，单位秒，0表示关闭该配置\t10 ","version":"Next","tagName":"h3"},{"title":"TLS 证书全局配置​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#tls-证书全局配置","content":"注意：当前仅对Ingress模式生效，Gateway API暂不支持 Higress TLS 的全局配置 ConfigMap 对象 higress-https ， 参考配置如下： apiVersion: v1 kind: ConfigMap metadata: name: higress-https namespace: higress-system data: cert: | automaticHttps: true renewBeforeDays: 30 fallbackForInvalidSecret: true acmeIssuer: - name: letsencrypt email: test@example.com credentialConfig: - tlsIssuer: letsencrypt domains: - foo.com tlsSecret: foo-com-secret  ","version":"Next","tagName":"h2"},{"title":"配置说明​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#配置说明-1","content":"字段\t类型\t说明\t默认name\tboolean\t是否启动通过 ACME Issuer 来签发证书\ttrue renewBeforeDays\tint\t证书过期前多少天自动Renew， 最大值为90天\t30 fallbackForInvalidSecret\tboolean\t如果开启，当 ingress TLS 里配置 secretName 不存在时，会在 credentialConfig 配置里根据域名匹配 secret\tfalse acmeIssuer\tarray\tacmeIssuer 设置\t参考下面 acmeIssuer credentialConfig\tarray\tcredentialConfig 设置\t参考下面 credentialConfig ","version":"Next","tagName":"h3"},{"title":"credentialConfig 配置​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#credentialconfig-配置","content":"字段\t类型\t说明\t默认tlsSecret\tstring\t证书 secret 名称\t- tlsIssuer\tstring\t对应 ACME Issuer 名称，现在只支持 letsencrypt。不填 tlsIssuer 时，domains可以填列表或泛域名，用于全局管理这些域名的secret配置； 如果设置为 letsencrypt， domains 下只能配置一个域名，而且不能是泛域名，并且 tlsSecret 不能是已经存在的非 Higress 创建的自动证书\t- domains\tarray\t域名配置，可以是泛域名\t- ","version":"Next","tagName":"h3"},{"title":"acmeIssuer 配置​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#acmeissuer-配置","content":"字段\t类型\t说明\t默认name\tstring\tACME Issuer 名称，只支持 letsencrypt\t- email\tstring\tACME Issuer 邮箱，用于通知证书变更等事件\t- ","version":"Next","tagName":"h3"},{"title":"如何开启和关闭 ACME Issuer 自动管理证书​","type":1,"pageTitle":"全局配置说明","url":"/zh-cn/docs/user/configmap#如何开启和关闭-acme-issuer-自动管理证书","content":"安装时默认启动 ACME Issuer 自动管理证书和系统随机生成邮箱地址，具体配置参数如下： 参数名\t参数说明\t默认值higress-core.controller.automaticHttps.enabled\t是否开启ACME Issuer签发证书，只支持 letsencrypt\ttrue higress-core.controller.automaticHttps.email\tACME Issuer 邮箱，如果为空，系统随机生成邮箱地址\t- ","version":"Next","tagName":"h3"},{"title":"HTTP转Dubbo 配置说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/dubbo-http2rpc","content":"","keywords":"Dubbo discovery","version":"Next"},{"title":"spec.dubbo​","type":1,"pageTitle":"HTTP转Dubbo 配置说明","url":"/zh-cn/docs/user/dubbo-http2rpc#specdubbo","content":"字段\t类型\t说明\tservice\tthe dubbo interface name\tdubbo服务接口名\t例如：&quot;com.alibaba.nacos.example.dubbo.service.DemoService&quot; version\tthe dubbo service version\tdubbo服务版本号\t例如：&quot;1.0.0&quot; group\tthe dubbo service group\tdubbo服务分组\t例：&quot;dev&quot; methods\tlist of spec.dubbo.methods\t每一项对应了一条方法映射规则\t ","version":"Next","tagName":"h3"},{"title":"spec.dubbo.methods​","type":1,"pageTitle":"HTTP转Dubbo 配置说明","url":"/zh-cn/docs/user/dubbo-http2rpc#specdubbomethods","content":"字段\t类型\t说明\tserviceMethod\tstring\tdubbo服务接口的方法名\t例：&quot;sayName&quot; headersAttach\tstring\t需要透传的http headers\t1、空: 不设置表示不透传任何值; 2、*: 表示透传所有headers; 3、用英文逗号隔开需要透出的headers key: header-A,header-B,header-C, httpPath\tstring\t指定绑定serviceMethod的http-path\t例：&quot;/dubbo/hello&quot; httpMethods\tlist of HTTP_METHOD_TYPE\thttp-path的请求方式\t例：&quot;POST&quot; params\tlist of spec.dubbo.methods.params\t指定参数提取方式 paramFromEntireBody\tParamFromEntireBody\t指定将整个请求body作为参数，如果同时配置了paramFromEntireBody和params，params字段的内容将被忽略\t ","version":"Next","tagName":"h3"},{"title":"spec.dubbo.methods.params​","type":1,"pageTitle":"HTTP转Dubbo 配置说明","url":"/zh-cn/docs/user/dubbo-http2rpc#specdubbomethodsparams","content":"字段\t类型\t说明\tparamKey\tstring\t参数名称\t例：&quot;p&quot; paramSource\tPARAM_SOURCE_TYPE\t参数来源\t&quot;QUERY&quot; paramType\tstring\tDubbo方法入参的参数类型\t&quot;java.lang.String&quot; ","version":"Next","tagName":"h3"},{"title":"spec.dubbo.methods.paramFromEntireBody​","type":1,"pageTitle":"HTTP转Dubbo 配置说明","url":"/zh-cn/docs/user/dubbo-http2rpc#specdubbomethodsparamfromentirebody","content":"字段\t类型\t说明\tparamType\tstring\tDubbo方法入参的参数类型\t&quot;java.lang.String&quot; ","version":"Next","tagName":"h3"},{"title":"HTTP_METHOD_TYPE​","type":1,"pageTitle":"HTTP转Dubbo 配置说明","url":"/zh-cn/docs/user/dubbo-http2rpc#http_method_type","content":"值\t说明GET\thttp GET method POST\thttp POST method PUT\thttp PUT method DELETE\thttp DELETE method PATCH\thttp PATCH method ","version":"Next","tagName":"h3"},{"title":"PARAM_SOURCE_TYPE​","type":1,"pageTitle":"HTTP转Dubbo 配置说明","url":"/zh-cn/docs/user/dubbo-http2rpc#param_source_type","content":"值\t说明QUERY\thttp url param HEADER\thttp header PATH\thttp url path BODY\thttp request body ","version":"Next","tagName":"h3"},{"title":"通过 OpenKruise Rollout 实现灰度发布","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/kruise-rollout","content":"","keywords":"rollout gray","version":"Next"},{"title":"什么是Kruise Rollout​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#什么是kruise-rollout","content":"Kruise Rollout 是阿里云开源的云原生应用自动化管理套件 OpenKruise 在渐进式交付领域的新尝试，支持配合流量和实例灰度的金丝雀发布、蓝绿发布、A/B Testing 发布，以及发布过程能够基于 Prometheus Metrics 指标自动化分批与暂停，并提供旁路的无感对接、兼容已有的多种工作负载（Deployment、CloneSet、DaemonSet）。 这里，熟悉 Kubernetes 的小伙伴可以会疑惑，官方的 Deployment 工作负载不是有控制发布的策略吗？我们为什么还需要 Kruise Rollout 呢？ 首先，Kubernetes 官方的 Deployment 中定义发布策略严格上不符合渐进性交付的思想，它实际是滚动发布。虽然 Deployment 对于升级而言提供了 maxUnavailable 和 maxSurge 两个参数，但是本质上来讲 Deployment 它只支持流式的一次性发布，用户并不能控制分批以及精细化的流量策略。比如用户无法严格控制新老版本之间的流量比例，只能根据实际 Pod 数量占比以及调用端的负载均衡策略；用户无法做 A/B testing 策略，例如限制公司内部员工可以访问新版本。当新版本出现问题，只能重新执行一遍滚动发布切回老版本，这样不仅回滚速度慢，而且频繁线上变更本身就具有极高的不稳定因素。 再者，Kubernetes 只提供了应用交付的 Deployment 控制器，以及针对流量的 Ingress、Service 抽象，但是如何将上述实现组合成开箱即用的渐进式交付方案，Kubernetes 并没有出标准的定义。 出于以上问题和考量，阿里云开始发起对渐进式领域的探索，结合多年来容器化、云原生的技术沉淀，推出了无侵入、可扩展、高易用的渐进式交付框架 Kruise Rollout。 ","version":"Next","tagName":"h2"},{"title":"Higress & Kruise Rollout工作机制​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#higress--kruise-rollout工作机制","content":"简单介绍一下 Higress 和 Kruise Rollout 在一次应用发布过程中的工作机制。  这里，假设集群中有一个 Deployment 应用A，通过 Higress 网关对外暴露提供服务。应用A由于业务发展，需要发布新功能。 用户首先在集群中添加渐进性交付策略（Rollout CRD资源），描述目标工作负载的交付策略，比如批次，每一批次的流量控制，以及关联的 Service 资源和 Ingress 资源。应用A发布新版本，用户修改集群上中目标Deployment的Pod模板中容器镜像为新版本。Kruise Rollout通过hook方式参与到Deployment滚动发布流程，修改Deployment的Pause来暂停滚动发布过程。执行第一次批次发布，根据Rollout CRD资源描述的交付策略，控制新版本的Pod数量，同时为正式Ingress资源生成对应的灰度Ingress资源，并配置灰度流量策略，比如流量权重比或者根据请求内容Header进行流量分发。Higress监听到Ingress资源变化，实时动态修改路由规则，满足灰度规则的流量被分发到新版本。通过Prometheus等监控手段观察应用流量的指标信息，验证新版本是否符合预期。 a. 如果符合预期，触发下一次批次发布，重复执行步骤4 b. 如果不符合预期，触发回滚，新发布的Pod下线，灰度已下线的部分老版本的Pod，Ingress资源自动下线灰度规则，Higress实时修改路由规则，确保流量只访问老版本服务。 整个 Rollout 过程，自动整合Deployment、Service、Ingress一起工作，并向用户屏蔽底层资源变化。这是与现有工作负载能力的一种协同，它尽量复用工作负载的能力，又做到了非 Rollout 过程的零入侵。 ","version":"Next","tagName":"h2"},{"title":"实战​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#实战","content":"","version":"Next","tagName":"h2"},{"title":"前提条件​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#前提条件","content":"安装Higress，请参阅安装部署安装Kruise Rollout helm install kruise-rollout openkruise/kruise-rollout --version 0.3.0-rc.0  安装kubectl-kruise命令行工具，请参阅安装kubectl-kruise ","version":"Next","tagName":"h3"},{"title":"金丝雀发布​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#金丝雀发布","content":"什么是金丝雀发布​ 金丝雀发布的思想是将少量的请求引流到新版本上，因此部署新版本服务只需极小数的机器。验证新版本符合预期后，逐步调整流量权重比例，使得流量慢慢从老版本迁移至新版本，期间可以根据设置的流量比例，对新版本服务进行扩容，同时对老版本服务进行缩容，使得底层资源得到最大化利用。 如图，某服务当前版本为v1，现在新版本v2要上线。为确保流量在服务升级过程中平稳无损，采用金丝雀发布方案，逐步将流量从老版本迁移至新版本。  基于Higress &amp; Kruise Rollout实践金丝雀发布​ 假设集群中有一个服务demo，通过Higress网关对外提供服务。 apiVersion: apps/v1 kind: Deployment metadata: name: demo spec: replicas: 5 selector: matchLabels: app: demo template: metadata: labels: app: demo spec: containers: - name: main image: registry.cn-hangzhou.aliyuncs.com/mse-ingress/version:v1 imagePullPolicy: Always ports: - containerPort: 8080 --- apiVersion: v1 kind: Service metadata: name: demo spec: ports: - port: 80 targetPort: 8080 protocol: TCP name: http selector: app: demo --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: demo annotations: kubernetes.io/ingress.class: nginx spec: ingressClassName: higress rules: - http: paths: - backend: service: name: demo port: number: 80 path: /version pathType: Exact  现在，服务demo需要发布新版本。在修改应用镜像之前，我们需要为服务demo定义金丝雀发布策略，以达到渐进式发布的效果。 apiVersion: rollouts.kruise.io/v1alpha1 kind: Rollout metadata: name: rollouts-demo spec: objectRef: workloadRef: apiVersion: apps/v1 kind: Deployment name: demo strategy: canary: steps: - weight: 10 pause: {} replicas: 1 - weight: 30 pause: {} replicas: 2 trafficRoutings: - service: demo ingress: classType: higress name: demo  其中workloadRef 旁路式的选择需要 Rollout 的 Workload，此处为Deployment，支持其他Workload（如CloneSet、DaemonSet）。其中canary.Steps 定义了整个 Rollout 过程一共分为3批，其中第一批只灰度一个新版本 Pod，并且 routing 10% 流量到新版本 Pod，并且需要人工确认是否继续发布；第二批只灰度两个新版本Pod，并且routing 30%流量到新版本Pod，并且需要人工确认是否继续发布；最后一批，无需定义，即全量发布。其中trafficRoutings指向了需要感知流量规则的资源，kruise rollout会自动更新相关资源，实时反射目标流量规则。 修改服务A的Deployment中镜像为registry.cn-hangzhou.aliyuncs.com/mse-ingress/version:v2，观察相关资源变化。 查看rollout资源状态，发现当前执行完第一批发布，并且出于暂停状态，需要人工确认才能继续下一批次发布。 查看pod状态，发现新版本pod只有一个，Deployment资源没有全部滚动发布。 查看Ingress的解析IP （即Higress网关对外的公网IP地址）。 测试流量，发现有10%流量访问新版本。 继续第二批次发布，查看当前Pod状态，发现新版本Pod有两个。 测试流量，观察流量分配比。 发布最后一批，完成全量发布。 测试流量，发现流量全部转发至新版本。至此，我们通过小流量的方式逐步将流量从老版本迁移至新版本。 ","version":"Next","tagName":"h3"},{"title":"A/B Testing​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#ab-testing","content":"什么是A/B Testing​ 相比于基于权重方式的金丝雀发布，A/B测试基于用户请求的元信息将流量路由到新版本，这是一种基于请求内容匹配的灰度发布策略。只有匹配特定规则的请求才会被引流到新版本，常见的做法包括基于Http Header和Cookie。基于Http Header方式的例子，例如User-Agent的值为Android的请求 （来自安卓系统的请求）可以访问新版本，其他系统仍然访问旧版本。基于Cookie方式的例子，Cookie中通常包含具有业务语义的用户信息，例如普通用户可以访问新版本，VIP用户仍然访问旧版本。 如图，某服务当前版本为v1，现在新版本v2要上线。希望安卓用户可以尝鲜新功能，其他系统用户保持不变。 通过在监控平台观察旧版本与新版本的成功率、RT对比，当新版本整体服务预期后，即可将所有请求切换到新版本v2，最后为了节省资源，可以逐步下线到旧版本v1。 基于Higress &amp; Kruise Rollout实践A/B Testing​ 我们仍然利用上面的例子，服务A初始镜像为v1。现在，服务demo需要发布新版本。在修改应用镜像之前，我们需要为服务demo定义A/B Testing 策略，以达到渐进式发布的效果。 apiVersion: rollouts.kruise.io/v1alpha1 kind: Rollout metadata: name: rollouts-header spec: objectRef: workloadRef: apiVersion: apps/v1 kind: Deployment name: demo strategy: canary: steps: - matches: - headers: - name: user-agent value: android pause: {} replicas: 1 trafficRoutings: - service: demo ingress: classType: higress name: demo  其中canary.Steps 定义了整个 Rollout 过程一共分为2批，其中第一批只灰度一个新版本 Pod，并且将带有HTTP Header user-agent: android (即安卓用户）的流量routing 到新版本 Pod，并且需要人工确认是否继续发布；最后一批，无需定义，即全量发布。 修改服务A的Deployment中镜像为registry.cn-hangzhou.aliyuncs.com/mse-ingress/version:v2，观察相关资源变化。 查看rollout资源状态，发现当前执行完第一批发布，并且出于暂停状态，需要人工确认才能继续下一批次发布。 查看pod状态，发现新版本pod只有一个，Deployment资源没有全部滚动发布。 测试来自安卓的流量是否路由到新版本，非安卓的流量是否路由到老版本。 发布最后一批，完成全量发布。并测试所有流量是否路由到新版本。 ","version":"Next","tagName":"h3"},{"title":"总结​","type":1,"pageTitle":"通过 OpenKruise Rollout 实现灰度发布","url":"/zh-cn/docs/user/kruise-rollout#总结","content":"相比于传统人工手动方式，Higress &amp; Kruise Rollouts提供了无侵入、自动化运维方式让应用发布丝滑般顺畅。开发者无需关注发布过程中如何调整Deployment、Ingress、Service等资源，只需声明并管理发布策略Rollouts资源即可，原生Deployment的滚动发布会自动实现为渐进式交付，让应用发布可批次、可灰度、可回滚，助力业务快速迭代发展同时，也提高了应用发布的稳定性和效率问题。 ","version":"Next","tagName":"h2"},{"title":"Mcp Bridge 配置说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/mcp-bridge","content":"","keywords":"discovery","version":"Next"},{"title":"McpBridge 字段说明​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#mcpbridge-字段说明","content":"字段\t类型\t说明\t示例值\t是否必填registries\tRegistryConfig 数组\t支持配置多个不同注册中心的服务来源\t[]\t否 name\t字符串\tMcpBridge 名称\tdefault\t是，当前该值只能是 default ","version":"Next","tagName":"h2"},{"title":"RegistryConfig 字段说明​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#registryconfig-字段说明","content":"字段\t类型\t说明\t示例值\t是否必填type\t字符串\t服务发现类型，可选项：nacos,nacos2,zookeeper,consul,eureka,static,dns\tnacos2\t是 name\t字符串\t自定义的服务来源名称\tmy-nacos\t是 domain\t字符串\t服务发现地址，一般是注册中心地址; 当类型是static或dns时，这个字段用于直接配置后端地址\t192.168.1.2\t是 port\t整数\t注册中心访问端口\t8848\t是 zkServicesPath\t字符串数组\t使用zk时,填写服务注册的根路径,默认监听 /dubbo 和 /services，前者为dubbo 服务默认根路径，后者为SpringCloud服务默认根路径\t[&quot;/service-provider&quot;]\t否 nacosNamespaceId\t字符串\tnacos命名空间id\td8ac64f3-xxxx-xxxx-xxxx-47a814ecf358\t否 nacosGroups\t字符串数组\tnacos服务分组列表\t[&quot;DEFAULT_GROUP&quot;]\t否 nacosAccessKey\t字符串\tnacos需要认证时填写的ak信息\txxxx\t否 nacosSecretKey\t字符串\tnacos需要认证时填写的sk信息\txxxx\t否 nacosRefreshInterval\t整数\tnacos需要认证时填写的服务刷新间隔纳秒数\t30000000000（30秒）\t否 consulDatacenter\t字符串\tconsul需要认证时填写的数据中心名称\tdc1\t否 consulServiceTag\t字符串\tconsul需要认证时填写的服务标签过滤\thigress\t否 consulRefreshInterval\t整数\tconsul需要认证时填写的服务刷新间隔纳秒数\t30000000000（30秒）\t否 authSecretName\t字符串\t服务发现认证信息 Secret 名称, 具体看下面说明\thigress-nacos-auth\t否 ","version":"Next","tagName":"h2"},{"title":"authSecretName 字段说明​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#authsecretname-字段说明","content":"服务发现来源认证信息保存在 higress-system 命名空间下对应 Secret 下 ，现在支持 nacos 和 consul 服务发现。 nacos 认证信息包含用户名和密码， consul 认证信息包含认证 token， 具体 Secret 配置样例如下： ","version":"Next","tagName":"h2"},{"title":"nacos 认证​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#nacos-认证","content":"apiVersion: v1 data: nacosPassword: aGlncmVzcw== nacosUsername: aGlncmVzcw== kind: Secret metadata: name: higress-nacos-auth namespace: higress-system type: Opaque  ","version":"Next","tagName":"h3"},{"title":"consul 认证​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#consul-认证","content":"apiVersion: v1 data: consulToken: NGFkZDE2NjUtNTM5NC03YzU1LTIzYTUtNzA4MDZkNTFiYzQy kind: Secret metadata: name: higress-consul-auth namespace: higress-system type: Opaque  ","version":"Next","tagName":"h3"},{"title":"支持配置静态的服务发现方式​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#支持配置静态的服务发现方式","content":"","version":"Next","tagName":"h2"},{"title":"通过固定IP发现服务​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#通过固定ip发现服务","content":"apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: &quot;1.1.1.1:80,2.2.2.2:80&quot; name: test port: 80 type: static  ","version":"Next","tagName":"h3"},{"title":"通过DNS域名发现服务​","type":1,"pageTitle":"Mcp Bridge 配置说明","url":"/zh-cn/docs/user/mcp-bridge#通过dns域名发现服务","content":"apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: - domain: www.alibaba.com name: alibaba port: 80 type: dns  ","version":"Next","tagName":"h3"},{"title":"Nginx Ingress 兼容说明","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/nginx-ingress","content":"Nginx Ingress 兼容说明 TBD","keywords":"ingress nginx","version":"Next"},{"title":"从 Nginx Ingress Controller 平滑迁移","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/nginx-ingress-migrate","content":"从 Nginx Ingress Controller 平滑迁移 TBD","keywords":"Ingress","version":"Next"},{"title":"对接 OpenSergo 实现全链路灰度","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/opensergo-gray","content":"对接 OpenSergo 实现全链路灰度 文档计划推出时间：2022.02.28","keywords":"opensergo gray","version":"Next"},{"title":"配置 Ingress 转发给注册在 Nacos 的服务","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/nacos-route","content":"","keywords":"ingress higress nacos","version":"Next"},{"title":"配置服务来源​","type":1,"pageTitle":"配置 Ingress 转发给注册在 Nacos 的服务","url":"/zh-cn/docs/user/nacos-route#配置服务来源","content":"apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: # 定义一个名为 “production” 的服务来源 - name: production # 注册中心类型是 Nacos 2.x，支持 gRPC 协议 type: nacos2 # 注册中心的访问地址，可以是域名或者IP domain: 192.xxx.xx.32 # 注册中心的访问端口，Nacos 默认都是 8848 port: 8848 # Nacos 命名空间 ID nacosNamespaceId: d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358 # Nacos 服务分组 nacosGroups: - DEFAULT_GROUP # 定义一个名为 “uat” 的服务来源 - name: uat # 注册中心类型是 Nacos 1.x，只支持 HTTP 协议 type: nacos # 注册中心的访问地址，可以是域名或者IP domain: 192.xxx.xx.31 # 注册中心的访问端口，Nacos 默认都是 8848 port: 8848 # Nacos 命名空间 ID nacosNamespaceId: 98ac6df3-xxxx-xxxx-xxxx-ab98115dfde4 # Nacos 服务分组 nacosGroups: - DEFAULT_GROUP  通过McpBridge资源配置了两个服务来源，分别取名 “production”和“uat”，需要注意的是 Higress 对接 Nacos 同时支持 HTTP 和 gRPC 两种协议，建议将 Nacos 升级到 2.x 版本，这样可以在上述配置的 type 中指定 “nacos2” 使用 gRPC 协议，从而更快速地感知到服务变化，并消耗更少的 Nacos 服务端资源。 基于 McpBridge 中的 registries 数组配置，Higress 可以轻松对接多个且不同类型的服务来源（Nacos/Zookeeper/Eureka/Consul/...），这里对于 Nacos 类型的服务来源，支持配置多个不同命名空间，从而实现不同命名空间的微服务可以共用一个网关，降低自建微服务网关的资源成本开销。 ","version":"Next","tagName":"h2"},{"title":"配置 Ingress​","type":1,"pageTitle":"配置 Ingress 转发给注册在 Nacos 的服务","url":"/zh-cn/docs/user/nacos-route#配置-ingress","content":"apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: service-provider.DEFAULT-GROUP.d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358.nacos name: demo namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: / pathType: Prefix  和常见的 Ingress 在 backend 中定义 service 不同，这里基于 Ingress 的 resource backend 将上面定义服务来源的 McpBridge 进行关联。并通过注解higress.io/destination指定路由最终要转发到的目标服务。 对于 Nacos 来源的服务，这里的目标服务格式为：“服务名称.服务分组.命名空间ID.nacos”，注意这里需要遵循 DNS 域名格式，因此服务分组中的下划线'_'被转换成了横杠'-'。 ","version":"Next","tagName":"h2"},{"title":"基于 Prometheus 实现入口流量观测","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/prometheus","content":"","keywords":"Higress Prometheus","version":"Next"},{"title":"使用 Higress Console 的内置监控套件​","type":1,"pageTitle":"基于 Prometheus 实现入口流量观测","url":"/zh-cn/docs/user/prometheus#使用-higress-console-的内置监控套件","content":"Higress Console 内置了一套基于 Prometheus + Grafana 的监控套件，但默认不会安装。在使用 Helm 安装 Higress 时，可以通过在命令行中添加 --set global.o11y.enabled=true 参数启用这一监控套件。 helm repo add higress.io https://higress.io/helm-charts helm install higress -n higress-system higress.io/higress --create-namespace --render-subchart-notes --set global.o11y.enabled=true  注意：在安装到标准 K8s 集群（即未指定 global.local=true 参数）时，监控系统所配置的 PersistentVolumeClaim 默认使用 ReadWriteMany 访问模式。如果目标 K8s 集群不支持这一访问模式，则可以在命令行中额外添加 --set global.pvc.rwxSupported=false 参数来将访问模式切换为 ReadyWriteOnce。 helm repo add higress.io https://higress.io/helm-charts helm install higress -n higress-system higress.io/higress --create-namespace --render-subchart-notes --set global.o11y.enabled=true --set global.pvc.rwxSupported=false  完成安装后，在浏览器中访问 Higress Console，点击左侧导航栏“监控面板”，页面右侧就会展示出系统内置的监控面板。  ","version":"Next","tagName":"h2"},{"title":"使用独立部署的监控套件​","type":1,"pageTitle":"基于 Prometheus 实现入口流量观测","url":"/zh-cn/docs/user/prometheus#使用独立部署的监控套件","content":"Higress 的数据面和控制面组件均通过 API 对外暴露了一系列的 Metrics 指标。只需要为 Prometheus 添加相应指标采集配置，并在 Grafana 中配置监控面板就可以监控 Higress 的内部运行情况了。 在正式开始配置之前，请先在浏览器中打开 Higress Console，并在左侧导航栏切换至“监控面板”页面。在未安装内置监控套件时，页面上就会展示出外置监控面板 URL 配置页面和外部系统的配置法。  按照界面下方给出的方法更新 Prometheus 和 Grafana 中的配置，然后把 Grafana 看板的页面 URL 填入上方输入框中并保存。随后页面会自动刷新，右侧就会出现配置好的外置监控面板。  如果需要更新监控面板的 URL，则可点击页面左上角的“重新配置”按钮。 ","version":"Next","tagName":"h2"},{"title":"基于 Sentinel 实现入口熔断限流","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/sentinel","content":"基于 Sentinel 实现入口熔断限流 文档计划推出时间：2022.03.15","keywords":"sentinel","version":"Next"},{"title":"Higress + Skywalking + SpringBoot 链路追踪探索","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/skywalking-springboot","content":"","keywords":"higress higress官网 云原生网关","version":"Next"},{"title":"分布式链路追踪介绍​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#分布式链路追踪介绍","content":"分布式链路追踪（Distributed Tracing）是一种用于跟踪和监控分布式系统中请求的路径和性能的技术。它可以帮助开发人员和运维团队在复杂的分布式系统中快速定位和解决问题。 在分布式系统中，多个服务之间的交互涉及到复杂的网络通信和数据传输，其中每个服务可能由不同的团队或组织负责维护和开发。因此，在这样的环境下，当一个请求被发出并经过多个服务的处理后，如果出现了问题或错误，很难快速定位到根因。分布式全链路追踪技术则可以帮助我们解决这个问题，它能够跟踪和记录请求在系统中的传输过程，并提供详细的性能和日志信息，使得开发人员能够快速诊断和定位问题。对于分布式系统的可靠性、性能和可维护性起到了非常重要的作用。 分布式链路追踪中有以下几个核心术语： Trace: 用来描述在分布式系统中一个完整的事务（这里的事务不是指数据库中的事务，而是指一个完整的业务流）Span: 可命名的、记录耗时的一个工作流片段，Span上可设置多个key:value的tags，也可以记录某个时间点的结构化的logSpanContext: 追踪信息会伴随着整个分布式事务，会通过网络或者消息总线来传递到下游服务中，包含了 trace id、span id 和其它需要传播的数据 分布式链路追踪通过在分布式系统中的每个请求上添加唯一的标识符（通常是一个trace ID），以及另外一些关键的上下文信息（例如span ID、父span ID等），来跟踪请求的流转和路径，如下图所示。当请求通过不同的服务和组件时，每个组件都会创建一个span并记录相关的信息，包括该组件的处理时间、调用的其他组件等。这些span将形成一个分布式的链路，描述了请求的完整路径和各个组件的性能。  ","version":"Next","tagName":"h2"},{"title":"Skywalking介绍​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#skywalking介绍","content":"SkyWalking是一个开源的分布式系统性能监控和跟踪解决方案。它专为云原生和微服务架构设计，可以帮助开发人员和运维团队实时监控和分析分布式系统的性能和链路追踪数据。 SkyWalking 逻辑上分为四部分：探针，平台后端，存储和用户界面： 探针：基于不同的来源可能是不一样的，但作用都是收集数据，将数据格式化为 SkyWalking 适用的格式平台后端：支持数据聚合，数据分析以及驱动数据流从探针到用户界面的流程。分析包括 Skywalking 原生追踪和性能指标以及第三方来源，包括 Istio 及 Envoy telemetry，Zipkin 追踪格式化等存储：通过开放的插件化的接口存放 SkyWalking 数据，支持 ElasticSearch、MySQL等UI：一个基于接口高度定制化的Web系统，用户可以可视化查看和管理 SkyWalking 数据 架构图如下所示：  应用程序接入skywalking时主要有两种方法，分别是通过agent方式接入以及通过SDK方式接入。skywalking 官方提供了适用于多种语言的agent供开发者使用，如下图所示：  ","version":"Next","tagName":"h2"},{"title":"Higress链路追踪能力​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#higress链路追踪能力","content":"Higress 支持多种链路追踪服务，详情参见 envoy 官方文档。在 Higress 1.1 版本以上，仅需要在 configmap 中增加以下配置即可集成skywalking，其中sampling字段设置采样率。 data: higress: |- tracing: enable: true sampling: 100 timeout: 500 skywalking: service: skywalking-oap-server.op-system.svc.cluster.local port: 11800  ","version":"Next","tagName":"h2"},{"title":"测试环境架构​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#测试环境架构","content":"本文中使用 6 个 spring boot 应用在本地 k8s 集群中构建如下调用链路：  本次测试中涉及的代码可以在 higress-demo 中获取，可以通过修改环境变量中remote_addrs和sleep_time来指定springboot程序要调用的下游服务以及当前服务休眠的时间，从而创造不同的测试场景。 ","version":"Next","tagName":"h2"},{"title":"链路追踪示例​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#链路追踪示例","content":"测试时，设置springboot服务的rt分别为： | service | rt(ms) | | :-: | :-: | | springboot-svc-1 | 100 | | springboot-svc-2-1 | 200 | | springboot-svc-2-2 | 200 | | springboot-svc-3 | 300 | | springboot-svc-4-1 | 100 | | springboot-svc-4-2 | 500 | 通过以下命令创造请求示例： while :; do curl springboot.higress.io/spring-svc-1 ; done  ","version":"Next","tagName":"h2"},{"title":"获取微服务调用链路​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#获取微服务调用链路","content":"skywalking基于请求调用链路生成微服务之间的拓扑图，通过拓扑图可以清晰的看到系统架构，如下图所示：  ","version":"Next","tagName":"h3"},{"title":"排查系统性能瓶颈​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#排查系统性能瓶颈","content":"当系统整体rt较高时，如何排查系统的性能瓶颈往往是开发者关心的问题。通过链路追踪能够帮助开发者排查系统的性能瓶颈。 根据trace id能够查看请求的链路，并且能够看到链路中各节点记录的相关信息，下图较为直观的反映了请求调用链路中各环节响应时间的对比：  以下表格反映了每个请求自身占用的时间，通过该表格可以看到 springboot-svc-4-2 耗时最久，为 504 ms，开发者可以根据此结果对服务进行性能优化。  ","version":"Next","tagName":"h3"},{"title":"排查系统错误节点​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#排查系统错误节点","content":"当系统中调用链路较为复杂时，如果某个环节出现错误，排查问题对于开发者来说是一件困难的事情，现在删除 springboot svc 4-2来模拟系统某一环节出现错误的情况，通过链路追踪来排查问题。  此时链路追踪显示的调用链路如上图所示，其中红色圆圈表示服务出现错误，可以看到此时链路中 springboot svc 1，springboot svc 2-1，springboot svc 3，springboot svc 4-2 的调用都是错误的，这些服务调用错误都是由 springboot svc 4-2 调用错误引发的连锁反应，只有 springboot svc 4-1 调用是成功的。 调用 springboot svc 4-2 时 skywalking span 中记录的信息如下：  通过以上信息我们能够知道 springboot svc 4-2 的服务端出现了问题，从而能够精准地去解决问题。 ","version":"Next","tagName":"h3"},{"title":"加入Higress社区​","type":1,"pageTitle":"Higress + Skywalking + SpringBoot 链路追踪探索","url":"/zh-cn/docs/user/skywalking-springboot#加入higress社区","content":" ","version":"Next","tagName":"h2"},{"title":"实现 SpringCloud 服务发现和路由","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/spring-cloud","content":"","keywords":"SpringCloud discovery","version":"Next"},{"title":"使用 Nacos 做注册中心​","type":1,"pageTitle":"实现 SpringCloud 服务发现和路由","url":"/zh-cn/docs/user/spring-cloud#使用-nacos-做注册中心","content":"应用配置具体参考Nacos Spring Cloud 快速开始进行应用配置 ","version":"Next","tagName":"h2"},{"title":"不指定命名空间​","type":1,"pageTitle":"实现 SpringCloud 服务发现和路由","url":"/zh-cn/docs/user/spring-cloud#不指定命名空间","content":"如果 application.properties 中没有指定 Nacos 命名空间，例如： server.port=8080 spring.application.name=my-service spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848  则 Higress 的 McpBridge 中亦无需指定命名空间： apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: # 定义一个名为 my-nacos 的服务来源 - name: my-nacos # 注册中心类型是 Nacos 2.x，支持 gRPC 协议 type: nacos2 # 注册中心的访问地址，可以是域名或者IP domain: 127.0.0.1 # 注册中心的访问端口，Nacos 默认都是 8848 port: 8848 # Nacos 服务分组 nacosGroups: - DEFAULT_GROUP  配置 Ingress 转发到这个服务(假设/api前缀的路由都转发给这个服务)需要做如下配置： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: my-service.DEFAULT-GROUP.public.nacos name: demo namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: /api pathType: Prefix  注意这里通过注解higress.io/destination指定路由最终要转发到的目标服务。 对于 Nacos 来源的服务，这里的目标服务格式为：“服务名称.服务分组.命名空间ID.nacos”，注意这里需要遵循 DNS 域名格式，因此服务分组中的下划线'_'被转换成了横杠'-'。命名空间未指定时，这里默认值为&quot;public&quot;。 ","version":"Next","tagName":"h3"},{"title":"指定命名空间、服务分组等信息​","type":1,"pageTitle":"实现 SpringCloud 服务发现和路由","url":"/zh-cn/docs/user/spring-cloud#指定命名空间服务分组等信息","content":"如果 application.properties 中指定了 Nacos 命名空间，服务分组等信息，例如： server.port=8080 spring.application.name=my-service spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 spring.cloud.nacos.discovery.namespace=d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358 spring.cloud.nacos.discovery.group=custom-group  则 Higress 的 McpBridge 做相应配置即可 apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: # 定义一个名为 my-nacos 的服务来源 - name: my-nacos # 注册中心类型是 Nacos 2.x，支持 gRPC 协议 type: nacos2 # 注册中心的访问地址，可以是域名或者IP domain: 127.0.0.1 # 注册中心的访问端口，Nacos 默认都是 8848 port: 8848 # Nacos 命名空间 ID nacosNamespaceId: d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358 # Nacos 服务分组 nacosGroups: - custom-group  配置 Ingress 转发到这个服务(假设/api前缀的路由都转发给这个服务)需要做如下配置： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: my-service.custom-group.d8ac64f3-xxxx-xxxx-xxxx-47a814ecf358.nacos name: demo namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: /api pathType: Prefix  ","version":"Next","tagName":"h3"},{"title":"使用 ZooKeeper 做注册中心​","type":1,"pageTitle":"实现 SpringCloud 服务发现和路由","url":"/zh-cn/docs/user/spring-cloud#使用-zookeeper-做注册中心","content":"使用 Zookeeper 做注册中心时，注意必须配置spring.cloud.zookeeper.discovery.preferIpAddress=true，否则注册到注册中心中到地址为主机名称，而不是IP。 ","version":"Next","tagName":"h2"},{"title":"不指定注册根路径​","type":1,"pageTitle":"实现 SpringCloud 服务发现和路由","url":"/zh-cn/docs/user/spring-cloud#不指定注册根路径","content":"如果 application.properties 中未指定注册根路径信息，例如： spring.application.name=my-service spring.cloud.zookeeper.connect-string=127.0.0.1:2181 spring.cloud.zookeeper.discovery.preferIpAddress=true spring.cloud.zookeeper.discovery.enabled=true spring.cloud.zookeeper.discovery.register=true  则 Higress 的 McpBridge 中亦无需指定zkServicePath： apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: # 定义一个名为 my-zk 的服务来源 - name: my-zk # 注册中心类型是 ZooKeeper type: zookeeper # 注册中心的访问地址，可以是域名或者IP domain: 127.0.0.1 # 注册中心的访问端口 port: 2181  配置 Ingress 转发到这个服务(假设/api前缀的路由都转发给这个服务)需要做如下配置： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: my-service.services.zookeeper name: demo namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: /api pathType: Prefix  注意对于 ZooKeeper 来源的服务，这里的目标服务格式为：&quot;服务名称.服务注册根路径.zookeeper&quot;，SpringCloud 在未指定服务注册根路径的情况下，根路径默认是&quot;services&quot; ","version":"Next","tagName":"h3"},{"title":"指定注册根路径​","type":1,"pageTitle":"实现 SpringCloud 服务发现和路由","url":"/zh-cn/docs/user/spring-cloud#指定注册根路径","content":"如果 application.properties 中指定了注册根路径信息，例如： spring.application.name=my-service spring.cloud.zookeeper.connect-string=127.0.0.1:2181 spring.cloud.zookeeper.discovery.preferIpAddress=true spring.cloud.zookeeper.discovery.enabled=true spring.cloud.zookeeper.discovery.register=true spring.cloud.zookeeper.discovery.root=my-services-root  则 Higress 的 McpBridge 中亦需指定zkServicePath： apiVersion: networking.higress.io/v1 kind: McpBridge metadata: name: default namespace: higress-system spec: registries: # 定义一个名为 my-zk 的服务来源 - name: my-zk # 注册中心类型是 ZooKeeper type: zookeeper # 注册中心的访问地址，可以是域名或者IP domain: 127.0.0.1 # 注册中心的访问端口 port: 2181 # 对应 spring.cloud.zookeeper.discovery.root 配置字段 zkServicePath: - my-services-root  配置 Ingress 转发到这个服务(假设/api前缀的路由都转发给这个服务)需要做如下配置： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: higress.io/destination: my-service.my-services-root.zookeeper name: demo namespace: default spec: rules: - http: paths: - backend: resource: apiGroup: networking.higress.io kind: McpBridge name: default path: /api pathType: Prefix  注意如果 spring.cloud.zookeeper.discovery.root 中包含了下划线，需要被替换为横杠，因为目标服务整体格式需要满足 DNS 域名规范 ","version":"Next","tagName":"h3"},{"title":"快速开始","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/quickstart","content":"","keywords":"Higress","version":"Next"},{"title":"环境一：在 K8s 中使用​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#环境一在-k8s-中使用","content":"","version":"Next","tagName":"h2"},{"title":"阶段一：安装​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#阶段一安装","content":"场景一：在标准 K8s 集群中使用​ Helm 安装命令 helm repo add higress.io https://higress.io/helm-charts helm install higress -n higress-system higress.io/higress --create-namespace --render-subchart-notes  中国大陆用户可以使用以下方法加速安装： helm repo add higress.cn https://higress.cn/helm-charts helm upgrade --install higress -n higress-system higress.cn/higress --create-namespace --render-subchart-notes  获取 Higress Gateway 的 LoadBalancer IP，并记录下来。后续可以通过该 IP 的 80 和 443 端口访问 Higress Gateway。 kubectl get svc -n higress-system higress-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}'  备注 如果 LoadBalancer IP 获取不到，说明您当前的 K8s 集群不支持 LoadBalancer 类型的 Service，可以考虑以下方案： 使用云厂商提供的 K8s 服务，例如阿里云 ACK参考运维参数配置，开启higress-core.gateway.hostNetwork，让 Higress 监听本机端口，再通过其他软/硬负载均衡器转发给固定机器 IP（生产不建议）使用开源的负载均衡方案 MetalLB 场景二：在本地 K8s 环境中使用​ 以下步骤适用于所有在本地启动 K8s 集群进行验证的场景。如果您本地已经配置好了一个测试集群，可以直接跳转到第三步安装 Higress。 第一步：安装 kubectl &amp; kind​ MacOS： # for Intel Macs [ $(uname -m) = x86_64 ] &amp;&amp; curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl&quot; [ $(uname -m) = x86_64 ] &amp;&amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.18.0/kind-darwin-amd64 # for Apple Silicon Macs (M1/M2) [ $(uname -m) = arm64 ] &amp;&amp; curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/arm64/kubectl&quot; [ $(uname -m) = arm64 ] &amp;&amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.18.0/kind-darwin-arm64 chmod +x ./kubectl ./kind sudo mv ./kubectl ./kind /usr/local/bin  Windows 中使用 PowerShell： 下载 kubectl v1.27.1 和 kind v0.18.0。 如果你本地安装了 curl 工具，可直接执行以下命令： curl.exe -LO &quot;https://dl.k8s.io/release/v1.27.1/bin/windows/amd64/kubectl.exe&quot; curl.exe -Lo kind-windows-amd64.exe https://kind.sigs.k8s.io/dl/v0.18.0/kind-windows-amd64  注：若要获知 kubectl 的最新稳定版本（例如用于脚本编写等场景），可查看 https://dl.k8s.io/release/stable.txt 的内容. 然后将下载下来的 kind-windows-amd64 或者 kind-windows-amd64.exe 重命名为 kind.exe，并将 kubectl.exe 和 kind.exe 移动到 PATH 环境变量所包含的路径下。 Linux: curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.18.0/kind-linux-amd64 chmod +x ./kubectl ./kind sudo mv ./kubectl ./kind /usr/local/bin  第二步：创建并启用 kind​ 首先创建一个集群配置文件: cluster.conf # cluster.conf kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 # networking: # WARNING: It is _strongly_ recommended that you keep this the default # (127.0.0.1) for security reasons. However it is possible to change this. # apiServerAddress: &quot;0.0.0.0&quot; # By default the API server listens on a random open port. # You may choose a specific port but probably don't need to in most cases. # Using a random port makes it easier to spin up multiple clusters. # apiServerPort: 6443 nodes: - role: control-plane kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: &quot;ingress-ready=true&quot; extraPortMappings: - containerPort: 80 hostPort: 80 protocol: TCP - containerPort: 443 hostPort: 443 protocol: TCP  Mac &amp; Linux 系统执行： kind create cluster --name higress --config=cluster.conf kubectl config use-context kind-higress  Windows 系统执行: kind.exe create cluster --name higress --config=cluster.conf kubectl.exe config use-context kind-higress  备注 上述配置是为了将本地（127.0.0.1）的80和443端口用于Higress访问 第三步：安装 Higress​ 本地安装开关: --set global.local=true helm repo add higress.io https://higress.io/helm-charts helm install higress -n higress-system higress.io/higress --create-namespace --render-subchart-notes --set global.local=true --set global.o11y.enabled=false  若要启用 Higress 内置的套件，可参阅安装部署文档。 安装完成后，通过本地的 80 和 443 端口即可访问本地集群内的 Higress Gateway。 注：如果您使用的是本地现存的 K8s 集群，那么可能需要先执行下方命令将 K8s 集群内的端口映射出来，然后再尝试访问本地端口。 kubectl port-forward service/higress-gateway -n higress-system 80:80 443:443  ","version":"Next","tagName":"h3"},{"title":"阶段二：配置​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#阶段二配置","content":"假设在 default 命名空间下已经部署了一个名为 foo 的服务，而我们希望创建一个对应 http://foo.bar.com/foo 的路由指向该服务。 如果需要的话，各位可以使用下方 YAML 来创建对应的测试服务。 kind: Pod apiVersion: v1 metadata: name: foo-app labels: app: foo spec: containers: - name: foo-app image: higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/http-echo:0.2.4-alpine args: - &quot;-text=foo&quot; --- kind: Service apiVersion: v1 metadata: name: foo-service spec: selector: app: foo ports: # Default port used by the image - port: 5678  方法一：使用 Higress Console 进行配置​ 使用 hgctl 打开控制台： hgctl dashboard console  首次访问时需要先初始化管理员账号。  初始化完成后，界面会自动跳转至登录页面。请使用前面设置的用户名密码登录 Higress 控制台。  点击左侧“域名管理”导航栏，然后点击页面右侧的“创建域名”按钮。按照下图所示内容填写表单并点击“确定”按钮。  点击左侧“路由管理”导航栏，然后点击页面右侧的“创建路由”按钮。按照下图片所示内容填写表单并点击“确定”按钮。  方法二：使用 Ingress CRD 进行配置​ 使用下方 YAML 来创建我们需要的路由配置。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: foo spec: ingressClassName: higress rules: - host: foo.bar.com http: paths: - pathType: Prefix path: &quot;/foo&quot; backend: service: name: foo-service port: number: 5678  ","version":"Next","tagName":"h3"},{"title":"阶段三：请求验证​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#阶段三请求验证","content":"执行以下命令，验证测试路由可以正常工作： # should output &quot;foo&quot; curl http://GatewayIP/foo -H 'host: foo.bar.com'  ","version":"Next","tagName":"h3"},{"title":"环境二：脱离 K8s 在 Docker Compose 中使用​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#环境二脱离-k8s-在-docker-compose-中使用","content":"注意 Standalone 模式没有大规模生产使用过，目前主要用于本地部署测试的场景，如果生产部署更建议云原生模式部署 ","version":"Next","tagName":"h2"},{"title":"阶段一：安装​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#阶段一安装-1","content":"安装命令一：使用独立部署的 Nacos curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -a -c nacos://192.168.0.1:8848 --nacos-username=nacos --nacos-password=nacos  请将 192.168.0.1 替换为 Nacos 服务器的 IP（如果 Nacos 部署在本机，请不要使用如 localhost 或 127.0.0.1 的 Loopback 地址），并按需调整 --nacos-username 和 --nacos-password 的取值。如果 Nacos 服务未开启认证功能，则可以移除这两个参数。 安装命令二：使用 Higress 内置 Nacos curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -a --use-builtin-nacos  注：Windows 系统下可以使用 Cygwin、Git Bash 等类 Unix Shell 中执行上述命令。 ","version":"Next","tagName":"h3"},{"title":"阶段二：配置​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#阶段二配置-1","content":"在浏览器中输入http://127.0.0.1:8080 进入 Higress 控制台。首次访问时需要先初始化管理员账号。  初始化完成后，界面会自动跳转至登录页面。请使用前面设置的用户名密码登录 Higress 控制台。  点击左侧“服务来源”导航栏，然后点击页面右侧的“创建服务来源”按钮。按照下图所示内容填写表单并点击“确定”按钮。  点击左侧“域名管理”导航栏，然后点击页面右侧的“创建域名”按钮。按照下图所示内容填写表单并点击“确定”按钮。  点击左侧“路由管理”导航栏，然后点击页面右侧的“创建路由”按钮。按照下图片所示内容填写表单并点击“确定”按钮。  ","version":"Next","tagName":"h3"},{"title":"阶段三：请求验证​","type":1,"pageTitle":"快速开始","url":"/zh-cn/docs/user/quickstart#阶段三请求验证-1","content":"执行以下命令，验证测试路由可以正常工作： # should output a JSON object containing request data curl http://localhost/get?foo=bar -H 'host: foo.bar.com'  ","version":"Next","tagName":"h3"},{"title":"开启 WAF 防护的最佳实践","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/waf","content":"","keywords":"higress higress官网 云原生网关","version":"Next"},{"title":"相关知识介绍​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#相关知识介绍","content":"","version":"Next","tagName":"h2"},{"title":"ModSecurity​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#modsecurity","content":"ModSecurity是一个开源的跨平台Web应用程序防火墙（WAF）引擎，是目前世界上使用最多的开源WAF产品，其主要功能是对传入的 HTTP 请求进行分析和过滤，以便检测和阻止潜在的攻击，主要包括： SQL Injection (SQLi)：阻止SQL注入Cross Site Scripting (XSS)：阻止跨站脚本攻击Local File Inclusion (LFI)：阻止利用本地文件包含漏洞进行攻击Remote File Inclusione(RFI)：阻止利用远程文件包含漏洞进行攻击Remote Code Execution (RCE)：阻止利用远程命令执行漏洞进行攻击PHP Code Injectiod：阻止PHP代码注入HTTP Protocol Violations：阻止违反HTTP协议的恶意访问HTTPoxy：阻止利用远程代理感染漏洞进行攻击Shellshock：阻止利用Shellshock漏洞进行攻击 ModSecurity通过一个基于规则的引擎实现这些功能，这些规则定义了要匹配和处理的模式和行为。 ","version":"Next","tagName":"h3"},{"title":"安全规则语言​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#安全规则语言","content":"ModSecurity规则语言（也称为SecLang）是一种基于正则表达式和模式匹配的领域特定语言，用于描述和检测Web应用程序中的安全事件和攻击。 SecLang 支持以下基本概念和语法结构： 事务和规则：SecLang中的规则以事务为单位，事务包含一个或多个规则。规则定义了要匹配和检测的模式，以及在匹配时要执行的操作。动作：规则可以包含多种动作，用于执行特定的操作，如日志记录、拦截请求、设置变量、修改请求等。条件：规则可以使用条件语句来指定仅在满足特定条件时才执行的动作。条件可以基于请求的各个方面，如请求方法、URI、请求头、请求正文、IP地址等。变量：SecLang 支持内置变量和用户定义的变量，用于存储和操作请求和响应中的数据。变量可以用于规则匹配、条件判断和动作执行。运算符：SecLang 提供了各种运算符，用于执行模式匹配、比较和逻辑操作。这些运算符用于构建规则的条件和操作。 SecLang 允许用户编写自定义规则，以指定在HTTP请求和响应中应该如何检测和处理潜在的安全问题。规则可以定义诸如阻止恶意请求、过滤特定的数据、拦截SQL注入和跨站点脚本（XSS）等攻击类型的行为。通过使用SecLang，用户可以利用ModSecurity的强大功能来保护Web应用程序免受各种安全威胁。更多关于SecLang的语法规则可参考SecLang语法参考。 ","version":"Next","tagName":"h3"},{"title":"OWASP核心规则集​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#owasp核心规则集","content":"OWASP CRS（OWASP ModSecurity Core Rule Set）是一个由OWASP（开放式Web应用安全项目）社区开发和维护的ModSecurity规则集合。它是一套预先定义的规则，旨在提供保护Web应用程序免受广泛的Web安全威胁和攻击。这些规则可以根据具体的需求进行修改，以适应不同的 Web 应用程序的安全需求。 ","version":"Next","tagName":"h3"},{"title":"WAF插件防护原理​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#waf插件防护原理","content":"WAF 插件基于 Higress Wasm Go SDK 以及 Coraza 实现，遵循 Modsecurity 定义的 Phase 规范。 Phase 1: Request headersPhase 2: Request bodyPhase 3: Response headersPhase 4: Response bodyPhase 5: Logging  插件内置了OWASP CRS以提供基础的防护功能，支持用户自定义防护规则，并且支持路由级/域名级细粒度防护。 ","version":"Next","tagName":"h2"},{"title":"使用示例​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#使用示例","content":"首先准备一个k8s集群，并安装Higress，参考Higress部署教程。 ","version":"Next","tagName":"h2"},{"title":"部署服务并创建ingress​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#部署服务并创建ingress","content":"在K8s集群中apply如下资源，以部署后端服务以及ingress： apiVersion: apps/v1 kind: Deployment metadata: name: httpbin-deployment labels: app: httpbin-deployment spec: replicas: 1 selector: matchLabels: app: httpbin-deployment template: metadata: labels: app: httpbin-deployment spec: containers: - image: kennethreitz/httpbin imagePullPolicy: IfNotPresent name: httpbin-backend ports: - name: http containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: httpbin-service namespace: default labels: app: httpbin-service spec: ports: - port: 8080 name: http protocol: TCP targetPort: 80 selector: app: httpbin-deployment type: ClusterIP --- kind: Pod apiVersion: v1 metadata: name: foo-app labels: app: foo spec: containers: - name: foo-app image: higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/http-echo:0.2.4-alpine args: - &quot;-text=foo&quot; --- kind: Service apiVersion: v1 metadata: name: foo-service spec: selector: app: foo ports: # Default port used by the image - port: 5678 --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: httpbin-ingress namespace: default spec: ingressClassName: higress rules: - http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: httpbin-service port: number: 8080 --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: echo-ingress namespace: default spec: ingressClassName: higress rules: - http: paths: - pathType: Prefix path: &quot;/foo&quot; backend: service: name: foo-service port: number: 5678  访问两条路由（/user-agent被路由到httpbin-service服务，/foo被路由到foo-service）： ","version":"Next","tagName":"h3"},{"title":"安装WAF插件​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#安装waf插件","content":"在K8s集群中apply如下资源，以部署WAF插件： apiVersion: extensions.higress.io/v1alpha1 kind: WasmPlugin metadata: name: waf-go namespace: higress-system spec: defaultConfig: useCRS: true secRules: - &quot;SecRuleEngine On&quot; - &quot;SecDebugLogLevel 3&quot; - &quot;SecRule REQUEST_URI \\&quot;@streq /admin\\&quot; \\&quot;id:101,phase:1,t:lowercase,deny\\&quot;&quot; matchRules: - ingress: - default/echo-ingress config: secRules: - &quot;SecRuleEngine On&quot; - &quot;SecDebugLogLevel 3&quot; - &quot;SecAction \\&quot;id:102,phase:1,deny\\&quot;&quot; url: oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/go-waf:1.0.1  上述配置含义如下： defaultConfig下配置了全局的防护规则 useCRS=true表明加载OWASP CRS安全规则集secRules下有三条规则为用户自定义的防护规则。 matchRules下配置了路由级防护规则（域名级同理），参考Higress插件使用文档 ingress用于指定防护规则生效的路由，这里设置的路由为default命名空间下的echo-ingress路由config下配置路由级防护规则，结构与defaultConfig一致，在这里没有加载OWASP CRS规则集，并且设置拦截一切请求。 ","version":"Next","tagName":"h3"},{"title":"请求拦截示例​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#请求拦截示例","content":"自定义规则防护测试​ 测试我们在全局防护规则中定义的如下自定义规则： &quot;SecRule REQUEST_URI \\&quot;@streq /admin\\&quot; \\&quot;id:101,phase:1,t:lowercase,deny\\&quot;&quot;  该条规则会阻止path为/admin的请求： 细粒度（路由级/域名级）防护测试​ 以路由级为例，访问/foo，该请求命中以下路由级防护规则： matchRules: - ingress: - default/echo-ingress config: secRules: - &quot;SecRuleEngine On&quot; - &quot;SecDebugLogLevel 3&quot; - &quot;SecAction \\&quot;id:102,phase:1,deny\\&quot;&quot;  根据该防护规则，该请求将会被拦截： 常见攻击防护测试​ shell注入攻防示例 sql注入攻防示例 远程文件包含（RFI）攻防示例 xss攻防示例 php注入攻防示例 ","version":"Next","tagName":"h3"},{"title":"整体防护能力评估​","type":1,"pageTitle":"开启 WAF 防护的最佳实践","url":"/zh-cn/docs/user/waf#整体防护能力评估","content":"GoTestWAF是一款API和OWASP攻击模拟工具，支持包括REST、GraphQL、gRPC、WebSockets、SOAP、XMLRPC等多种API协议，旨在评估Web应用安全解决方案，如API安全代理、Web应用防火墙（WAF）、IPS、API网关等。 该工具使用放置在HTTP请求正文、标头、URL参数等不同部分的不同编码的有效负载生成恶意请求，涵盖了常见的各种攻击类型。 多种攻击测试结果如下图所示，图中结果表明WAF插件能够有效检测各种攻击类型的非法请求。 WAF防护功能整体得分如下，高于gotestwaf提供的benchmark（benchmark中paranoia表示防护等级，数值越大，防护等级越高，正确拦截与误拦截的请求数均会增加），测试结果表明WAF插件具有较好的防护能力。 ","version":"Next","tagName":"h2"},{"title":"Wasm 插件镜像规范","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/wasm-image-spec","content":"","keywords":"wasm image oci","version":"Next"},{"title":"1. 概述​","type":1,"pageTitle":"Wasm 插件镜像规范","url":"/zh-cn/docs/user/wasm-image-spec#1-概述","content":"本规范旨在定义对 Higress Wasm Plugin 镜像的内容和构建方式。在编写时，笔者参考了 Wasm Image Specification。 注意：本规范使用 OCI 镜像格式，并不限定插件只能使用 OCI 镜像，对于自定义插件开发，请参考自定义插件里介绍的更简单的方式。 OCI 镜像是用来规范所有平台推出的通用标准插件使用 ","version":"Next","tagName":"h2"},{"title":"2. 镜像结构​","type":1,"pageTitle":"Wasm 插件镜像规范","url":"/zh-cn/docs/user/wasm-image-spec#2-镜像结构","content":"每个镜像必须基于 scratch 使用 OCI 格式规范进行构建，且可包含以下文件： spec.yaml：必要。插件的元数据文件。其内容格式请见第 3 节。README.md：必要。插件的用法说明文件。使用 Markdown 格式。语言可使用英文或中文。README_{lang}.md：可选。插件用法说明文件的翻译版本。使用 Markdown 格式。lang 的取值为 ZH 或 EN。icon.png：可选。插件的图标文件。也可以选择在 spec.yaml 中指定图标 URL。二者同时存在时，系统会使用包内部的图标文件用于展示。plugin.wasm：必要。插件的二进制文件。 镜像的每一层只可包含一个文件。 除 plugin.wasm 所在层外，其它层需根据文件名设置 media type： spec.yaml：application/vnd.module.wasm.spec.v1+yaml README.md：application/vnd.module.wasm.doc.v1+markdownREADME_{lang}.md：application/vnd.module.wasm.doc.v1.{lang}+markdownicon.png：application/vnd.module.wasm.icon.v1+png plugin.wasm 文件必须放置于镜像的最后一层，且该层应使用 application/vnd.oci.image.layer.v1.tar+gzip 作为 media type。 ","version":"Next","tagName":"h2"},{"title":"3. 元数据文件格式​","type":1,"pageTitle":"Wasm 插件镜像规范","url":"/zh-cn/docs/user/wasm-image-spec#3-元数据文件格式","content":"本节以 basic-auth 插件的元数据信息为例，介绍元数据文件 spec.yaml 的格式。 apiVersion: 1.0.0 # 本文件所使用的格式版本。目前固定为 1.0.0 info: category: auth # 插件类型。可选值有：auth（认证鉴权）、security（安全防护）、protocol（协议转换）、flow-control（流量控制）、flow-monitor（流量观测）、custom（自定义） name: basic-auth/v1 # 插件名称。这是插件的唯一标识。建议在尾部追加类似&quot;/v1&quot;的版本号，以便应对后续不兼容升级的场景 title: Basic Auth # 显示名称，支持国际化 description: 本插件实现了基于 HTTP Basic Auth 标准进行认证鉴权的功能。 # 功能描述，支持国际化 x-description-i18n: # 上面 description 字段的国际化内容。所有支持国际化的字段均可使用&quot;x-{name}-i18n&quot;的方式添加国际化内容 en-US: This plugin implements an authentication function based on HTTP Basic Auth standard. iconUrl: https://img.alicdn.com/imgextra/i1/O1CN01I7WjVs1K33EQjInid_!!6000000001107-2-tps-960-290.png # 可选，插件的图标文件 URL。 version: 1.0.0 # 版本号 contact: # 联系信息 name: Higress Team url: http://higress.io/ email: admin@higress.io spec: phase: AUTHN # 运行阶段。取值请参考 https://istio.io/latest/docs/reference/config/proxy_extensions/wasm-plugin/#PluginPhase priority: 0 # 阶段内的运行优先级。取值请参考 https://istio.io/latest/docs/reference/config/proxy_extensions/wasm-plugin/#WasmPlugin configSchema: # 插件运行配置的数据模型，目前仅支持使用 OpenAPI 3.0.0 标准中的 Schema 格式进行定义 openAPIV3Schema: # 以下内容的数据格式请参考 https://openapi.apifox.cn/#schema-%E5%AF%B9%E8%B1%A1 。部分显示用字段支持国际化。 type: object properties: consumers: type: array scope: GLOBAL # 配置项作用范围。可选值：GLOBAL（全局配置）、INSTANCE（实例级配置，即在关联路由、域名时的配置）、ALL（全局、实例皆可配置）。可空。缺省值为 INSTANCE。 title: 调用方列表 x-title-i18n: en-US: Consumer List description: 服务调用方列表，用于对请求进行认证 x-description-i18n: en-US: List of service consumers which will be used in request authentication items: type: object properties: name: type: string title: 名称 x-title-i18n: en-US: Name description: 该调用方的名称 x-description-i18n: en-US: The name of the consumer # 数据校验场景参照 JSON Schema Validation Spec 实现 # https://json-schema.org/draft/2020-12/json-schema-validation.html # 目前支持以下字段： # - maximum # - minimum # - maxLength # - minLength # - pattern # - maxItems # - minItems # - required minLength: 6 # 最小长度，用于数据校验 maxLength: 256 # 最大长度，用于数据校验 pattern: &quot;^$&quot; # 正则表达式，用于数据校验 example: - consumer1 credential: type: string title: 访问凭证 x-title-i18n: en-US: Credential description: 该调用方的访问凭证 x-description-i18n: en-US: The credential of the consumer example: - admin:123456 required: - name - credential allow: type: array title: 授权访问的调用方列表 x-title-i18n: en-US: Allowed Consumers description: 对于匹配上述条件的请求，允许访问的调用方列表 x-description-i18n: en-US: Consumers to be allowed for matched requests items: type: string example: - consumer1 required: - allow - consumers example: consumers: - name: consumer1 credential: admin:123456 - name: consumer2 credential: guest:abc allow: - consumer2  ","version":"Next","tagName":"h2"},{"title":"4. 镜像构建方式​","type":1,"pageTitle":"Wasm 插件镜像规范","url":"/zh-cn/docs/user/wasm-image-spec#4-镜像构建方式","content":"在 Higress 项目目录内启动构建用容器 GO_VERSION=&quot;1.19&quot; TINYGO_VERSION=&quot;0.28.1&quot; ORAS_VERSION=&quot;1.0.0&quot; PLUGIN_NAME=&quot;hello-world&quot; BUILDER_IMAGE=&quot;higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-builder:go${GO_VERSION}-tinygo${TINYGO_VERSION}-oras${ORAS_VERSION}&quot; docker run -v ${PWD}:/workspace -e PLUGIN_NAME=${PLUGIN_NAME} -it --rm ${BUILDER_IMAGE} /bin/bash  在容器中构建 Wasm 文件 cd /workspace/plugins/wasm-go/extensions/${PLUGIN_NAME} go mod tidy tinygo build -o ./plugin.wasm -scheduler=none -target=wasi -gc=custom -tags='custommalloc nottinygc_finalizer' ./main.go  构建并推送 OCI 镜像 tar czvf plugin.tar.gz plugin.wasm IMAGE_REGISTRY_SERVICE=docker.io IMAGE_REPOSITORY=&quot;${IMAGE_REGISTRY_SERVICE}/plugins/${PLUGIN_NAME}&quot; IMAGE_TAG=&quot;v0.0.1&quot; oras login ${IMAGE_REGISTRY_SERVICE} oras push ${IMAGE_REPOSITORY}:${IMAGE_TAG} \\ ./spec.yaml:application/vnd.module.wasm.spec.v1+yaml \\ ./README.md:application/vnd.module.wasm.doc.v1+markdown \\ ./README_EN.md:application/vnd.module.wasm.doc.v1.en+markdown \\ ./plugin.tar.gz:application/vnd.oci.image.layer.v1.tar+gzip  ","version":"Next","tagName":"h2"},{"title":"5. 附录​","type":1,"pageTitle":"Wasm 插件镜像规范","url":"/zh-cn/docs/user/wasm-image-spec#5-附录","content":"","version":"Next","tagName":"h2"},{"title":"5.1 各插件类型的缺省图标​","type":1,"pageTitle":"Wasm 插件镜像规范","url":"/zh-cn/docs/user/wasm-image-spec#51-各插件类型的缺省图标","content":"自定义：https://img.alicdn.com/imgextra/i1/O1CN018iKKih1iVx287RltL_!!6000000004419-2-tps-42-42.png认证鉴权：https://img.alicdn.com/imgextra/i4/O1CN01BPFGlT1pGZ2VDLgaH_!!6000000005333-2-tps-42-42.png流量管控：https://img.alicdn.com/imgextra/i3/O1CN01bAFa9k1t1gdQcVTH0_!!6000000005842-2-tps-42-42.png流量观测：https://img.alicdn.com/imgextra/i4/O1CN01aet3s61MoLOEEhRIo_!!6000000001481-2-tps-42-42.png安全防护：https://img.alicdn.com/imgextra/i1/O1CN01jKT9vC1O059vNaq5u_!!6000000001642-2-tps-42-42.png传输协议：https://img.alicdn.com/imgextra/i2/O1CN01xIywow1mVGuRUjbhe_!!6000000004959-2-tps-42-42.png ","version":"Next","tagName":"h3"},{"title":"使用 GO 语言开发 WASM 插件","type":0,"sectionRef":"#","url":"/zh-cn/docs/user/wasm-go","content":"","keywords":"wasm","version":"Next"},{"title":"一、工具准备​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#一工具准备","content":"需要先安装 Golang 和 TinyGo 两个程序 ","version":"Next","tagName":"h2"},{"title":"1. Golang​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#1-golang","content":"（要求 1.18 版本以上） 官方指引链接：https://go.dev/doc/install Windows​ 下载安装文件：https://go.dev/dl/go1.19.windows-amd64.msi打开下载好的安装文件直接安装，默认会安装到 Program Files 或 Program Files (x86) 目录安装完成后，使用键盘上的快捷键“Win+R”打开运行窗口，在运行窗口中输入“cmd”点击确定即可打开命令窗口，输入命令：go version，输出当前安装的版本，表明安装成功 MacOS​ 下载安装文件：https://go.dev/dl/go1.19.darwin-amd64.pkg打开下载好的安装文件直接安装，默认会安装到/usr/local/go目录打开终端命令行工具，输入命令：go version，输出当前安装的版本，表明安装成功 Linux​ 下载安装文件：https://go.dev/dl/go1.19.linux-amd64.tar.gz执行下列命令进行安装： rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin  执行 go version，输出当前安装的版本，表明安装成功 ","version":"Next","tagName":"h3"},{"title":"2. TinyGo​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#2-tinygo","content":"（要求 0.28.1 版本以上） 官方指引链接：https://tinygo.org/getting-started/install/ Windows​ 下载安装文件：https://github.com/tinygo-org/tinygo/releases/download/v0.28.1/tinygo0.28.1.windows-amd64.zip解压安装文件到指定目录如果安装解压后的目录为C:\\tinygo，则需要将C:\\tinygo\\bin添加到环境变量PATH中，例如通过在命令窗口中输入 set 命令设置 set PATH=%PATH%;&quot;C:\\tinygo\\bin&quot;;  在命令窗口执行命令 tinygo version，输出当前安装的版本，表明安装成功 MacOS​ 下载压缩包并解压 wget https://github.com/tinygo-org/tinygo/releases/download/v0.28.1/tinygo0.28.1.darwin-amd64.tar.gz tar -zxf tinygo0.28.1.darwin-amd64.tar.gz  如果安装解压后的目录为/tmp，则需要将/tmp/tinygo/bin添加到环境变量PATH中： export PATH=/tmp/tinygo/bin:$PATH  在终端执行 tinygo version，输出当前安装的版本，表明安装成功 Linux​ 以 Ubuntu 下 amd64 架构为例，其他系统请参考官方指引链接 下载 DEB 文件，并安装 wget https://github.com/tinygo-org/tinygo/releases/download/v0.28.1/tinygo_0.28.1_amd64.deb sudo dpkg -i tinygo_0.28.1_amd64.deb export PATH=$PATH:/usr/local/bin  在终端执行 tinygo version，输出当前安装的版本，表明安装成功 ","version":"Next","tagName":"h3"},{"title":"二、编写插件​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#二编写插件","content":"","version":"Next","tagName":"h2"},{"title":"1. 初始化工程目录​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#1-初始化工程目录","content":"新建一个工程目录文件，例如wasm-demo-go在所建目录下执行以下命令，进行 Go 工程初始化 go mod init wasm-demo-go  国内环境可能需要设置下载依赖包的代理 go env -w GOPROXY=https://proxy.golang.com.cn,direct  下载构建插件的依赖 go get github.com/higress-group/proxy-wasm-go-sdk go get github.com/alibaba/higress/plugins/wasm-go@main go get github.com/tidwall/gjson  ","version":"Next","tagName":"h3"},{"title":"2. 编写 main.go 文件​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#2-编写-maingo-文件","content":"下面是一个简单示例，实现了在插件配置mockEnable: true时直接返回hello world应答；未做插件配置，或者设置mockEnable: false时给原始请求添加 hello: world请求头。更多例子请参考本文第四节。 注意：在网关控制台中的插件配置为 yaml 格式，下发给插件时将自动转换为 json 格式，所以例子中的 parseConfig 可以直接从 json 中解析配置 package main import ( &quot;github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types&quot; &quot;github.com/tidwall/gjson&quot; ) func main() { wrapper.SetCtx( // 插件名称 &quot;my-plugin&quot;, // 为解析插件配置，设置自定义函数 wrapper.ParseConfigBy(parseConfig), // 为处理请求头，设置自定义函数 wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders), ) } // 自定义插件配置 type MyConfig struct { mockEnable bool } // 在控制台插件配置中填写的yaml配置会自动转换为json，此处直接从json这个参数里解析配置即可 func parseConfig(json gjson.Result, config *MyConfig, log wrapper.Log) error { // 解析出配置，更新到config中 config.mockEnable = json.Get(&quot;mockEnable&quot;).Bool() return nil } func onHttpRequestHeaders(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log) types.Action { proxywasm.AddHttpRequestHeader(&quot;hello&quot;, &quot;world&quot;) if config.mockEnable { proxywasm.SendHttpResponse(200, nil, []byte(&quot;hello world&quot;), -1) } return types.ActionContinue }  HTTP 处理挂载点​ 上面示例代码中通过 wrapper.ProcessRequestHeadersBy将自定义函数 onHttpRequestHeaders用于HTTP 请求头处理阶段处理请求。除此之外，还可以通过下面方式，设置其他阶段的自定义处理函数 HTTP 处理阶段\t触发时机\t挂载方法HTTP 请求头处理阶段\t网关接收到客户端发送来的请求头数据时\twrapper.ProcessRequestHeadersBy HTTP 请求 Body 处理阶段\t网关接收到客户端发送来的请求 Body 数据时\twrapper.ProcessRequestBodyBy HTTP 应答头处理阶段\t网关接收到后端服务响应的应答头数据时\twrapper.ProcessResponseHeadersBy HTTP 应答 Body 处理阶段\t网关接收到后端服务响应的应答 Body 数据时\twrapper.ProcessResponseBodyBy 工具方法​ 上面示例代码中的 proxywasm.AddHttpRequestHeader 和 proxywasm.SendHttpResponse是插件 SDK 提供的两个工具方法，主要的工具方法见下表： 分类\t方法名称\t用途\t可以生效的 HTTP 处理阶段请求头处理\tGetHttpRequestHeaders\t获取客户端请求的全部请求头\tHTTP 请求头处理阶段 ReplaceHttpRequestHeaders\t替换客户端请求的全部请求头\tHTTP 请求头处理阶段 GetHttpRequestHeader\t获取客户端请求的指定请求头\tHTTP 请求头处理阶段 RemoveHttpRequestHeader\t移除客户端请求的指定请求头\tHTTP 请求头处理阶段 ReplaceHttpRequestHeader\t替换客户端请求的指定请求头\tHTTP 请求头处理阶段 AddHttpRequestHeader\t新增一个客户端请求头\tHTTP 请求头处理阶段 请求 Body 处理\tGetHttpRequestBody\t获取客户端请求 Body\tHTTP 请求 Body 处理阶段 AppendHttpRequestBody\t将指定的字节串附加到客户端请求 Body 末尾\tHTTP 请求 Body 处理阶段 PrependHttpRequestBody\t将指定的字节串附加到客户端请求 Body 的开头\tHTTP 请求 Body 处理阶段 ReplaceHttpRequestBody\t替换客户端请求 Body\tHTTP 请求 Body 处理阶段 应答头处理\tGetHttpResponseHeaders\t获取后端响应的全部应答头\tHTTP 应答头处理阶段 ReplaceHttpResponseHeaders\t替换后端响应的全部应答头\tHTTP 应答头处理阶段 GetHttpResponseHeader\t获取后端响应的指定应答头\tHTTP 应答头处理阶段 RemoveHttpResponseHeader\t移除后端响应的指定应答头\tHTTP 应答头处理阶段 ReplaceHttpResponseHeader\t替换后端响应的指定应答头\tHTTP 应答头处理阶段 AddHttpResponseHeader\t新增一个后端响应头\tHTTP 应答头处理阶段 应答 Body 处理\tGetHttpResponseBody\t获取客户端请求 Body\tHTTP 应答 Body 处理阶段 AppendHttpResponseBody\t将指定的字节串附加到后端响应 Body 末尾\tHTTP 应答 Body 处理阶段 PrependHttpResponseBody\t将指定的字节串附加到后端响应 Body 的开头\tHTTP 应答 Body 处理阶段 ReplaceHttpResponseBody\t替换后端响应 Body\tHTTP 应答 Body 处理阶段 HTTP 调用\tDispatchHttpCall\t发送一个 HTTP 请求\t- GetHttpCallResponseHeaders\t获取 DispatchHttpCall 请求响应的应答头\t- GetHttpCallResponseBody\t获取 DispatchHttpCall 请求响应的应答 Body\t- GetHttpCallResponseTrailers\t获取 DispatchHttpCall 请求响应的应答 Trailer\t- 直接响应\tSendHttpResponse\t直接返回一个特定的 HTTP 应答\t- 流程恢复\tResumeHttpRequest\t恢复先前被暂停的请求处理流程\t- ResumeHttpResponse\t恢复先前被暂停的应答处理流程\t- ","version":"Next","tagName":"h3"},{"title":"3. 编译生成 WASM 文件​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#3-编译生成-wasm-文件","content":"go mod tidy tinygo build -o main.wasm -scheduler=none -target=wasi -gc=custom -tags=&quot;custommalloc nottinygc_finalizer&quot; ./  如果windows下编译出现error: could not find wasm-opt, set the WASMOPT environment variable to override 则需要下载https://github.com/WebAssembly/binaryen/ 里面包含了bin\\wasm-opt.exe将这个文件拷贝到tinygo的bin目录下重新编译即可。 编译成功会在当前目录下创建文件 main.wasm。这个文件在下面本地调试的例子中也会被用到。  如果linux/mac下编译出现该错误，使用apt/brew等系统自带包管理工具安装下binaryen即可，例如brew install binaryen 要在Higress中配合Wasmplugin CRD或者Console的UI交互配置该插件，需要将该wasm文件打包成oci或者docker镜像，可以参考这篇文档：《自定义插件》 ","version":"Next","tagName":"h3"},{"title":"三、本地调试​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#三本地调试","content":"","version":"Next","tagName":"h2"},{"title":"工具准备​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#工具准备","content":"安装Docker ","version":"Next","tagName":"h3"},{"title":"使用 docker compose 启动验证​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#使用-docker-compose-启动验证","content":"进入在编写插件时创建的目录，例如wasm-demo目录，确认该目录下已经编译生成了main.wasm文件。在目录下创建文件docker-compose.yaml，内容如下： version: '3.7' services: envoy: image: higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/gateway:v1.4.0-rc.1 entrypoint: /usr/local/bin/envoy # 注意这里对wasm开启了debug级别日志，正式部署时则默认info级别 command: -c /etc/envoy/envoy.yaml --component-log-level wasm:debug depends_on: - httpbin networks: - wasmtest ports: - &quot;10000:10000&quot; volumes: - ./envoy.yaml:/etc/envoy/envoy.yaml - ./main.wasm:/etc/envoy/main.wasm httpbin: image: kennethreitz/httpbin:latest networks: - wasmtest ports: - &quot;12345:80&quot; networks: wasmtest: {}  继续在该目录下创建文件envoy.yaml，内容如下： admin: address: socket_address: protocol: TCP address: 0.0.0.0 port_value: 9901 static_resources: listeners: - name: listener_0 address: socket_address: protocol: TCP address: 0.0.0.0 port_value: 10000 filter_chains: - filters: - name: envoy.filters.network.http_connection_manager typed_config: &quot;@type&quot;: type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager scheme_header_transformation: scheme_to_overwrite: https stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: local_service domains: [&quot;*&quot;] routes: - match: prefix: &quot;/&quot; route: cluster: httpbin http_filters: - name: wasmdemo typed_config: &quot;@type&quot;: type.googleapis.com/udpa.type.v1.TypedStruct type_url: type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm value: config: name: wasmdemo vm_config: runtime: envoy.wasm.runtime.v8 code: local: filename: /etc/envoy/main.wasm configuration: &quot;@type&quot;: &quot;type.googleapis.com/google.protobuf.StringValue&quot; value: | { &quot;mockEnable&quot;: false } - name: envoy.filters.http.router clusters: - name: httpbin connect_timeout: 30s type: LOGICAL_DNS # Comment out the following line to test on v6 networks dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN load_assignment: cluster_name: httpbin endpoints: - lb_endpoints: - endpoint: address: socket_address: address: httpbin port_value: 80  执行以下命令启动docker compose。 docker compose up  ","version":"Next","tagName":"h3"},{"title":"功能验证​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#功能验证","content":"WASM功能验证 使用curl直接访问httpbin，可以看到不经过网关时的请求头内容，如下： curl http://127.0.0.1:12345/get { &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Host&quot;: &quot;127.0.0.1:12345&quot;, &quot;User-Agent&quot;: &quot;curl/7.79.1&quot; }, &quot;origin&quot;: &quot;172.18.0.1&quot;, &quot;url&quot;: &quot;http://127.0.0.1:12345/get&quot; }  使用curl通过网关访问httpbin，可以看到经过网关处理后的请求头的内容，如下： curl http://127.0.0.1:10000/get { &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Hello&quot;: &quot;world&quot;, &quot;Host&quot;: &quot;127.0.0.1:10000&quot;, &quot;Original-Host&quot;: &quot;127.0.0.1:10000&quot;, &quot;Req-Start-Time&quot;: &quot;1681269273896&quot;, &quot;User-Agent&quot;: &quot;curl/7.79.1&quot;, &quot;X-Envoy-Expected-Rq-Timeout-Ms&quot;: &quot;15000&quot; }, &quot;origin&quot;: &quot;172.18.0.3&quot;, &quot;url&quot;: &quot;https://127.0.0.1:10000/get&quot; }  此时上文编写插件的功能已经生效了，加入了hello: world请求头。 插件配置修改验证 修改envoy.yaml，将mockEnable配置修改为true。  configuration: &quot;@type&quot;: &quot;type.googleapis.com/google.protobuf.StringValue&quot; value: | { &quot;mockEnable&quot;: true }  使用curl通过网关访问httpbin，可以看到经过网关处理后的请求头的内容，如下： curl http://127.0.0.1:10000/get hello world  说明插件配置修改生效，开启了mock应答直接返回了hello world。 ","version":"Next","tagName":"h3"},{"title":"更多示例​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#更多示例","content":"","version":"Next","tagName":"h2"},{"title":"无配置插件​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#无配置插件","content":"插件无需配置时，直接定义空结构体即可 package main import ( &quot;github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types&quot; ) func main() { wrapper.SetCtx( &quot;hello-world&quot;, wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders), ) } type MyConfig struct {} func onHttpRequestHeaders(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log) types.Action { proxywasm.SendHttpResponse(200, nil, []byte(&quot;hello world&quot;), -1) return types.ActionContinue }  ","version":"Next","tagName":"h3"},{"title":"在插件中请求外部服务​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#在插件中请求外部服务","content":"目前仅支持 http 调用，支持访问在网关控制台中设置了服务来源的 Nacos、K8s 服务，以及固定地址或 DNS 来源的服务。请注意，无法直接使用net/http库中的 HTTP client，必须使用如下例中封装的 HTTP client。 下面例子中，在配置解析阶段解析服务类型，生成对应的 HTTP client ；在请求头处理阶段根据配置的请求路径访问对应服务，解析应答头，然后再设置在原始的请求头中。 package main import ( &quot;errors&quot; &quot;net/http&quot; &quot;strings&quot; &quot;github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types&quot; &quot;github.com/tidwall/gjson&quot; ) func main() { wrapper.SetCtx( &quot;http-call&quot;, wrapper.ParseConfigBy(parseConfig), wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders), ) } type MyConfig struct { // 用于发起HTTP调用client client wrapper.HttpClient // 请求url requestPath string // 根据这个key取出调用服务的应答头对应字段，再设置到原始请求的请求头，key为此配置项 tokenHeader string } func parseConfig(json gjson.Result, config *MyConfig, log wrapper.Log) error { config.tokenHeader = json.Get(&quot;tokenHeader&quot;).String() if config.tokenHeader == &quot;&quot; { return errors.New(&quot;missing tokenHeader in config&quot;) } config.requestPath = json.Get(&quot;requestPath&quot;).String() if config.requestPath == &quot;&quot; { return errors.New(&quot;missing requestPath in config&quot;) } // 带服务类型的完整 FQDN 名称，例如 my-svc.dns, my-svc.static, service-provider.DEFAULT-GROUP.public.nacos, httpbin.my-ns.svc.cluster.local serviceName := json.Get(&quot;serviceName&quot;).String() servicePort := json.Get(&quot;servicePort&quot;).Int() if servicePort == 0 { if strings.HasSuffix(serviceName, &quot;.static&quot;) { // 静态IP类型服务的逻辑端口是80 servicePort = 80 } } config.client = wrapper.NewClusterClient(wrapper.FQDNCluster{ FQDN: serviceName, Port: servicePort, }) } func onHttpRequestHeaders(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log) types.Action { // 使用client的Get方法发起HTTP Get调用，此处省略了timeout参数，默认超时时间500毫秒 config.client.Get(config.requestPath, nil, // 回调函数，将在响应异步返回时被执行 func(statusCode int, responseHeaders http.Header, responseBody []byte) { // 请求没有返回200状态码，进行处理 if statusCode != http.StatusOK { log.Errorf(&quot;http call failed, status: %d&quot;, statusCode) proxywasm.SendHttpResponse(http.StatusInternalServerError, nil, []byte(&quot;http call failed&quot;), -1) return } // 打印响应的HTTP状态码和应答body log.Infof(&quot;get status: %d, response body: %s&quot;, statusCode, responseBody) // 从应答头中解析token字段设置到原始请求头中 token := responseHeaders.Get(config.tokenHeader) if token != &quot;&quot; { proxywasm.AddHttpRequestHeader(config.tokenHeader, token) } // 恢复原始请求流程，继续往下处理，才能正常转发给后端服务 proxywasm.ResumeHttpRequest() }) // 需要等待异步回调完成，返回Pause状态，可以被ResumeHttpRequest恢复 return types.ActionPause }  ","version":"Next","tagName":"h3"},{"title":"在插件中调用Redis​","type":1,"pageTitle":"使用 GO 语言开发 WASM 插件","url":"/zh-cn/docs/user/wasm-go#在插件中调用redis","content":"使用如下示例代码实现Redis限流插件 package main import ( &quot;strconv&quot; &quot;time&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm&quot; &quot;github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types&quot; &quot;github.com/tidwall/gjson&quot; &quot;github.com/tidwall/resp&quot; &quot;github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper&quot; ) func main() { wrapper.SetCtx( &quot;redis-demo&quot;, wrapper.ParseConfigBy(parseConfig), wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders), wrapper.ProcessResponseHeadersBy(onHttpResponseHeaders), ) } type RedisCallConfig struct { client wrapper.RedisClient qpm int } func parseConfig(json gjson.Result, config *RedisCallConfig, log wrapper.Log) error { // 带服务类型的完整 FQDN 名称，例如 my-redis.dns、redis.my-ns.svc.cluster.local serviceName := json.Get(&quot;serviceName&quot;).String() servicePort := json.Get(&quot;servicePort&quot;).Int() if servicePort == 0 { if strings.HasSuffix(serviceName, &quot;.static&quot;) { // 静态IP类型服务的逻辑端口是80 servicePort = 80 } else { servicePort = 6379 } } username := json.Get(&quot;username&quot;).String() password := json.Get(&quot;password&quot;).String() // 单位是毫秒 timeout := json.Get(&quot;timeout&quot;).Int() if timeout == 0 { timeout = 1000 } qpm := json.Get(&quot;qpm&quot;).Int() config.qpm = int(qpm) config.client = wrapper.NewRedisClusterClient(wrapper.FQDNCluster{ FQDN: serviceName, Port: servicePort, }) return config.client.Init(username, password, timeout) } func onHttpRequestHeaders(ctx wrapper.HttpContext, config RedisCallConfig, log wrapper.Log) types.Action { now := time.Now() minuteAligned := now.Truncate(time.Minute) timeStamp := strconv.FormatInt(minuteAligned.Unix(), 10) // 如果 redis api 返回的 err != nil，一般是由于网关找不到 redis 后端服务，请检查是否误删除了 redis 后端服务 err := config.client.Incr(timeStamp, func(response resp.Value) { if response.Error() != nil { log.Errorf(&quot;call redis error: %v&quot;, response.Error()) proxywasm.ResumeHttpRequest() } else { ctx.SetContext(&quot;timeStamp&quot;, timeStamp) ctx.SetContext(&quot;callTimeLeft&quot;, strconv.Itoa(config.qpm-response.Integer())) if response.Integer() == 1 { err := config.client.Expire(timeStamp, 60, func(response resp.Value) { if response.Error() != nil { log.Errorf(&quot;call redis error: %v&quot;, response.Error()) } proxywasm.ResumeHttpRequest() }) if err != nil { log.Errorf(&quot;Error occured while calling redis, it seems cannot find the redis cluster.&quot;) proxywasm.ResumeHttpRequest() } } else { if response.Integer() &gt; config.qpm { proxywasm.SendHttpResponse(429, [][2]string{{&quot;timeStamp&quot;, timeStamp}, {&quot;callTimeLeft&quot;, &quot;0&quot;}}, []byte(&quot;Too many requests\\n&quot;), -1) } else { proxywasm.ResumeHttpRequest() } } } }) if err != nil { // 由于调用redis失败，放行请求，记录日志 log.Errorf(&quot;Error occured while calling redis, it seems cannot find the redis cluster.&quot;) return types.ActionContinue } else { // 请求hold住，等待redis调用完成 return types.ActionPause } } func onHttpResponseHeaders(ctx wrapper.HttpContext, config RedisCallConfig, log wrapper.Log) types.Action { if ctx.GetContext(&quot;timeStamp&quot;) != nil { proxywasm.AddHttpResponseHeader(&quot;timeStamp&quot;, ctx.GetContext(&quot;timeStamp&quot;).(string)) } if ctx.GetContext(&quot;callTimeLeft&quot;) != nil { proxywasm.AddHttpResponseHeader(&quot;callTimeLeft&quot;, ctx.GetContext(&quot;callTimeLeft&quot;).(string)) } return types.ActionContinue }  ","version":"Next","tagName":"h3"}],"options":{"languages":["en","zh"],"id":"default"}}